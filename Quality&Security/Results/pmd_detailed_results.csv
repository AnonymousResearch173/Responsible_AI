Rule,Description,FullSnippet,ErrorLines,Source
AvoidFieldNameMatchingMethodName,Field id has the same name as a method,"import com.couchbase.client.core.error.DocumentNotFoundException;
import com.couchbase.client.java.Collection;
import com.couchbase.client.java.codec.RawJsonTranscoder;
import com.couchbase.client.java.json.JsonObject;
import com.couchbase.client.java.kv.GetResult;
import com.couchbase.client.java.kv.InsertOptions;
import com.couchbase.client.java.kv.MutationResult;

import static java.util.Objects.requireNonNull;

public class CouchbaseConnector {
  /**
   * Associates a document ID with a JsonObject.
   */
  public static class JsonDocument {
    private final String id;
    private final JsonObject content; // nullable!

    public JsonDocument(String id, JsonObject content) {
      this.id = requireNonNull(id);
      this.content = content;
    }

    public String id() {
      return id;
    }

    public JsonObject content() {
      return content;
    }
  }

  private final Collection collection;

  public CouchbaseConnector(Collection collection) {
    this.collection = requireNonNull(collection);
  }

  public MutationResult insert(String id, String jsonString) {
    // Use RawJsonTranscoder.INSTANCE when you have a String or byte array
    // containing pre-formatted JSON:
    return collection.insert(id, jsonString,
      InsertOptions.insertOptions()
        .transcoder(RawJsonTranscoder.INSTANCE)
    );
  }

  public MutationResult insert(String id, JsonObject jsonObject) {
    // Use the JsonTranscoder (the default) with JsonObject,
    // and any other Java object compatible with JSON data binding:
    return collection.insert(id, jsonObject);
  }

  public MutationResult insert(JsonDocument document) {
    return collection.insert(document.id(), document.content());
  }

  public GetResult retrieve(String id) throws DocumentNotFoundException {
    return collection.get(id);
  }

  @Deprecated
  public JsonDocument retrieveAsJsonObject(String id) throws DocumentNotFoundException {
    GetResult result = collection.get(id);
    return new JsonDocument(id, result.contentAsObject());
  }

  public MutationResult remove(String id) {
    try {
      return collection.remove(id);
    } catch (DocumentNotFoundException e) {
      return null;
    }
  }

  @Deprecated
  public JsonDocument removeAsJsonDocument(String id) {
    MutationResult result = remove(id);
    return result == null ? null : new JsonDocument(id, null);
  }
}",    private final String id;,StackOverflow
AvoidFieldNameMatchingMethodName,Field content has the same name as a method,"import com.couchbase.client.core.error.DocumentNotFoundException;
import com.couchbase.client.java.Collection;
import com.couchbase.client.java.codec.RawJsonTranscoder;
import com.couchbase.client.java.json.JsonObject;
import com.couchbase.client.java.kv.GetResult;
import com.couchbase.client.java.kv.InsertOptions;
import com.couchbase.client.java.kv.MutationResult;

import static java.util.Objects.requireNonNull;

public class CouchbaseConnector {
  /**
   * Associates a document ID with a JsonObject.
   */
  public static class JsonDocument {
    private final String id;
    private final JsonObject content; // nullable!

    public JsonDocument(String id, JsonObject content) {
      this.id = requireNonNull(id);
      this.content = content;
    }

    public String id() {
      return id;
    }

    public JsonObject content() {
      return content;
    }
  }

  private final Collection collection;

  public CouchbaseConnector(Collection collection) {
    this.collection = requireNonNull(collection);
  }

  public MutationResult insert(String id, String jsonString) {
    // Use RawJsonTranscoder.INSTANCE when you have a String or byte array
    // containing pre-formatted JSON:
    return collection.insert(id, jsonString,
      InsertOptions.insertOptions()
        .transcoder(RawJsonTranscoder.INSTANCE)
    );
  }

  public MutationResult insert(String id, JsonObject jsonObject) {
    // Use the JsonTranscoder (the default) with JsonObject,
    // and any other Java object compatible with JSON data binding:
    return collection.insert(id, jsonObject);
  }

  public MutationResult insert(JsonDocument document) {
    return collection.insert(document.id(), document.content());
  }

  public GetResult retrieve(String id) throws DocumentNotFoundException {
    return collection.get(id);
  }

  @Deprecated
  public JsonDocument retrieveAsJsonObject(String id) throws DocumentNotFoundException {
    GetResult result = collection.get(id);
    return new JsonDocument(id, result.contentAsObject());
  }

  public MutationResult remove(String id) {
    try {
      return collection.remove(id);
    } catch (DocumentNotFoundException e) {
      return null;
    }
  }

  @Deprecated
  public JsonDocument removeAsJsonDocument(String id) {
    MutationResult result = remove(id);
    return result == null ? null : new JsonDocument(id, null);
  }
}",    private final JsonObject content; // nullable!,StackOverflow
AvoidFieldNameMatchingTypeName,It is somewhat confusing to have a field name matching the declaring class name,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(8080);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            DataInputStream input = new DataInputStream(new BufferedInputStream(client.getInputStream()));
            DataOutputStream output = new DataOutputStream(new BufferedOutputStream(client.getOutputStream()));

            int op = input.readInt();
            int num1 = input.readInt();
            int num2 = input.readInt();
            int num3 = input.readInt();

            switch (op) {
                case 0:
                    output.writeInt(num1 + num2 + num3);
                    output.flush();
                    break;
                case 1:
                    output.writeInt(num1 - num2 - num3);
                    output.flush();
                    break;
                case 2:
                    output.writeInt(num1 * num2 * num3);
                    output.flush();
                    break;
            }

            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            System.out.print(e);
        }
    }
}",    ServerSocket server = new ServerSocket(8080);,StackOverflow
CloseResource,Ensure that resources like this Socket object are closed after use,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(8080);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            DataInputStream input = new DataInputStream(new BufferedInputStream(client.getInputStream()));
            DataOutputStream output = new DataOutputStream(new BufferedOutputStream(client.getOutputStream()));

            int op = input.readInt();
            int num1 = input.readInt();
            int num2 = input.readInt();
            int num3 = input.readInt();

            switch (op) {
                case 0:
                    output.writeInt(num1 + num2 + num3);
                    output.flush();
                    break;
                case 1:
                    output.writeInt(num1 - num2 - num3);
                    output.flush();
                    break;
                case 2:
                    output.writeInt(num1 * num2 * num3);
                    output.flush();
                    break;
            }

            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            System.out.print(e);
        }
    }
}",            Socket client = server.accept();,StackOverflow
CloseResource,Ensure that resources like this DataInputStream object are closed after use,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(8080);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            DataInputStream input = new DataInputStream(new BufferedInputStream(client.getInputStream()));
            DataOutputStream output = new DataOutputStream(new BufferedOutputStream(client.getOutputStream()));

            int op = input.readInt();
            int num1 = input.readInt();
            int num2 = input.readInt();
            int num3 = input.readInt();

            switch (op) {
                case 0:
                    output.writeInt(num1 + num2 + num3);
                    output.flush();
                    break;
                case 1:
                    output.writeInt(num1 - num2 - num3);
                    output.flush();
                    break;
                case 2:
                    output.writeInt(num1 * num2 * num3);
                    output.flush();
                    break;
            }

            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            System.out.print(e);
        }
    }
}",            DataInputStream input = new DataInputStream(new BufferedInputStream(client.getInputStream()));,StackOverflow
CloseResource,Ensure that resources like this DataOutputStream object are closed after use,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(8080);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            DataInputStream input = new DataInputStream(new BufferedInputStream(client.getInputStream()));
            DataOutputStream output = new DataOutputStream(new BufferedOutputStream(client.getOutputStream()));

            int op = input.readInt();
            int num1 = input.readInt();
            int num2 = input.readInt();
            int num3 = input.readInt();

            switch (op) {
                case 0:
                    output.writeInt(num1 + num2 + num3);
                    output.flush();
                    break;
                case 1:
                    output.writeInt(num1 - num2 - num3);
                    output.flush();
                    break;
                case 2:
                    output.writeInt(num1 * num2 * num3);
                    output.flush();
                    break;
            }

            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            System.out.print(e);
        }
    }
}",            DataOutputStream output = new DataOutputStream(new BufferedOutputStream(client.getOutputStream()));,StackOverflow
NullAssignment,Assigning an Object to null is a code smell.  Consider refactoring.,"@Entity
public class Day {
    @PrimaryKey
    Long dayId = null;
    String date;
    Float weight;
    /* etc */

    Day(){} /* Room will use this constructor */
    @Ignore /* Tell Room to ignore this constructor, but still usable outside of Room, so makes life easier */
    Day(String date, Float weight) {
        this.dayId = null; /* not needed but effectively what happens */
        this.date = date;
        this.weight = weight;
    }
    /* No getters and setters required as members aren't private/protected */
}",        this.dayId = null; /* not needed but effectively what happens */,StackOverflow
TestClassWithoutTestCases,"The class 'ApplicationTest' might be a test class, but it contains no test cases.","import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackageClasses = { PredefinedAspect.class } )
public class ApplicationTest {
    public void main(String args[]) {
        SpringBootApplication.run(ApplicationTest.class, args);
    }
}",public class ApplicationTest {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new DrawPane(300, 300));
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class DrawPane extends JPanel {

        int height, radius;

        public DrawPane(int myRadius, int myHeight) {
            super();
            radius = myRadius;
            height = myHeight;
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(400, 400);
        }

        public void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();

            int x = (getWidth() - radius) / 2;
            int y = (getHeight() - (height + (radius / 4))) / 2;

            g2d.translate(x, y);

            g2d.setColor(Color.LIGHT_GRAY);
            g2d.drawRect(0, 0, radius, height + (radius / 4));

            // Base
            g2d.setColor(Color.RED);
            g2d.fillOval(0, height - (radius / 4), radius, radius / 2);

            g2d.setColor(Color.BLACK);
            g2d.drawOval(0, 0, radius, radius / 2);

            g2d.setColor(Color.BLACK);
            g2d.drawLine(0, radius / 4, 0, height);
            g2d.drawLine(radius, radius / 4, radius, height);

            g2d.dispose();
        }
    }
}",    public class DrawPane extends JPanel {,StackOverflow
AvoidFieldNameMatchingTypeName,It is somewhat confusing to have a field name matching the declaring class name,"public class ID {
    long id = 0L;
    int occurrence = 0;

    public ID(long id, int uses) {
        this.id = id;
        occurrence = uses;
    }

    public long getID() {
        return(id);
    }
    
    public int getOccurs() {
        return(occurrence);
    }
}",    long id = 0L;,StackOverflow
TestClassWithoutTestCases,"The class 'CalculatorTest' might be a test class, but it contains no test cases.","public class Calculator {
    public int subtract(int a, int b) {
        return a - b;
    }
}

@RequiredArgsConstructor
@RunWith(Parameterized.class)
class CalculatorTest {
    private final int x;
    private final int y;
    private final int z;
    private Calculator calculator;
 
    // Constructor is generated by lombok with @RequiredArgsConstructor
    // and accepts three parameters, x, y, and z

    @BeforeEach
    void setUp() {
        calculator = new Calculator();
    }

    @Test
    void testSubtract() {
        assertEquals(z, calculator.subtract(x, y));
    }
    
    /**
     * This method will pass each parameter into the constructor
     * of this test class. In this case, the testSubtract method
     * will be ran 4 times with each set of parameters.
     */
    @Parameterized.Parameters
    static Collection parameters() {
        return Arrays.asList(
            new Object[][] {
               {5, 3, 2},
               {10, 1, 9},
               {120, 40, 80},
               {1, 1, 0}
            }
        );
    }
}",class CalculatorTest {,StackOverflow
DoNotTerminateVM,System.exit() should not be used in J2EE/JEE apps,"public class Main {
    public static void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_A) {
            System.exit(0);
        }
    }

    public static void main(String[] args) {
        JFrame GUI = new JFrame();
        GUI.setSize(300, 300);
        GUI.setLayout(null);
        GUI.setVisible(true);
        GUI.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                Main.keyPressed(e);
            }
        });
    }
}",            System.exit(0);,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","class Test {
    String field2, field1, field3;

    public Test(String field1, String field2, String field3) {
        this.field1 = field1;
        this.field2 = field2;
        this.field3 = field3;
    }
}",class Test {,StackOverflow
AvoidFieldNameMatchingMethodName,Field isWhite has the same name as a method,"public static abstract class Piece extends JButton {
    private final boolean isWhite;
    private Point cell;

    public Piece(int x, int y, boolean isWhite) {
        cell = new Point(x, y);
        this.isWhite = isWhite;
    }

    public Point getCell() {
        return cell;
    }

    public boolean isWhite() {
        return isWhite;
    }

    public boolean canMoveTo(int toX, int toY) {
        return true;
    }
}",    private final boolean isWhite;,StackOverflow
AvoidFieldNameMatchingMethodName,Field isEnabled has the same name as a method,"public abstract class ToggledActionListener implements java.awt.event.ActionListener {

    private boolean isEnabled;

    public ToggledActionListener(){
        isEnabled = true;
    }

    public void setEnabled(boolean flag){
        isEnabled = flag;
    }

    public boolean isEnabled(){
        return  isEnabled;
    }

    @Override
    public final void actionPerformed(ActionEvent e) {
        if(isEnabled){
            runIfAllowed(e);
        }
    }

    abstract void runIfAllowed(ActionEvent e);
}",    private boolean isEnabled;,StackOverflow
NullAssignment,Assigning an Object to null is a code smell.  Consider refactoring.,"public class network_detector extends BroadcastReceiver {

    private AlertDialog dialog;

    @Override
    public void onReceive(Context context, Intent intent) {
         if (dialog != null) {
            boolean isConnected = networkClass.isConnectedToInternet(context);
            if (isConnected) {
                dialog.dismiss();
                dialog = null;
            } else if (!dialog.isShowing()) {
                showNoInternetDialog(context);
            }
        } else {
            showNoInternetDialog(context);
        }

}


    private void showNoInternetDialog(Context context) {
        View alertdialogView = LayoutInflater.from(context).inflate(R.layout.network_dialog, null);
        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(context);
        dialogBuilder.setView(alertdialogView);

        dialog = dialogBuilder.create();
        dialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));

        dialog.setCancelable(false);
        dialog.show();
    }
}",                dialog = null;,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"// MyCustomException.java
public class MyCustomException extends Exception {

  String errorReason;
  int errorCode;
  
  public MyCustomException(Throwable throwable, String errorReason, int errorCode) {
    super(errorReason, throwable);
    this.errorReason = errorReason;
    this.errorCode = errorCode;
  }
}",public class MyCustomException extends Exception {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"private static class VariableLeadingParagraphRenderer extends ParagraphRenderer {
    public VariableLeadingParagraphRenderer(Paragraph modelElement) {
        super(modelElement);
    }

    @Override
    public LayoutResult layout(LayoutContext layoutContext) {
        setLeadingBasedOnPageNumber(layoutContext.getArea().getPageNumber());
        return super.layout(layoutContext);
    }

    private void setLeadingBasedOnPageNumber(int pageNumber) {
        if (pageNumber == 1) {
            this.setProperty(Property.LEADING, new Leading(Leading.FIXED, 100));
        } else {
            this.setProperty(Property.LEADING, new Leading(Leading.FIXED, 50));
        }
    }

    @Override
    public IRenderer getNextRenderer() {
        return new ParagraphRenderer((Paragraph) modelElement);
    }
}",        if (pageNumber == 1) {,StackOverflow
TestClassWithoutTestCases,"The class 'ApplicationTest' might be a test class, but it contains no test cases.","@Configuration
@SpringBootApplication
public class ApplicationTest {}",public class ApplicationTest {},StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"package de.scrum_master.stackoverflow.q74575745;

class WebClientException extends RuntimeException {
  public WebClientException(Throwable cause) {
    super(cause);
  }
}",class WebClientException extends RuntimeException {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"package lol;

import static io.vavr.API.$;
import static io.vavr.API.Case;
import static io.vavr.API.Match;
import static io.vavr.API.run;
import static io.vavr.Patterns.$None;
import static io.vavr.Patterns.$Some;

import io.vavr.control.Option;

public class Lol {

  public static void main(String[] args) {
    String val = ""lol"";
    Match(Option.of(val)).of(
        Case($None(), () -> run(() -> {
          System.out.println(1);
          throw new IllegalArgumentException(""null"");
        })),
        Case($Some($(String::isEmpty)), () -> run(() -> {
          System.out.println(2);
          throw new IllegalArgumentException(""empty"");
        })),
        Case($(), () -> run(() -> {
          System.out.println(3);
          if (""lol"".equals(val)) {
            throw new IllegalArgumentException(""lol"");
          }
        }))
    )
    ;
  }
}","          if (""lol"".equals(val)) {",StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

public class CreatePPTXNunberings {
    
 static void createBulletpointList(XSLFTextShape textShape, String[] items) {
  XSLFTextParagraph paragraph = null;
  XSLFTextRun run = null;
  double fontSize = 22d;
  double indent = 22d;
  for (String item : items) {
   paragraph = textShape.addNewTextParagraph();
   paragraph.setBullet(true); //XSLFTextParagraph.setBullet sets pPr too
   paragraph.getXmlObject().getPPr().setMarL(org.apache.poi.util.Units.toEMU(indent));
   paragraph.setIndent(-indent);
   run = paragraph.addNewTextRun();
   run.setFontSize(fontSize);
   run.setText(item);
  }   
 }
 
 static void createNumberedList(XSLFTextShape textShape, String[] items) {
  XSLFTextParagraph paragraph = null;
  XSLFTextRun run = null;
  double fontSize = 22d;
  double indent = 32d;
  for (String item : items) {
   paragraph = textShape.addNewTextParagraph();
   if (paragraph.getXmlObject().getPPr() == null) paragraph.getXmlObject().addNewPPr();
   if (paragraph.getXmlObject().getPPr().getBuAutoNum() == null) paragraph.getXmlObject().getPPr().addNewBuAutoNum();
   paragraph.getXmlObject().getPPr().getBuAutoNum().setType(org.openxmlformats.schemas.drawingml.x2006.main.STTextAutonumberScheme.ARABIC_PERIOD);
   paragraph.getXmlObject().getPPr().setMarL(org.apache.poi.util.Units.toEMU(indent));
   paragraph.setIndent(-indent);
   run = paragraph.addNewTextRun();
   run.setFontSize(fontSize);
   run.setText(item);
  }   
 }

 public static void main(String[] args) throws Exception {

  XMLSlideShow slideShow = new XMLSlideShow();
  
  XSLFSlide slide = slideShow.createSlide();
  
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 300);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  XSLFTextRun run = null;
  double fontSize = 22d;
  
  paragraph = textShape.addNewTextParagraph();
  run = paragraph.addNewTextRun();
  run.setFontSize(fontSize);
  run.setText(""Following is a bullet point list:"");
  
  createBulletpointList(textShape, 
   new String[]{""First list item"", ""Second list item, a little bit longer to show automatic line breaks"", ""Third list item""}
  );
  
  paragraph = textShape.addNewTextParagraph();
  
  paragraph = textShape.addNewTextParagraph();
  run = paragraph.addNewTextRun();
  run.setFontSize(fontSize);
  run.setText(""Following is a numbered list:"");
  
  createNumberedList(textShape, 
   new String[]{""First list item"", ""Second list item, a little bit longer to show automatic line breaks"", ""Third list item""}
  );

  FileOutputStream out = new FileOutputStream(""./CreatePPTXNunberings.pptx"");
  slideShow.write(out);
  out.close();
  slideShow.close();

 }
}","  FileOutputStream out = new FileOutputStream(""./CreatePPTXNunberings.pptx"");",StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","public class Test {

    public static void main(String[] args) throws InterruptedException {

        Thread t = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    System.out.println(""worker is sleeping"");
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    // flag is cleared when exception is thrown,
                    //  and needs to be set again
                    Thread.currentThread().interrupt();
                }                
            }
            System.out.println(""worker terminating"");
        });
        t.start();
        System.out.println(""main thread sleeping"");
        Thread.sleep(1000);
        System.out.println(""main thread interrupts worker and waits for it to finish"");
        t.interrupt();
        t.join();
    }
}",public class Test {,StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"package pkg;

import java.io.FileDescriptor;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;

public class Main {

    public static void main(String[] args) throws IOException {
        
        String str = ""Â¿Ã¦ÅÃ©Ä°Ã¼ÅÃ¯ÄÅÄÃ¸""; // Sample data from the question.
        
        System.out.println(""1: "" + str); // Fails if default charset is not UTF-8.  

        // Redirect System.out to use a PrintStream using UTF-8 charset.
        FileOutputStream fos2 = new FileOutputStream(FileDescriptor.out);
        PrintStream ps2 = new PrintStream(fos2, true, StandardCharsets.UTF_8);
        System.setOut(ps2);
        System.out.println(""2: "" + str); // Works.
        
        // Use your own PrintStream with UTF-8 charset instead of using System.out.
        FileOutputStream fos3 = new FileOutputStream(FileDescriptor.out);
        PrintStream ps3 = new PrintStream(fos3, true, StandardCharsets.UTF_8);
        ps3.print(""3: "" + str); // Works.
        ps3.close();
    }
}",        FileOutputStream fos2 = new FileOutputStream(FileDescriptor.out);,StackOverflow
CloseResource,Ensure that resources like this PrintStream object are closed after use,"package pkg;

import java.io.FileDescriptor;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;

public class Main {

    public static void main(String[] args) throws IOException {
        
        String str = ""Â¿Ã¦ÅÃ©Ä°Ã¼ÅÃ¯ÄÅÄÃ¸""; // Sample data from the question.
        
        System.out.println(""1: "" + str); // Fails if default charset is not UTF-8.  

        // Redirect System.out to use a PrintStream using UTF-8 charset.
        FileOutputStream fos2 = new FileOutputStream(FileDescriptor.out);
        PrintStream ps2 = new PrintStream(fos2, true, StandardCharsets.UTF_8);
        System.setOut(ps2);
        System.out.println(""2: "" + str); // Works.
        
        // Use your own PrintStream with UTF-8 charset instead of using System.out.
        FileOutputStream fos3 = new FileOutputStream(FileDescriptor.out);
        PrintStream ps3 = new PrintStream(fos3, true, StandardCharsets.UTF_8);
        ps3.print(""3: "" + str); // Works.
        ps3.close();
    }
}","        PrintStream ps2 = new PrintStream(fos2, true, StandardCharsets.UTF_8);",StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"package pkg;

import java.io.FileDescriptor;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;

public class Main {

    public static void main(String[] args) throws IOException {
        
        String str = ""Â¿Ã¦ÅÃ©Ä°Ã¼ÅÃ¯ÄÅÄÃ¸""; // Sample data from the question.
        
        System.out.println(""1: "" + str); // Fails if default charset is not UTF-8.  

        // Redirect System.out to use a PrintStream using UTF-8 charset.
        FileOutputStream fos2 = new FileOutputStream(FileDescriptor.out);
        PrintStream ps2 = new PrintStream(fos2, true, StandardCharsets.UTF_8);
        System.setOut(ps2);
        System.out.println(""2: "" + str); // Works.
        
        // Use your own PrintStream with UTF-8 charset instead of using System.out.
        FileOutputStream fos3 = new FileOutputStream(FileDescriptor.out);
        PrintStream ps3 = new PrintStream(fos3, true, StandardCharsets.UTF_8);
        ps3.print(""3: "" + str); // Works.
        ps3.close();
    }
}",        FileOutputStream fos3 = new FileOutputStream(FileDescriptor.out);,StackOverflow
CloseResource,Ensure that resources like this PrintStream object are closed after use,"package pkg;

import java.io.FileDescriptor;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;

public class Main {

    public static void main(String[] args) throws IOException {
        
        String str = ""Â¿Ã¦ÅÃ©Ä°Ã¼ÅÃ¯ÄÅÄÃ¸""; // Sample data from the question.
        
        System.out.println(""1: "" + str); // Fails if default charset is not UTF-8.  

        // Redirect System.out to use a PrintStream using UTF-8 charset.
        FileOutputStream fos2 = new FileOutputStream(FileDescriptor.out);
        PrintStream ps2 = new PrintStream(fos2, true, StandardCharsets.UTF_8);
        System.setOut(ps2);
        System.out.println(""2: "" + str); // Works.
        
        // Use your own PrintStream with UTF-8 charset instead of using System.out.
        FileOutputStream fos3 = new FileOutputStream(FileDescriptor.out);
        PrintStream ps3 = new PrintStream(fos3, true, StandardCharsets.UTF_8);
        ps3.print(""3: "" + str); // Works.
        ps3.close();
    }
}","        PrintStream ps3 = new PrintStream(fos3, true, StandardCharsets.UTF_8);",StackOverflow
CloseResource,Ensure that resources like this FileInputStream object are closed after use,"import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import ar.com.hjg.pngj.FilterType;
import ar.com.hjg.pngj.ImageInfo;
import ar.com.hjg.pngj.PngWriter;

public class RGB1 {

public static void main(String[] args) throws IOException {

    final int CHUNK_SIZE = 134217728;
    final int SIDE = 5; // Dimensions hard coded to square 5 X 5, please change as needed

    byte[] buf = new byte[CHUNK_SIZE];

    int br, i,j,row=0;
    int[] arr = new int[SIDE*3];// 3 Bytes per pixel

    FileInputStream fileInputStream=new FileInputStream(""C:\\Don\\source.bin"");
    OutputStream os = new FileOutputStream(""C:\\Don\\dest.png"");

    ImageInfo imi = new ImageInfo(SIDE, SIDE, 8, false);

    PngWriter pngw = new PngWriter(os, imi);
    pngw.setCompLevel(9);// maximum compression
    pngw.setFilterType(FilterType.FILTER_ADAPTIVE_FAST); 
    //Please Refer https://github.com/leonbloy/pngj/blob/master/src/main/java/ar/com/hjg/pngj/FilterType.java

    br = fileInputStream.read(buf);
    j=0; 
    System.out.println(""Bytes Read: "" + br);
    while(br>0)
    {
        for(i=0;i<br;i++)
        {
            arr[j++] = buf[i] & 0xFF;

            if(j==SIDE*3)
            {
                pngw.writeRowInt(arr);

                j=0;
                row++;
                if(row==SIDE) break;
            }

        }
        if(row==SIDE) break;
        br = fileInputStream.read(buf);
        System.out.println(""Bytes Read: "" + br);
    }

    pngw.end();

    System.out.println(""Done."");
    fileInputStream.close();

}

}","    FileInputStream fileInputStream=new FileInputStream(""C:\\Don\\source.bin"");",StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import ar.com.hjg.pngj.FilterType;
import ar.com.hjg.pngj.ImageInfo;
import ar.com.hjg.pngj.PngWriter;

public class RGB1 {

public static void main(String[] args) throws IOException {

    final int CHUNK_SIZE = 134217728;
    final int SIDE = 5; // Dimensions hard coded to square 5 X 5, please change as needed

    byte[] buf = new byte[CHUNK_SIZE];

    int br, i,j,row=0;
    int[] arr = new int[SIDE*3];// 3 Bytes per pixel

    FileInputStream fileInputStream=new FileInputStream(""C:\\Don\\source.bin"");
    OutputStream os = new FileOutputStream(""C:\\Don\\dest.png"");

    ImageInfo imi = new ImageInfo(SIDE, SIDE, 8, false);

    PngWriter pngw = new PngWriter(os, imi);
    pngw.setCompLevel(9);// maximum compression
    pngw.setFilterType(FilterType.FILTER_ADAPTIVE_FAST); 
    //Please Refer https://github.com/leonbloy/pngj/blob/master/src/main/java/ar/com/hjg/pngj/FilterType.java

    br = fileInputStream.read(buf);
    j=0; 
    System.out.println(""Bytes Read: "" + br);
    while(br>0)
    {
        for(i=0;i<br;i++)
        {
            arr[j++] = buf[i] & 0xFF;

            if(j==SIDE*3)
            {
                pngw.writeRowInt(arr);

                j=0;
                row++;
                if(row==SIDE) break;
            }

        }
        if(row==SIDE) break;
        br = fileInputStream.read(buf);
        System.out.println(""Bytes Read: "" + br);
    }

    pngw.end();

    System.out.println(""Done."");
    fileInputStream.close();

}

}","    OutputStream os = new FileOutputStream(""C:\\Don\\dest.png"");",StackOverflow
ConstructorCallsOverridableMethod,"This method may call an overridable method during object construction: Main.getPreferredSize() (call stack: [Main.draw(), Main.getPreferredSize()])","public class Main extends JPanel {

    private static JFrame frame;
    private static Container contentPanel;

    Main() {
        draw();
    }

    // draw game textures
    private void draw() {
        setLayout(new GridLayout(8, 8));
        double w = getPreferredSize().getWidth(),
               h = getPreferredSize().getHeight();
        Dimension d = new Dimension((int) (w / 8), (int) (h / 8));
        Color cb = Color.black, cw = Color.white;
        boolean b = true;
        JLabel label;
        for (int i = 0; i < 8 * 8; i++) {
            label = new JLabel();
            label.setPreferredSize(d);
            b = i % 8 == 0 == b;
            label.setBackground(b ? cb : cw);
            label.setOpaque(true);
            add(label);
        }
    }

    // define preferred size
    @Override
    public Dimension getPreferredSize() {
        return new Dimension(800, 800);
    }

    // create GUI
    private static void createAndShowGui() {
        Main main = new Main();

        frame = new JFrame(""Java Chess V1.0"");
        contentPanel = frame.getContentPane();
        contentPanel.add(main);

        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createAndShowGui();
            }
        });
    }
}",        draw();,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","public class Test {

    public static void main(String[] args) {
        // Uncomment the following line to see the difference
        // args.hashCode();

        int exceptionCount = 0;
        while (true) {
            try {
                ((Object) null).hashCode();
            } catch (Exception e) {
                exceptionCount++;
                if (e.getStackTrace().length == 0) {
                    System.out.println(exceptionCount);
                    break;
                }
            }
        }
    }
}",public class Test {,StackOverflow
ConstructorCallsOverridableMethod,This method may call an overridable method during object construction: SOQ_20220430.<T extends SOQ_20220430#AgentA> findFirst(Collection<T>) (call stack: [SOQ_20220430.<T extends SOQ_20220430#AgentA> findFirst(Collection<T>)]),"import java.util.Collection;
import java.util.List;

public class SOQ_20220430
{

   class AgentA
   {
   
      public final boolean condition1;
      public final boolean condition2;
      
      /** Potentially other fields. */
      
      public AgentA(boolean condition1, boolean condition2)
      {
      
         this.condition1 = condition1;
         this.condition2 = condition2;
      
      }
      
      public boolean bothTrue()
      {
      
         return condition1 && condition2;
      
      }
      
      public String toString()
      {
      
         return
            this.getClass().getName() 
               + ""{ condition1 = "" + this.condition1
               + "", condition2 = "" + this.condition2 + ""}"";
      
      }
      
      /** Potentially other methods. */
   
   }
   
   class AgentB extends AgentA { 
      public AgentB(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   class AgentC extends AgentA { 
      public AgentC(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   class AgentD extends AgentA { 
      public AgentD(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   public SOQ_20220430()
   {
   
      final List<AgentB> popB = List.of(new AgentB(false, false), new AgentB(true, true));
      final List<AgentC> popC = List.of(new AgentC(false, false), new AgentC(true, true));
      final List<AgentD> popD = List.of(new AgentD(false, false), new AgentD(true, true));
      
      System.out.println(findFirst(popB));
      System.out.println(findFirst(popC));
      System.out.println(findFirst(popD));
   
   }
   
   public <T extends AgentA> T findFirst(Collection<T> popT)
   {
   
      for (T each : popT)
      {
      
         if (each.bothTrue())
         {
         
            return each;
         
         }
      
      }
   
      throw new IllegalStateException(""Couldn't find one!"");
   
   }
   
   public static void main(String[] args)
   {
   
      new SOQ_20220430();
   
   }

}",      System.out.println(findFirst(popB));,StackOverflow
ConstructorCallsOverridableMethod,This method may call an overridable method during object construction: SOQ_20220430.<T extends SOQ_20220430#AgentA> findFirst(Collection<T>) (call stack: [SOQ_20220430.<T extends SOQ_20220430#AgentA> findFirst(Collection<T>)]),"import java.util.Collection;
import java.util.List;

public class SOQ_20220430
{

   class AgentA
   {
   
      public final boolean condition1;
      public final boolean condition2;
      
      /** Potentially other fields. */
      
      public AgentA(boolean condition1, boolean condition2)
      {
      
         this.condition1 = condition1;
         this.condition2 = condition2;
      
      }
      
      public boolean bothTrue()
      {
      
         return condition1 && condition2;
      
      }
      
      public String toString()
      {
      
         return
            this.getClass().getName() 
               + ""{ condition1 = "" + this.condition1
               + "", condition2 = "" + this.condition2 + ""}"";
      
      }
      
      /** Potentially other methods. */
   
   }
   
   class AgentB extends AgentA { 
      public AgentB(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   class AgentC extends AgentA { 
      public AgentC(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   class AgentD extends AgentA { 
      public AgentD(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   public SOQ_20220430()
   {
   
      final List<AgentB> popB = List.of(new AgentB(false, false), new AgentB(true, true));
      final List<AgentC> popC = List.of(new AgentC(false, false), new AgentC(true, true));
      final List<AgentD> popD = List.of(new AgentD(false, false), new AgentD(true, true));
      
      System.out.println(findFirst(popB));
      System.out.println(findFirst(popC));
      System.out.println(findFirst(popD));
   
   }
   
   public <T extends AgentA> T findFirst(Collection<T> popT)
   {
   
      for (T each : popT)
      {
      
         if (each.bothTrue())
         {
         
            return each;
         
         }
      
      }
   
      throw new IllegalStateException(""Couldn't find one!"");
   
   }
   
   public static void main(String[] args)
   {
   
      new SOQ_20220430();
   
   }

}",      System.out.println(findFirst(popC));,StackOverflow
ConstructorCallsOverridableMethod,This method may call an overridable method during object construction: SOQ_20220430.<T extends SOQ_20220430#AgentA> findFirst(Collection<T>) (call stack: [SOQ_20220430.<T extends SOQ_20220430#AgentA> findFirst(Collection<T>)]),"import java.util.Collection;
import java.util.List;

public class SOQ_20220430
{

   class AgentA
   {
   
      public final boolean condition1;
      public final boolean condition2;
      
      /** Potentially other fields. */
      
      public AgentA(boolean condition1, boolean condition2)
      {
      
         this.condition1 = condition1;
         this.condition2 = condition2;
      
      }
      
      public boolean bothTrue()
      {
      
         return condition1 && condition2;
      
      }
      
      public String toString()
      {
      
         return
            this.getClass().getName() 
               + ""{ condition1 = "" + this.condition1
               + "", condition2 = "" + this.condition2 + ""}"";
      
      }
      
      /** Potentially other methods. */
   
   }
   
   class AgentB extends AgentA { 
      public AgentB(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   class AgentC extends AgentA { 
      public AgentC(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   class AgentD extends AgentA { 
      public AgentD(boolean c1, boolean c2) { super(c1, c2); }
   }
   
   public SOQ_20220430()
   {
   
      final List<AgentB> popB = List.of(new AgentB(false, false), new AgentB(true, true));
      final List<AgentC> popC = List.of(new AgentC(false, false), new AgentC(true, true));
      final List<AgentD> popD = List.of(new AgentD(false, false), new AgentD(true, true));
      
      System.out.println(findFirst(popB));
      System.out.println(findFirst(popC));
      System.out.println(findFirst(popD));
   
   }
   
   public <T extends AgentA> T findFirst(Collection<T> popT)
   {
   
      for (T each : popT)
      {
      
         if (each.bothTrue())
         {
         
            return each;
         
         }
      
      }
   
      throw new IllegalStateException(""Couldn't find one!"");
   
   }
   
   public static void main(String[] args)
   {
   
      new SOQ_20220430();
   
   }

}",      System.out.println(findFirst(popD));,StackOverflow
CompareObjectsWithEquals,Use equals() to compare object references.,"import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.util.ArrayList;
import java.util.List;

public final class Main {
    public static void main(String[] args) {

        String plainText = ""Hello World"";
        String htmlText = ""<html><body><h1>This is a test</h1></body></html>"";

        HtmlSelection htmlSelection = new HtmlSelection(htmlText, plainText);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(htmlSelection, null);
    }

    public static class HtmlSelection implements Transferable {

        private static List<DataFlavor> htmlFlavors = new ArrayList<>(3);

        static {
                htmlFlavors.add(DataFlavor.stringFlavor);
                htmlFlavors.add(DataFlavor.allHtmlFlavor);
        }

        private String html;
        private String plainText;

        public HtmlSelection(String html, String plainText) {
            this.html = html;
            this.plainText = plainText;
        }

        public DataFlavor[] getTransferDataFlavors() {
            return (DataFlavor[]) htmlFlavors.toArray(new DataFlavor[htmlFlavors.size()]);
        }

        public boolean isDataFlavorSupported(DataFlavor flavor) {
            return htmlFlavors.contains(flavor);
        }

        public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {

            String toBeExported = plainText;
            if (flavor == DataFlavor.stringFlavor) {
                toBeExported = plainText;
            } else if (flavor == DataFlavor.allHtmlFlavor) {
                toBeExported = html;
            }

            if (String.class.equals(flavor.getRepresentationClass())) {
                return toBeExported;
            }
            throw new UnsupportedFlavorException(flavor);
        }
    }
}",            if (flavor == DataFlavor.stringFlavor) {,StackOverflow
CompareObjectsWithEquals,Use equals() to compare object references.,"import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.util.ArrayList;
import java.util.List;

public final class Main {
    public static void main(String[] args) {

        String plainText = ""Hello World"";
        String htmlText = ""<html><body><h1>This is a test</h1></body></html>"";

        HtmlSelection htmlSelection = new HtmlSelection(htmlText, plainText);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(htmlSelection, null);
    }

    public static class HtmlSelection implements Transferable {

        private static List<DataFlavor> htmlFlavors = new ArrayList<>(3);

        static {
                htmlFlavors.add(DataFlavor.stringFlavor);
                htmlFlavors.add(DataFlavor.allHtmlFlavor);
        }

        private String html;
        private String plainText;

        public HtmlSelection(String html, String plainText) {
            this.html = html;
            this.plainText = plainText;
        }

        public DataFlavor[] getTransferDataFlavors() {
            return (DataFlavor[]) htmlFlavors.toArray(new DataFlavor[htmlFlavors.size()]);
        }

        public boolean isDataFlavorSupported(DataFlavor flavor) {
            return htmlFlavors.contains(flavor);
        }

        public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {

            String toBeExported = plainText;
            if (flavor == DataFlavor.stringFlavor) {
                toBeExported = plainText;
            } else if (flavor == DataFlavor.allHtmlFlavor) {
                toBeExported = html;
            }

            if (String.class.equals(flavor.getRepresentationClass())) {
                return toBeExported;
            }
            throw new UnsupportedFlavorException(flavor);
        }
    }
}",            } else if (flavor == DataFlavor.allHtmlFlavor) {,StackOverflow
AvoidDuplicateLiterals,"The String literal ""true"" appears 4 times in this file; the first occurrence is on line 21","public class WebConfiguration implements ServletContextInitializer {
    private static final String FACES_SERVLET = ""Faces Servlet"";
    
    @Bean
    public EmbeddedServletContainerFactory servletContainer() {
        TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory();
        
        TomcatContextCustomizer contextCustomizer = context -> context.addWelcomeFile(""/MyService.xhtml"");
        factory.addContextCustomizers(contextCustomizer);
        
        return factory;
    }
    
    @Override
    public void onStartup(ServletContext servletContext) {
        AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext();
        
        // Parameters
        servletContext.setInitParameter(""javax.faces.STATE_SAVING_METHOD"", ""client"");
        servletContext.setInitParameter(""facelets.REFRESH_PERIOD"", ""1"");
        servletContext.setInitParameter(""com.sun.faces.validateXml"", ""true"");
        servletContext.setInitParameter(""javax.faces.DEFAULT_SUFFIX"", "".xhtml"");
        servletContext.setInitParameter(""facelets.DEVELOPMENT"", ""true"");
        servletContext.setInitParameter(""facelets.SKIP_COMMENTS"", ""true"");
        servletContext.setInitParameter(""facelets.LIBRARIES"", ""/WEB-INF/facelets/custom.taglib.xml"");
        servletContext.setInitParameter(""com.sun.faces.preferXHTML"", ""true"");
        servletContext.setInitParameter(""com.sun.faces.expressionFactory"", ""com.sun.el.ExpressionFactoryImpl"");
        servletContext.setInitParameter(""org.ajax4jsf.VIEW_HANDLERS"", ""com.sun.facelets.FaceletViewHandler"");
        servletContext.setInitParameter(""org.richfaces.SKIN"", ""blueSky"");
        servletContext.setInitParameter(""org.richfaces.CONTROL_SKINNING"", ""enable"");
        servletContext.setInitParameter(""log4jRefreshInterval"", ""1000"");
        
        // Filters
        servletContext
           .addFilter(""richfaces"", new Filter())
           .addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE), false, FACES_SERVLET);
        
        servletContext
           .addFilter(""openEntityManagerInViewFilter"", new OpenEntityManagerInViewFilter())
           .addMappingForUrlPatterns(null, false, ""/*"");
        
        // Listeners
        servletContext.addListener(new RequestContextListener());
        servletContext.addListener(new ConfigureListener());
        
        // Servlets
        ServletRegistration.Dynamic restServlet = servletContext.addServlet(""rest"", new DispatcherServlet(rootContext));
        restServlet.setLoadOnStartup(1);
        restServlet.addMapping(""/rest/*"");
        
        ServletRegistration.Dynamic dispatcherServlet = servletContext.addServlet(""dispatcherServlet"", new DispatcherServlet(rootContext));
        dispatcherServlet.setLoadOnStartup(1);
        dispatcherServlet.setInitParameter(""contextAttribute"", ""org.springframework.web.context.WebApplicationContext.ROOT"");
        dispatcherServlet.addMapping(""/"");
        
        ServletRegistration.Dynamic facesServlet = servletContext.addServlet(FACES_SERVLET, new FacesServlet());
        facesServlet.setLoadOnStartup(1);
        facesServlet.addMapping(""*.xhtml"", ""*.html"", ""/faces/*"", ""*.faces"");
    }
}","        servletContext.setInitParameter(""com.sun.faces.validateXml"", ""true"");",StackOverflow
TestClassWithoutTestCases,"The class 'MyServiceTest' might be a test class, but it contains no test cases.","@Service
public class MyService {
  private Logger log = LogManager.getLogger(MyService.class);

 /**
  * Protected so that this is available to test but no more than necessary.
  */
  protected void setLogger(Logger logger) {
    this.log = logger;
  }

  public boolean processData(String data) throws ServiceException {
    try {
      if (!this.validateDataContains(data, ""MagicString"")) {
        log.warn(""The given data does not contain the MagicString!"");
        return false;
      }
    } catch (Exception e) {
      log.error(""The given data is bad!"", e);
      throw new ServiceException(""There was a problem you can do nothing about, except maybe 'try again later'."");
    }
    return true;
  }

  protected boolean validateDataContains(String data, String magicString) {
    if (data == null) {
      throw new NullPointerException(""Data given was null"");
    } else if (!data.contains(magicString)) {
      return false;
    }
    return true;
  }
}

@SpringBootTest
public class MyServiceTest extends Assertions {
  @Autowired
  private MyService service;
  @Captor
  private ArgumentCaptor<String> stringCaptor;

  @Test
  public void logsErrorTest() {
    var mockLogger = Mockito.mock(Logger.class);
    service.setLogger(mockLogger);

    assertThrows(ServiceException.class,
      () -> this.injectedService.processData(null));
    
    Mockito.verify(mockLogger, Mockito.times(1)).error(stringCaptor.capture(), ArgumentMatchers.any(Throwable.class));
    assertEquals(""The given data is bad!"", stringCaptor.getValue());
  }

  @Test
  public void logsWarningTest() {
    var mockLogger = Mockito.mock(Logger.class);
    service.setLogger(mockLogger);

    assertFalse(service.processData(""This is plain text""));
    
    Mockito.verify(mockLogger, Mockito.times(1)).warn(stringCaptor.capture());
    assertEquals(""The given data does not contain the MagicString!"", stringCaptor.getValue());
  }
}",public class MyServiceTest extends Assertions {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"@Component
public class TokenAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    
    
  @Override
  public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
      throws IOException, ServletException {

    HttpServletRequest httpRequest = (HttpServletRequest) req;
    // Here, I get the token from authorization header, change if you get it from anywhere else
    String token = httpRequest.getHeader(""Authorization"");
    
    // here i'm just doing a dummy check. if my token equals ""mysupersecrettoken"" the authentication is validated
    // change this test by yours (using Auth0 etc.)
    if (""mysupersecrettoken"".equals(token)) {
      // dummy authentication object. You can set a real username / credentials / role based on the claims of your token if you want to.
      UsernamePasswordAuthenticationToken user = new UsernamePasswordAuthenticationToken(""username"", ""credentials"",
          Arrays.asList(new SimpleGrantedAuthority(""ROLE"")));
      SecurityContextHolder.getContext().setAuthentication(user);
    }
    // call next filters, if authentication is not valid, no authentication will be set so user will not be authenticated
    chain.doFilter(req, res);
  }

}","    if (""mysupersecrettoken"".equals(token)) {",StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","import java.util.*;
import java.util.regex.*;
 
class Test
{
    public static void main (String[] args) throws java.lang.Exception
    {
        String s = ""Ox   2.66 abcda   34.3 abfdasd"";
        Pattern pattern = Pattern.compile(""\\bOx\\s+(\\d*\\.?\\d+)\\s+\\S+\\s+(\\d*\\.?\\d+)"");
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()){
            System.out.println(matcher.group(1)); // => 2.66
            System.out.println(matcher.group(2)); // => 34.3
        } 
    }
}",class Test,StackOverflow
DoNotCallGarbageCollectionExplicitly,Do not explicitly trigger a garbage collection.,"public class Main {
    public static void main(String[] args) throws Exception {
        ReferenceQueue<Class<?>> queue = new ReferenceQueue<>();
        WeakReference<Class<?>> ref = f(queue);
        do System.gc(); while(queue.remove(1000) != ref);
        System.out.println(""class has been collected"");
    }

    public static
        WeakReference<Class<?>> f(ReferenceQueue<Class<?>>queue) throws Exception {

        URL url = Main.class.getProtectionDomain().getCodeSource().getLocation();
        try(URLClassLoader cl=new URLClassLoader(new URL[]{ url }, null)) {
           Class<?> c = cl.loadClass(""com.expirement.Loadable1"");
           return new WeakReference<>(c, queue);
        }
    }
}",        do System.gc(); while(queue.remove(1000) != ref);,StackOverflow
AvoidDuplicateLiterals,"The String literal ""myContext"" appears 5 times in this file; the first occurrence is on line 19","import com.github.benmanes.caffeine.cache.AsyncCache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;
import java.util.Map;

class ContextFromMonoToCaffeineCache {

    @Test
    void context() {
        final UserService userService = new UserService();

        // Call the user service 4 times, each time with a different context.

        // Fetch the user with ID=1 twice, using the method which loses the context.
        // The 1st fetch is from the database, the 2nd is already from the cache.
        userService.getUserWithoutContext(1)
                .delayUntil(this::printUser)
                .contextWrite(context -> context.put(""myContext"", ""FIRST""))
                .block();
        userService.getUserWithoutContext(1)
                .delayUntil(this::printUser)
                .contextWrite(context -> context.put(""myContext"", ""SECOND""))
                .block();
        // Fetch the user with ID=2 twice, using the context preserving fetch.
        // The 1st fetch is from the database, the 2nd is already from the cache.
        userService.getUserWithContext(2)
                .delayUntil(this::printUser)
                .contextWrite(context -> context.put(""myContext"", ""THIRD""))
                .block();
        userService.getUserWithContext(2)
                .delayUntil(this::printUser)
                .contextWrite(context -> context.put(""myContext"", ""FORTH""))
                .block();
    }

    private Mono<Object> printUser(User user) {
        return Mono.deferContextual(context -> {
            System.out.printf(""Found %s, with myContext: %s %n"", user, context.get(""myContext""));
            return Mono.empty();
        });
    }
}","                .contextWrite(context -> context.put(""myContext"", ""FIRST""))",StackOverflow
AssignmentInOperand,Avoid assignments in operands,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;


public class PostJSON {

    public static void main(String[] args) throws IOException {
        URL url = new URL(""http://127.0.0.1:8000/"");
        HttpURLConnection con = (HttpURLConnection) url.openConnection();
        con.setRequestMethod(""POST"");
        con.setRequestProperty(""Content-Type"", ""application/json"");
        con.setRequestProperty(""Accept"", ""application/json"");
        con.setDoOutput(true);
        String jsonInputString = ""{\""user\"": \""foo\""}"";

        try (OutputStream os = con.getOutputStream()) {
            byte[] input = jsonInputString.getBytes(StandardCharsets.UTF_8);
            os.write(input, 0, input.length);
        }

        try (BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), StandardCharsets.UTF_8))) {
            StringBuilder response = new StringBuilder();
            String responseLine = null;
            while ((responseLine = br.readLine()) != null) {
                response.append(responseLine.trim());
            }
            System.out.println(con.getResponseCode() + "" "" + response);
        }
    }

}",            while ((responseLine = br.readLine()) != null) {,StackOverflow
ConstructorCallsOverridableMethod,"Overridable method called during object construction: HTMLtoPPTX.createParagraphFromHTML(*XSLFTextParagraph, Element) ","import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   createParagraphFromHTML(paragraph, htmlElement);",StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}",  FileOutputStream out = new FileOutputStream(pptxPath);,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   if (""#text"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""i"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""b"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""u"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""br"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""font"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""li"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""span"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   if (""#text"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""i"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""b"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""u"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""br"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""font"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""li"".equals(nodeName)) {",StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.FileOutputStream;

import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.sl.usermodel.*;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.NodeTraversor;

public class HTMLtoPPTX {

 private XMLSlideShow slideShow;

 public HTMLtoPPTX(String html, String pptxPath) throws Exception {

  this.slideShow = new XMLSlideShow();
  XSLFSlide slide = slideShow.createSlide();
  XSLFTextShape textShape = slide.createAutoShape();
  java.awt.Rectangle rect = new java.awt.Rectangle(100, 100, 500, 400);
  textShape.setAnchor(rect.getBounds2D());
  textShape.setShapeType(ShapeType.RECT);

  XSLFTextParagraph paragraph = null;
  Document htmlDocument = Jsoup.parse(html);
  Elements htmlElements = htmlDocument.select(""p:not(li *), ul li:not(li *)"");
  for(Element htmlElement : htmlElements) {

System.out.println(htmlElement);

   paragraph = textShape.addNewTextParagraph();
   createParagraphFromHTML(paragraph, htmlElement);
  }

  FileOutputStream out = new FileOutputStream(pptxPath);
  slideShow.write(out);
  out.close();
  slideShow.close();

 }

 void createParagraphFromHTML(XSLFTextParagraph paragraph, Element htmlElement) {

  ParagraphNodeVisitor nodeVisitor = new ParagraphNodeVisitor(paragraph);
  NodeTraversor.traverse(nodeVisitor, htmlElement);

 }

 private class ParagraphNodeVisitor implements NodeVisitor {

  String nodeName;
  boolean isItalic;
  boolean isBold;
  boolean isUnderlined;
  double fontSize;
  java.awt.Color fontColor;
  XSLFTextParagraph paragraph;
  XSLFTextRun run;
  boolean spanStyleSetBold;
  boolean spanStyleSetItalic;
  boolean spanStyleSetUnderlined;
  boolean spanStyleSetFontColor;
  boolean spanStyleSetFontSize;

  ParagraphNodeVisitor(XSLFTextParagraph paragraph) {
   this.paragraph = paragraph;
   this.run = paragraph.addNewTextRun(); this.run.setText("""");
   this.nodeName = """";
   this.isItalic = false;
   this.isBold = false;
   this.isUnderlined = false;
   this.fontSize = 11d;
   this.fontColor = java.awt.Color.BLACK;
   this.spanStyleSetBold = false;
   this.spanStyleSetItalic = false;
   this.spanStyleSetUnderlined = false;
   this.spanStyleSetFontColor = false;
   this.spanStyleSetFontSize = false;

  }

  @Override
  public void head(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""Start ""+nodeName+"": "" + node);

   if (""#text"".equals(nodeName)) {
    run.setText(((TextNode)node).textâ());
   } else if (""i"".equals(nodeName)) {
    isItalic = true;
   } else if (""b"".equals(nodeName)) {
    isBold = true;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = true;
   } else if (""br"".equals(nodeName)) {
    run = run.getParagraph().addLineBreak();
   } else if (""font"".equals(nodeName)) {
    String rgbS = (!"""".equals(node.attr(""color"")))?node.attr(""color""):""#000000"";
    fontColor = new java.awt.Color(
     Integer.valueOf(rgbS.substring(1, 3), 16),
     Integer.valueOf(rgbS.substring(3, 5), 16),
     Integer.valueOf(rgbS.substring(5, 7), 16)
    );
    fontSize = (!"""".equals(node.attr(""size"")))?Double.parseDouble(node.attr(""size"")):11d;
   } else if (""li"".equals(nodeName)) {
    paragraph.setBullet(true); 
   } else if (""span"".equals(nodeName)) {
    String style = node.attr(""style"");
    if (style.matches("".*\\bfont-weight:\\s*bold\\s*;.*"")) {
     isBold = true;
     spanStyleSetBold = true;
    }
    if (style.matches("".*\\bfont-style:\\s*italic\\s*;.*"")) {
     isItalic = true;
     spanStyleSetItalic = true;
    }
    if (style.matches("".*\\btext-decoration:\\s*underline\\s*;.*"")) {
     isUnderlined = true;
     spanStyleSetUnderlined = true;
    }
    //if (style.matches("".*\\bcolor:\\s*(#[0-9a-fA-F]+)\\s*;.*"")) { 
    // ToDo      
    //}
    //if (style.matches("".*\\bfont-size:\\s*(#[0-9]+)\\s*;.*"")) { 
    // ToDo      
    //}  
   }
   
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }

  @Override
  public void tail(Node node, int depth) {
   nodeName = node.nodeName();

System.out.println(""End ""+nodeName);

   if (""#text"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting the text in the run a new run is needed
   } else if (""i"".equals(nodeName)) {
    isItalic = false;
   } else if (""b"".equals(nodeName)) {
    isBold = false;
   } else if (""u"".equals(nodeName)) {
    isUnderlined = false;
   } else if (""br"".equals(nodeName)) {
    run = paragraph.addNewTextRun(); run.setText(""""); //after setting a break a new run is needed
   } else if (""font"".equals(nodeName)) {
    fontColor = java.awt.Color.BLACK;
    fontSize = 11d;
   } else if (""li"".equals(nodeName)) {
    // ToDo
   } else if (""span"".equals(nodeName)) {
    if (spanStyleSetItalic) isItalic = false;
    if (spanStyleSetBold) isBold = false;
    if (spanStyleSetUnderlined) isUnderlined = false;
    //if (spanStyleSetFontColor) fontColor = java.awt.Color.BLACK; //ToDo
    //if (spanStyleSetFontSize) fontSize = 11d; //ToDo
    run = paragraph.addNewTextRun(); run.setText(""""); //after a span a new run is needed
   }
   run.setItalic(isItalic);
   run.setBold(isBold);
   if (isUnderlined) run.setUnderlined(true); else run.setUnderlined(false);
   run.setFontColor(fontColor); run.setFontSize(fontSize);
  }
 }

 public static void main(String[] args) throws Exception {

  String html = 
   ""<p><font size='32' color='#0000FF'><b>First paragraph.</font></b><br/>Just like a heading</p>""
  +""<p>This is my text <i>which now is in italic <b>but also in bold</b> depending on its <u>importance</u></i>.<br/>Now a <b><i><u>new</u></i></b> line starts <i>within <b>the same</b> paragraph</i>.</p>""
  +""<p><b>Last <u>paragraph <i>comes</u> here</b> finally</i>.</p>""
  +""<p>But yet <u><i><b>another</i></u></b> paragraph having <i><font size='22' color='#FF0000'>special <u>font</u> settings</font></i>. Now default font again.</p>""
  +""<p />""
  ;

  //html += 
  html = 
   ""<p><span style=\""font-weight: bold; font-style: italic; text-decoration: underline; \"">Title</span></p>""
  +""<ul> <li> <span style=\""font-weight: bold;\""> </span><span>Laser cutting of sheet </span><span style=\""font-weight: bold;\"">metal</span><span> generates a continuous heat source which can led to high levels of thermal stress </span> </li> <li><span>Thermal Stress can deform the material at the micron level and the slightest deformation reduces the effectiveness of the sheet metal components</span></li> <br /> </ul>""
  +""<p><span> </span><span style=\""font-weight:bold;text-decoration:underline;\"">Mass Level Production</span></p>""
  +""<ul> <li><span>Laser cutting cannot produce more component more than one part at a time</span></li> <li><span>When production is required at a lower level , laser cutting may be apt but inefficient for mass level production</span></li> </ul>""
  +""<p><span style=\""font-weight: bold;\"">Metal etching with aluminum</span></p>""
  +""<p><span style=\""font-weight: bold;\""> </span></p>""
  +""<ul> <li><span>Aluminum is a reflective material that is reactive to heat in the manufacturing process and therefore, makes it less suitable for laser cutting and wire EDM processes</span></li> <li> <span>As the use of aluminum is growing in many industries, there is a requirement for a suitable manufacturing process for thin </span><span style=\""font-weight: bold;\"">aluminum</span><span>components</span> </li> </ul>""
  ;
  
  HTMLtoPPTX htmlToPPTX = new HTMLtoPPTX(html, ""./CreatePowerPointTextFromHTML.pptx"");

 }
}","   } else if (""span"".equals(nodeName)) {",StackOverflow
TestClassWithoutTestCases,"The class 'RecipientPayloadConsumerTests' might be a test class, but it contains no test cases.","@Testcontainers
@SpringBootTest
@TestPropertySource(locations = ""classpath:application-test.properties"")
public class RecipientPayloadConsumerTests {

    private static final String TOPIC = ""tappedtechnologies.test.topics"";

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private KafkaTemplate<String, RecipientSavedEvent> kafkaTemplate;

    @Container
    public static MySQLContainer<?> mySQLContainer = new MySQLContainer<>(""mysql:latest"");
    @Container
    public static KafkaContainer kafkaContainer = new KafkaContainer(DockerImageName.parse(""confluentinc/cp-kafka:6.2.1""));

    @DynamicPropertySource
    public static void setProperties(DynamicPropertyRegistry registry) {
        registry.add(""spring.datasource.url"", mySQLContainer::getJdbcUrl);
        registry.add(""spring.datasource.username"", mySQLContainer::getUsername);
        registry.add(""spring.datasource.password"", mySQLContainer::getPassword);

        registry.add(""spring.kafka.bootstrap-servers"", kafkaContainer::getBootstrapServers);
    }

    @AfterEach
    public void afterEach() {
        userRepository.deleteAll();
    }

    @Test
    public void consumePayload_Should_SavePayload() throws InterruptedException {
        RecipientSavedEvent expected = getPayload();
        kafkaTemplate.send(TOPIC, 0, Instant.now().getEpochSecond(), expected.getPayloadKey(), expected);
        Thread.sleep(5000);

        User actual = userRepository.findByEmail(expected.getEmail()).orElse(null);

        assert actual != null;
        assertThat(actual.getFirstName()).isEqualTo(expected.getFirstName());
        assertThat(actual.getLastName()).isEqualTo(expected.getLastName());
        assertThat(actual.getEmail()).isEqualTo(expected.getEmail());
    }

    private RecipientSavedEvent getPayload() {
        return RecipientSavedEvent.builder()
                .payloadKey(UUID.randomUUID().toString())
                .firstName(""Randy"")
                .lastName(""Marsh"")
                .email(""randy@tegridyfarms.com"")
                .build();
    }
}",public class RecipientPayloadConsumerTests {,StackOverflow
TestClassWithoutTestCases,"The class 'BaseTest' might be a test class, but it contains no test cases.","public class BaseTest {

    @BeforeAll
    public static void start() throws Exception {
        System.out.println(""Before All from Suite1"");
    }

    @AfterAll
    public static void end() throws Exception {
        System.out.println(""After All from Suite1"");
    }
}

public class SampleTestOne extends BaseTest {
    @Test
    public void testOne(){
        System.out.println(""Extended test passed!"");
    }

    @Test
    public void testTwo(){
        System.out.println(""Extended test passed!"");
    }
}

public class SampleTestTwo extends SampleTestOne {
    @Test
    public void testThree(){
        System.out.println(""test passed"");
    }
}",public class BaseTest {,StackOverflow
TestClassWithoutTestCases,"The class 'UsaTesteEstaticoTest' might be a test class, but it contains no test cases.","public class UsaTesteEstaticoTest {
    
    UsaTesteEstatico usaTesteEstatico = new UsaTesteEstatico();

    @Test
    void teste1(){
        try (var ms = Mockito.mockStatic(TesteEstatico.class)) {
            Mockito.when(TesteEstatico.teste()).thenReturn(""BANANA"");
            String res = usaTesteEstatico.metodoParaTeste1();
            System.out.println(res);
        }
    }

    @Test
    void teste2(){
        try (var ms = Mockito.mockStatic(TesteEstatico.class)) {
            Mockito.when(TesteEstatico.teste()).thenReturn(""LARANJA"");
            String res = usaTesteEstatico.metodoParaTeste2();
            System.out.println(res);
        }
    }
}

// BAD CODE DONT USE
public class UsaTesteEstaticoTest {

    UsaTesteEstatico usaTesteEstatico = new UsaTesteEstatico();
    static MockedStatic<TesteEstatico> ms;

    @BeforeAll
    public static void init() {
        ms = Mockito.mockStatic(TesteEstatico.class);
    }

    @AfterAll
    public static void close() {
        ms.close();
    }


    @Test
    void teste1() {
        Mockito.when(TesteEstatico.teste()).thenReturn(""BANANA"");
        String res = usaTesteEstatico.metodoParaTeste1();
        System.out.println(res);
    }

    @Test
    void teste2() {
        String res = usaTesteEstatico.metodoParaTeste2();
        System.out.println(res);
    }
}",public class UsaTesteEstaticoTest {,StackOverflow
TestClassWithoutTestCases,"The class 'UsaTesteEstaticoTest' might be a test class, but it contains no test cases.","public class UsaTesteEstaticoTest {
    
    UsaTesteEstatico usaTesteEstatico = new UsaTesteEstatico();

    @Test
    void teste1(){
        try (var ms = Mockito.mockStatic(TesteEstatico.class)) {
            Mockito.when(TesteEstatico.teste()).thenReturn(""BANANA"");
            String res = usaTesteEstatico.metodoParaTeste1();
            System.out.println(res);
        }
    }

    @Test
    void teste2(){
        try (var ms = Mockito.mockStatic(TesteEstatico.class)) {
            Mockito.when(TesteEstatico.teste()).thenReturn(""LARANJA"");
            String res = usaTesteEstatico.metodoParaTeste2();
            System.out.println(res);
        }
    }
}

// BAD CODE DONT USE
public class UsaTesteEstaticoTest {

    UsaTesteEstatico usaTesteEstatico = new UsaTesteEstatico();
    static MockedStatic<TesteEstatico> ms;

    @BeforeAll
    public static void init() {
        ms = Mockito.mockStatic(TesteEstatico.class);
    }

    @AfterAll
    public static void close() {
        ms.close();
    }


    @Test
    void teste1() {
        Mockito.when(TesteEstatico.teste()).thenReturn(""BANANA"");
        String res = usaTesteEstatico.metodoParaTeste1();
        System.out.println(res);
    }

    @Test
    void teste2() {
        String res = usaTesteEstatico.metodoParaTeste2();
        System.out.println(res);
    }
}",public class UsaTesteEstaticoTest {,StackOverflow
AvoidAccessibilityAlteration,"You should not modify visibility of constructors, methods or fields using setAccessible()","import java.lang.reflect.Field;

class           B {private String p1=""1""; private String p2=""2"";}
class A extends B {private String p3=""3""; private String p4=""4"";}

public class Scratch    {
    static void showFields(Class clazz, Object obj) throws Exception {
        for(Field f:clazz.getDeclaredFields())  {
            f.setAccessible(true);
            System.out.println(""Field ""+f.getName()+"" had value ""+f.get(obj));
        }
    }

    public static void main(String[] args) throws Exception  {
        System.out.println(""Fields defined in parent: "");
        showFields(B.class, new A());
        System.out.println(""Fields defined in child"");
        showFields(A.class, new A());
    }
}",            f.setAccessible(true);,StackOverflow
TestClassWithoutTestCases,"The class 'InteractiveTicketServiceTest' might be a test class, but it contains no test cases.","@ExtendWith(MockitoExtension.class)
public class InteractiveTicketServiceTest {
    @Mock
    DataTransformationService transformationService;

    @InjectMocks
    InteractiveTicketService interactiveTicketService;

    @Test
    public void should_Create_MultiDoc_Ticket() throws URISyntaxException{
        JSONObject samplePolicyData = createSamplePolicyData(""Sample Multidoc Template"");   
        InteractiveRequest sampleInteractiveRequest = createSampleInteractiveRequest();
        when(transformationService
            .transformMultiDocData(createSampleInteractiveData()))
            .thenReturn(createSampleInteractiveData());
        String ticketId = interactiveTicketService.createTicket(samplePolicyData.toString());
        assertThat(ticketId).isEqualTo(""sampleTicketId"");
        verify(transformationService, times(1)).transformMultiDocData(createSampleInteractiveData());
    }
}",public class InteractiveTicketServiceTest {,StackOverflow
TestClassWithoutTestCases,"The class 'ServiceToTest' might be a test class, but it contains no test cases.","interface ContainerFactory {
    CustomContainer create(Object configuration, String name);
}

interface EnvironmentAccessor {
    String getEnv(String name);
}

@Service
public class ServiceToTest {

    private final CustomContainer customContainer;

    public ServiceToTest(ContainerFactory containerFactory, EnvironmentAccessor environmentAccessor) {
        Object configuration = new Object();
        String envWord = environmentAccessor.getEnv(""envword"");
        this.customContainer = containerFactory.create(configuration, envWord == null ? ""default"" : envWord);
    }

    public String getContainerName() {
        return customContainer.getContainerName();
    }
}",public class ServiceToTest {,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","import java.util.*;

class Test {
  public static void main(String[] args) {
    List<String> a = new ArrayList<String>();
    a.add(""Hello""); a.add(""World"");
    copyFirstToEnd(a);
    System.out.println(a);
  }

  private static void copyFirstToEnd(List<?> in) {
    class Helper {
      <S> void help(List<S> a) { a.add(a.get(0)); }
    }

    new Helper().help(in);
  }
}",class Test {,StackOverflow
UnnecessaryCaseChange,Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals().,"package org.ajames.tomcathttpsvalve;

import java.io.IOException;
import javax.servlet.ServletException;
import org.apache.catalina.connector.Request;
import org.apache.catalina.connector.Response;
import org.apache.catalina.valves.ValveBase;

// In server.xml:
// <Valve className=""org.ajames.tomcathttpsvalve.TomcatHttpsValve""
//        fromPort=""8080"" toPort=""8443"" />
//
// This class is packaged as a JAR & placed in Tomcat's /lib
public class TomcatHttpsValve extends ValveBase {

    private final String fromScheme = ""http"";
    private final String toScheme = ""https"";
    private final int httpsDefaultPort = 443;
    private int fromPort; // see valve config for value
    private int toPort; // see valve config for value

    public TomcatHttpsValve() {
        super(true); // async supported
    }

    @Override
    public void invoke(Request req, Response resp) throws IOException, ServletException {
        if (req.getScheme().toLowerCase().equals(toScheme)) {
            // already using https:
            getNext().invoke(req, resp);
        } else {
            // need to redirect to https:
            resp.sendRedirect(buildNewReqUrl(req));
        }
    }

    private String buildNewReqUrl(Request req) {
        String scheme = req.getScheme();
        int port = req.getServerPort();

        if (scheme.toLowerCase().equals(fromScheme)) {
            scheme = toScheme;
        }

        if (port == fromPort) {
            port = toPort;
        }

        // build the new URL
        // assumes no userinfo (...//john.doe@...)
        StringBuilder sb = new StringBuilder();
        sb.append(scheme).append(""://"").append(req.getServerName());
        if (port != httpsDefaultPort) { // 443 is implicit with https
            sb.append("":"").append(port);
        }
        sb.append(req.getRequestURI()); // (e.g. /foo/bar)
        if (req.getQueryString() != null) {
            sb.append(""?"").append(req.getQueryString());
        }

        return sb.toString();
    }

    public int getFromPort() {
        return fromPort;
    }

    public void setFromPort(String fromPort) {
        this.fromPort = Integer.parseInt(fromPort);
    }

    public int getToPort() {
        return toPort;
    }

    public void setToPort(String toPort) {
        this.toPort = Integer.parseInt(toPort);
    }
}",        if (req.getScheme().toLowerCase().equals(toScheme)) {,StackOverflow
UnnecessaryCaseChange,Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals().,"package org.ajames.tomcathttpsvalve;

import java.io.IOException;
import javax.servlet.ServletException;
import org.apache.catalina.connector.Request;
import org.apache.catalina.connector.Response;
import org.apache.catalina.valves.ValveBase;

// In server.xml:
// <Valve className=""org.ajames.tomcathttpsvalve.TomcatHttpsValve""
//        fromPort=""8080"" toPort=""8443"" />
//
// This class is packaged as a JAR & placed in Tomcat's /lib
public class TomcatHttpsValve extends ValveBase {

    private final String fromScheme = ""http"";
    private final String toScheme = ""https"";
    private final int httpsDefaultPort = 443;
    private int fromPort; // see valve config for value
    private int toPort; // see valve config for value

    public TomcatHttpsValve() {
        super(true); // async supported
    }

    @Override
    public void invoke(Request req, Response resp) throws IOException, ServletException {
        if (req.getScheme().toLowerCase().equals(toScheme)) {
            // already using https:
            getNext().invoke(req, resp);
        } else {
            // need to redirect to https:
            resp.sendRedirect(buildNewReqUrl(req));
        }
    }

    private String buildNewReqUrl(Request req) {
        String scheme = req.getScheme();
        int port = req.getServerPort();

        if (scheme.toLowerCase().equals(fromScheme)) {
            scheme = toScheme;
        }

        if (port == fromPort) {
            port = toPort;
        }

        // build the new URL
        // assumes no userinfo (...//john.doe@...)
        StringBuilder sb = new StringBuilder();
        sb.append(scheme).append(""://"").append(req.getServerName());
        if (port != httpsDefaultPort) { // 443 is implicit with https
            sb.append("":"").append(port);
        }
        sb.append(req.getRequestURI()); // (e.g. /foo/bar)
        if (req.getQueryString() != null) {
            sb.append(""?"").append(req.getQueryString());
        }

        return sb.toString();
    }

    public int getFromPort() {
        return fromPort;
    }

    public void setFromPort(String fromPort) {
        this.fromPort = Integer.parseInt(fromPort);
    }

    public int getToPort() {
        return toPort;
    }

    public void setToPort(String toPort) {
        this.toPort = Integer.parseInt(toPort);
    }
}",        if (scheme.toLowerCase().equals(fromScheme)) {,StackOverflow
UseLocaleWithCaseConversions,"When doing a String.toLowerCase()/toUpperCase() call, use a Locale","package org.ajames.tomcathttpsvalve;

import java.io.IOException;
import javax.servlet.ServletException;
import org.apache.catalina.connector.Request;
import org.apache.catalina.connector.Response;
import org.apache.catalina.valves.ValveBase;

// In server.xml:
// <Valve className=""org.ajames.tomcathttpsvalve.TomcatHttpsValve""
//        fromPort=""8080"" toPort=""8443"" />
//
// This class is packaged as a JAR & placed in Tomcat's /lib
public class TomcatHttpsValve extends ValveBase {

    private final String fromScheme = ""http"";
    private final String toScheme = ""https"";
    private final int httpsDefaultPort = 443;
    private int fromPort; // see valve config for value
    private int toPort; // see valve config for value

    public TomcatHttpsValve() {
        super(true); // async supported
    }

    @Override
    public void invoke(Request req, Response resp) throws IOException, ServletException {
        if (req.getScheme().toLowerCase().equals(toScheme)) {
            // already using https:
            getNext().invoke(req, resp);
        } else {
            // need to redirect to https:
            resp.sendRedirect(buildNewReqUrl(req));
        }
    }

    private String buildNewReqUrl(Request req) {
        String scheme = req.getScheme();
        int port = req.getServerPort();

        if (scheme.toLowerCase().equals(fromScheme)) {
            scheme = toScheme;
        }

        if (port == fromPort) {
            port = toPort;
        }

        // build the new URL
        // assumes no userinfo (...//john.doe@...)
        StringBuilder sb = new StringBuilder();
        sb.append(scheme).append(""://"").append(req.getServerName());
        if (port != httpsDefaultPort) { // 443 is implicit with https
            sb.append("":"").append(port);
        }
        sb.append(req.getRequestURI()); // (e.g. /foo/bar)
        if (req.getQueryString() != null) {
            sb.append(""?"").append(req.getQueryString());
        }

        return sb.toString();
    }

    public int getFromPort() {
        return fromPort;
    }

    public void setFromPort(String fromPort) {
        this.fromPort = Integer.parseInt(fromPort);
    }

    public int getToPort() {
        return toPort;
    }

    public void setToPort(String toPort) {
        this.toPort = Integer.parseInt(toPort);
    }
}",        if (scheme.toLowerCase().equals(fromScheme)) {,StackOverflow
DoNotThrowExceptionInFinally,A throw statement in a finally block makes the control flow hard to understand.,"public class TimeoutExtension implements InvocationInterceptor {
  private static final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1);
  @Override
  public void interceptTestMethod(Invocation<Void> invocation, ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
    Timeout timeout = invocationContext.getExecutable().getAnnotation(Timeout.class);
    Class<?> clazz = invocationContext.getExecutable().getDeclaringClass();
    while (timeout == null && clazz != Object.class) {
      timeout = clazz.getAnnotation(Timeout.class);
      clazz = clazz.getSuperclass();
    }
    if (timeout == null || timeout.seconds() <= 0) {
      invocation.proceed();
      return;
    }
    int seconds = timeout.seconds();
    Thread caller = Thread.currentThread();
    AtomicBoolean timedOut = new AtomicBoolean();
    Future<Void> future = exec.schedule(() -> {
      System.out.println(""**** TIMEOUT ERROR: TEST EXCEEDED "" + seconds + "" SECONDS ****"");
      printThreadDump();
      timedOut.set(true);
      caller.interrupt();
      return null;
    }, seconds, TimeUnit.SECONDS);
    Exception caught = null;
    try {
      invocation.proceed();
    } catch (Exception ex) {
      caught = ex;
    } finally {
      future.cancel(true);
      if (timedOut.get()) {
        if (timeout.expectTimeout()) {
          // awesome!
        } else {
          Exception ex = new TimeoutException(""Test exceeded timeout of "" + seconds + "" seconds"");
          if (caught != null) {
            ex.addSuppressed(caught);
          }
          throw ex;
        }
      } else if (caught != null) {
        throw caught;
      } else if (timeout.expectTimeout()) {
        throw new RuntimeException(""Test expected to timeout at "" + seconds + "" but didn't"");
      }
    }
  }
}

public class TestUtils {
  public static String generateThreadDump() {
    final StringBuilder dump = new StringBuilder();
    final ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    final ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(threadMXBean.getAllThreadIds(), 100);
    for (ThreadInfo threadInfo : threadInfos) {
      dump.append('""');
      dump.append(threadInfo.getThreadName());
      dump.append(""\"" "");
      final Thread.State state = threadInfo.getThreadState();
      dump.append(""\n   java.lang.Thread.State: "");
      dump.append(state);
      final StackTraceElement[] stackTraceElements = threadInfo.getStackTrace();
      for (final StackTraceElement stackTraceElement : stackTraceElements) {
        dump.append(""\n        at "");
        dump.append(stackTraceElement);
      }
      dump.append(""\n\n"");
    }
    return dump.toString();
  }
  public static void printThreadDump() {
    System.out.println(generateThreadDump());
  }
}","    } finally {
      future.cancel(true);
      if (timedOut.get()) {
        if (timeout.expectTimeout()) {
          // awesome!
        } else {
          Exception ex = new TimeoutException(""Test exceeded timeout of "" + seconds + "" seconds"");
          if (caught != null) {
            ex.addSuppressed(caught);
          }
          throw ex;
        }
      } else if (caught != null) {
        throw caught;
      } else if (timeout.expectTimeout()) {
        throw new RuntimeException(""Test expected to timeout at "" + seconds + "" but didn't"");
      }
    }",StackOverflow
TestClassWithoutTestCases,"The class 'TestUtils' might be a test class, but it contains no test cases.","public class TimeoutExtension implements InvocationInterceptor {
  private static final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1);
  @Override
  public void interceptTestMethod(Invocation<Void> invocation, ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
    Timeout timeout = invocationContext.getExecutable().getAnnotation(Timeout.class);
    Class<?> clazz = invocationContext.getExecutable().getDeclaringClass();
    while (timeout == null && clazz != Object.class) {
      timeout = clazz.getAnnotation(Timeout.class);
      clazz = clazz.getSuperclass();
    }
    if (timeout == null || timeout.seconds() <= 0) {
      invocation.proceed();
      return;
    }
    int seconds = timeout.seconds();
    Thread caller = Thread.currentThread();
    AtomicBoolean timedOut = new AtomicBoolean();
    Future<Void> future = exec.schedule(() -> {
      System.out.println(""**** TIMEOUT ERROR: TEST EXCEEDED "" + seconds + "" SECONDS ****"");
      printThreadDump();
      timedOut.set(true);
      caller.interrupt();
      return null;
    }, seconds, TimeUnit.SECONDS);
    Exception caught = null;
    try {
      invocation.proceed();
    } catch (Exception ex) {
      caught = ex;
    } finally {
      future.cancel(true);
      if (timedOut.get()) {
        if (timeout.expectTimeout()) {
          // awesome!
        } else {
          Exception ex = new TimeoutException(""Test exceeded timeout of "" + seconds + "" seconds"");
          if (caught != null) {
            ex.addSuppressed(caught);
          }
          throw ex;
        }
      } else if (caught != null) {
        throw caught;
      } else if (timeout.expectTimeout()) {
        throw new RuntimeException(""Test expected to timeout at "" + seconds + "" but didn't"");
      }
    }
  }
}

public class TestUtils {
  public static String generateThreadDump() {
    final StringBuilder dump = new StringBuilder();
    final ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    final ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(threadMXBean.getAllThreadIds(), 100);
    for (ThreadInfo threadInfo : threadInfos) {
      dump.append('""');
      dump.append(threadInfo.getThreadName());
      dump.append(""\"" "");
      final Thread.State state = threadInfo.getThreadState();
      dump.append(""\n   java.lang.Thread.State: "");
      dump.append(state);
      final StackTraceElement[] stackTraceElements = threadInfo.getStackTrace();
      for (final StackTraceElement stackTraceElement : stackTraceElements) {
        dump.append(""\n        at "");
        dump.append(stackTraceElement);
      }
      dump.append(""\n\n"");
    }
    return dump.toString();
  }
  public static void printThreadDump() {
    System.out.println(generateThreadDump());
  }
}",public class TestUtils {,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new Main());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class Main extends JPanel implements ActionListener, MouseListener, KeyListener {

        Color GREEN = new Color(41, 176, 59);
        Color WHITE = new Color(254, 255, 228);

        Board board;

        public Main() throws IOException {
            board = new Board();
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(800, 800);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            super.paintComponent(g);
            boolean flag = true;
            for (int i = 0; i < 8; i++) {

                for (int j = 0; j < 8; j++) {
                    if (flag) {
                        g.setColor(WHITE);
                    } else {
                        g.setColor(GREEN);
                    }
                    g.fillRect((j * 100), (i * 100), ((j + 1) * 100), ((i + 1) * 100));
                    flag = !flag;
                }
                flag = !flag;
            }
            for (int i = 0; i < 8; i++) {
                for (int j = 0; j < 8; j++) {
                    if (board.board[i][j] != null) {
                        board.board[i][j].paint(g);
                    }
                }
            }
        }

        @Override
        public void actionPerformed(ActionEvent e) {
        }

        @Override
        public void mouseClicked(MouseEvent e) {
        }

        @Override
        public void mousePressed(MouseEvent e) {
        }

        @Override
        public void mouseReleased(MouseEvent e) {
        }

        @Override
        public void mouseEntered(MouseEvent e) {
        }

        @Override
        public void mouseExited(MouseEvent e) {
        }

        @Override
        public void keyTyped(KeyEvent e) {
        }

        @Override
        public void keyPressed(KeyEvent e) {
        }

        @Override
        public void keyReleased(KeyEvent e) {
        }
    }

    public class Board {

        Piece[][] board;

        public Board() throws IOException {
            board = new Piece[8][8];
            for (int i = 0; i < 8; i++) {
                board[1][i] = new Pawn(i, 1, 8 + i);
            }

            for (int i = 0; i < 8; i++) {
                board[6][i] = new Pawn(i, 0, 16 + i);
            }
        }

    }

    public class Pawn extends Piece {

        public Pawn(int Id, int color, int position) throws IOException {
            super(Id, color, position);
            this.state = 0;
            String path = ""/imgs/Pieces/"";
            if (color == 0) {
                path += ""W"";
            } else {
                path += ""B"";
            }
            path += ""_Pawn.png"";
            Sprite = getImage(path);
        }
    }

    public class Piece {

        public int Id;
        public int color;
        public int state;
        public Image Sprite;
        public AffineTransform tx;
        public boolean dragged;
        public int x;
        public int y;

        public Piece(int Id, int color, int position) {
            dragged = false;
            this.Id = Id;
            this.color = color;

            x = 100 * (position % 8);
            y = 100 * (position / 8);

            System.out.println(x + ""x"" + y);

            tx = AffineTransform.getTranslateInstance(x, y);
            tx.scale(0.1, 0.1);
        }

        protected Image getImage(String path) throws IOException {
            BufferedImage img = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g2d = img.createGraphics();
            g2d.setFont(new JLabel().getFont().deriveFont(Font.PLAIN, 16));
            g2d.setColor(Color.BLACK);
            FontMetrics fm = g2d.getFontMetrics();

            int cellX = x;
            int cellY = y;

            String text = x + ""x"" + y;

            int x = (100 - fm.stringWidth(text)) / 2;
            int y = ((100 - fm.getHeight()) / 2) + fm.getAscent();

            g2d.drawString(text, x, y);

            g2d.setStroke(new BasicStroke(16));
            g2d.drawRect(0, 0, 99, 99);

            g2d.dispose();

            return img;
        }

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            g2.drawImage(Sprite, tx, null);
        }
    }
}",public class Test {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new Main());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class Main extends JPanel implements ActionListener, MouseListener, KeyListener {

        Color GREEN = new Color(41, 176, 59);
        Color WHITE = new Color(254, 255, 228);

        Board board;

        public Main() throws IOException {
            board = new Board();
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(800, 800);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            super.paintComponent(g);
            boolean flag = true;
            for (int i = 0; i < 8; i++) {

                for (int j = 0; j < 8; j++) {
                    if (flag) {
                        g.setColor(WHITE);
                    } else {
                        g.setColor(GREEN);
                    }
                    g.fillRect((j * 100), (i * 100), ((j + 1) * 100), ((i + 1) * 100));
                    flag = !flag;
                }
                flag = !flag;
            }
            for (int i = 0; i < 8; i++) {
                for (int j = 0; j < 8; j++) {
                    if (board.board[i][j] != null) {
                        board.board[i][j].paint(g);
                    }
                }
            }
        }

        @Override
        public void actionPerformed(ActionEvent e) {
        }

        @Override
        public void mouseClicked(MouseEvent e) {
        }

        @Override
        public void mousePressed(MouseEvent e) {
        }

        @Override
        public void mouseReleased(MouseEvent e) {
        }

        @Override
        public void mouseEntered(MouseEvent e) {
        }

        @Override
        public void mouseExited(MouseEvent e) {
        }

        @Override
        public void keyTyped(KeyEvent e) {
        }

        @Override
        public void keyPressed(KeyEvent e) {
        }

        @Override
        public void keyReleased(KeyEvent e) {
        }
    }

    public class Board {

        Piece[][] board;

        public Board() throws IOException {
            board = new Piece[8][8];
            for (int i = 0; i < 8; i++) {
                board[1][i] = new Pawn(i, 1, 8 + i);
            }

            for (int i = 0; i < 8; i++) {
                board[6][i] = new Pawn(i, 0, 16 + i);
            }
        }

    }

    public class Pawn extends Piece {

        public Pawn(int Id, int color, int position) throws IOException {
            super(Id, color, position);
            this.state = 0;
            String path = ""/imgs/Pieces/"";
            if (color == 0) {
                path += ""W"";
            } else {
                path += ""B"";
            }
            path += ""_Pawn.png"";
            Sprite = getImage(path);
        }
    }

    public class Piece {

        public int Id;
        public int color;
        public int state;
        public Image Sprite;
        public AffineTransform tx;
        public boolean dragged;
        public int x;
        public int y;

        public Piece(int Id, int color, int position) {
            dragged = false;
            this.Id = Id;
            this.color = color;

            x = 100 * (position % 8);
            y = 100 * (position / 8);

            System.out.println(x + ""x"" + y);

            tx = AffineTransform.getTranslateInstance(x, y);
            tx.scale(0.1, 0.1);
        }

        protected Image getImage(String path) throws IOException {
            BufferedImage img = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g2d = img.createGraphics();
            g2d.setFont(new JLabel().getFont().deriveFont(Font.PLAIN, 16));
            g2d.setColor(Color.BLACK);
            FontMetrics fm = g2d.getFontMetrics();

            int cellX = x;
            int cellY = y;

            String text = x + ""x"" + y;

            int x = (100 - fm.stringWidth(text)) / 2;
            int y = ((100 - fm.getHeight()) / 2) + fm.getAscent();

            g2d.drawString(text, x, y);

            g2d.setStroke(new BasicStroke(16));
            g2d.drawRect(0, 0, 99, 99);

            g2d.dispose();

            return img;
        }

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            g2.drawImage(Sprite, tx, null);
        }
    }
}","    public class Main extends JPanel implements ActionListener, MouseListener, KeyListener {",StackOverflow
NonSerializableClass,The field 'board' of serializable class 'Test$Main' is of non-serializable type 'Test#Board'.,"import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new Main());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class Main extends JPanel implements ActionListener, MouseListener, KeyListener {

        Color GREEN = new Color(41, 176, 59);
        Color WHITE = new Color(254, 255, 228);

        Board board;

        public Main() throws IOException {
            board = new Board();
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(800, 800);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            super.paintComponent(g);
            boolean flag = true;
            for (int i = 0; i < 8; i++) {

                for (int j = 0; j < 8; j++) {
                    if (flag) {
                        g.setColor(WHITE);
                    } else {
                        g.setColor(GREEN);
                    }
                    g.fillRect((j * 100), (i * 100), ((j + 1) * 100), ((i + 1) * 100));
                    flag = !flag;
                }
                flag = !flag;
            }
            for (int i = 0; i < 8; i++) {
                for (int j = 0; j < 8; j++) {
                    if (board.board[i][j] != null) {
                        board.board[i][j].paint(g);
                    }
                }
            }
        }

        @Override
        public void actionPerformed(ActionEvent e) {
        }

        @Override
        public void mouseClicked(MouseEvent e) {
        }

        @Override
        public void mousePressed(MouseEvent e) {
        }

        @Override
        public void mouseReleased(MouseEvent e) {
        }

        @Override
        public void mouseEntered(MouseEvent e) {
        }

        @Override
        public void mouseExited(MouseEvent e) {
        }

        @Override
        public void keyTyped(KeyEvent e) {
        }

        @Override
        public void keyPressed(KeyEvent e) {
        }

        @Override
        public void keyReleased(KeyEvent e) {
        }
    }

    public class Board {

        Piece[][] board;

        public Board() throws IOException {
            board = new Piece[8][8];
            for (int i = 0; i < 8; i++) {
                board[1][i] = new Pawn(i, 1, 8 + i);
            }

            for (int i = 0; i < 8; i++) {
                board[6][i] = new Pawn(i, 0, 16 + i);
            }
        }

    }

    public class Pawn extends Piece {

        public Pawn(int Id, int color, int position) throws IOException {
            super(Id, color, position);
            this.state = 0;
            String path = ""/imgs/Pieces/"";
            if (color == 0) {
                path += ""W"";
            } else {
                path += ""B"";
            }
            path += ""_Pawn.png"";
            Sprite = getImage(path);
        }
    }

    public class Piece {

        public int Id;
        public int color;
        public int state;
        public Image Sprite;
        public AffineTransform tx;
        public boolean dragged;
        public int x;
        public int y;

        public Piece(int Id, int color, int position) {
            dragged = false;
            this.Id = Id;
            this.color = color;

            x = 100 * (position % 8);
            y = 100 * (position / 8);

            System.out.println(x + ""x"" + y);

            tx = AffineTransform.getTranslateInstance(x, y);
            tx.scale(0.1, 0.1);
        }

        protected Image getImage(String path) throws IOException {
            BufferedImage img = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g2d = img.createGraphics();
            g2d.setFont(new JLabel().getFont().deriveFont(Font.PLAIN, 16));
            g2d.setColor(Color.BLACK);
            FontMetrics fm = g2d.getFontMetrics();

            int cellX = x;
            int cellY = y;

            String text = x + ""x"" + y;

            int x = (100 - fm.stringWidth(text)) / 2;
            int y = ((100 - fm.getHeight()) / 2) + fm.getAscent();

            g2d.drawString(text, x, y);

            g2d.setStroke(new BasicStroke(16));
            g2d.drawRect(0, 0, 99, 99);

            g2d.dispose();

            return img;
        }

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            g2.drawImage(Sprite, tx, null);
        }
    }
}",        Board board;,StackOverflow
AvoidFieldNameMatchingTypeName,It is somewhat confusing to have a field name matching the declaring class name,"import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new Main());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class Main extends JPanel implements ActionListener, MouseListener, KeyListener {

        Color GREEN = new Color(41, 176, 59);
        Color WHITE = new Color(254, 255, 228);

        Board board;

        public Main() throws IOException {
            board = new Board();
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(800, 800);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            super.paintComponent(g);
            boolean flag = true;
            for (int i = 0; i < 8; i++) {

                for (int j = 0; j < 8; j++) {
                    if (flag) {
                        g.setColor(WHITE);
                    } else {
                        g.setColor(GREEN);
                    }
                    g.fillRect((j * 100), (i * 100), ((j + 1) * 100), ((i + 1) * 100));
                    flag = !flag;
                }
                flag = !flag;
            }
            for (int i = 0; i < 8; i++) {
                for (int j = 0; j < 8; j++) {
                    if (board.board[i][j] != null) {
                        board.board[i][j].paint(g);
                    }
                }
            }
        }

        @Override
        public void actionPerformed(ActionEvent e) {
        }

        @Override
        public void mouseClicked(MouseEvent e) {
        }

        @Override
        public void mousePressed(MouseEvent e) {
        }

        @Override
        public void mouseReleased(MouseEvent e) {
        }

        @Override
        public void mouseEntered(MouseEvent e) {
        }

        @Override
        public void mouseExited(MouseEvent e) {
        }

        @Override
        public void keyTyped(KeyEvent e) {
        }

        @Override
        public void keyPressed(KeyEvent e) {
        }

        @Override
        public void keyReleased(KeyEvent e) {
        }
    }

    public class Board {

        Piece[][] board;

        public Board() throws IOException {
            board = new Piece[8][8];
            for (int i = 0; i < 8; i++) {
                board[1][i] = new Pawn(i, 1, 8 + i);
            }

            for (int i = 0; i < 8; i++) {
                board[6][i] = new Pawn(i, 0, 16 + i);
            }
        }

    }

    public class Pawn extends Piece {

        public Pawn(int Id, int color, int position) throws IOException {
            super(Id, color, position);
            this.state = 0;
            String path = ""/imgs/Pieces/"";
            if (color == 0) {
                path += ""W"";
            } else {
                path += ""B"";
            }
            path += ""_Pawn.png"";
            Sprite = getImage(path);
        }
    }

    public class Piece {

        public int Id;
        public int color;
        public int state;
        public Image Sprite;
        public AffineTransform tx;
        public boolean dragged;
        public int x;
        public int y;

        public Piece(int Id, int color, int position) {
            dragged = false;
            this.Id = Id;
            this.color = color;

            x = 100 * (position % 8);
            y = 100 * (position / 8);

            System.out.println(x + ""x"" + y);

            tx = AffineTransform.getTranslateInstance(x, y);
            tx.scale(0.1, 0.1);
        }

        protected Image getImage(String path) throws IOException {
            BufferedImage img = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g2d = img.createGraphics();
            g2d.setFont(new JLabel().getFont().deriveFont(Font.PLAIN, 16));
            g2d.setColor(Color.BLACK);
            FontMetrics fm = g2d.getFontMetrics();

            int cellX = x;
            int cellY = y;

            String text = x + ""x"" + y;

            int x = (100 - fm.stringWidth(text)) / 2;
            int y = ((100 - fm.getHeight()) / 2) + fm.getAscent();

            g2d.drawString(text, x, y);

            g2d.setStroke(new BasicStroke(16));
            g2d.drawRect(0, 0, 99, 99);

            g2d.dispose();

            return img;
        }

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            g2.drawImage(Sprite, tx, null);
        }
    }
}",        Piece[][] board;,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Test#Piece.getImage(String) ,"import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new Main());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class Main extends JPanel implements ActionListener, MouseListener, KeyListener {

        Color GREEN = new Color(41, 176, 59);
        Color WHITE = new Color(254, 255, 228);

        Board board;

        public Main() throws IOException {
            board = new Board();
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(800, 800);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            super.paintComponent(g);
            boolean flag = true;
            for (int i = 0; i < 8; i++) {

                for (int j = 0; j < 8; j++) {
                    if (flag) {
                        g.setColor(WHITE);
                    } else {
                        g.setColor(GREEN);
                    }
                    g.fillRect((j * 100), (i * 100), ((j + 1) * 100), ((i + 1) * 100));
                    flag = !flag;
                }
                flag = !flag;
            }
            for (int i = 0; i < 8; i++) {
                for (int j = 0; j < 8; j++) {
                    if (board.board[i][j] != null) {
                        board.board[i][j].paint(g);
                    }
                }
            }
        }

        @Override
        public void actionPerformed(ActionEvent e) {
        }

        @Override
        public void mouseClicked(MouseEvent e) {
        }

        @Override
        public void mousePressed(MouseEvent e) {
        }

        @Override
        public void mouseReleased(MouseEvent e) {
        }

        @Override
        public void mouseEntered(MouseEvent e) {
        }

        @Override
        public void mouseExited(MouseEvent e) {
        }

        @Override
        public void keyTyped(KeyEvent e) {
        }

        @Override
        public void keyPressed(KeyEvent e) {
        }

        @Override
        public void keyReleased(KeyEvent e) {
        }
    }

    public class Board {

        Piece[][] board;

        public Board() throws IOException {
            board = new Piece[8][8];
            for (int i = 0; i < 8; i++) {
                board[1][i] = new Pawn(i, 1, 8 + i);
            }

            for (int i = 0; i < 8; i++) {
                board[6][i] = new Pawn(i, 0, 16 + i);
            }
        }

    }

    public class Pawn extends Piece {

        public Pawn(int Id, int color, int position) throws IOException {
            super(Id, color, position);
            this.state = 0;
            String path = ""/imgs/Pieces/"";
            if (color == 0) {
                path += ""W"";
            } else {
                path += ""B"";
            }
            path += ""_Pawn.png"";
            Sprite = getImage(path);
        }
    }

    public class Piece {

        public int Id;
        public int color;
        public int state;
        public Image Sprite;
        public AffineTransform tx;
        public boolean dragged;
        public int x;
        public int y;

        public Piece(int Id, int color, int position) {
            dragged = false;
            this.Id = Id;
            this.color = color;

            x = 100 * (position % 8);
            y = 100 * (position / 8);

            System.out.println(x + ""x"" + y);

            tx = AffineTransform.getTranslateInstance(x, y);
            tx.scale(0.1, 0.1);
        }

        protected Image getImage(String path) throws IOException {
            BufferedImage img = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g2d = img.createGraphics();
            g2d.setFont(new JLabel().getFont().deriveFont(Font.PLAIN, 16));
            g2d.setColor(Color.BLACK);
            FontMetrics fm = g2d.getFontMetrics();

            int cellX = x;
            int cellY = y;

            String text = x + ""x"" + y;

            int x = (100 - fm.stringWidth(text)) / 2;
            int y = ((100 - fm.getHeight()) / 2) + fm.getAscent();

            g2d.drawString(text, x, y);

            g2d.setStroke(new BasicStroke(16));
            g2d.drawRect(0, 0, 99, 99);

            g2d.dispose();

            return img;
        }

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            g2.drawImage(Sprite, tx, null);
        }
    }
}",            Sprite = getImage(path);,StackOverflow
UseLocaleWithCaseConversions,"When doing a String.toLowerCase()/toUpperCase() call, use a Locale","import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.List.of;

class Node {
    final String data;
    final List<Node> children;

    Node(String data, List<Node> children) {
        this.data = data;
        this.children = children;
    }
}

class Node2 {
    final String data;
    final String data2;
    final List<Node2> children;

    Node2(String data, String data2, List<Node2> children) {
        this.data = data;
        this.data2 = data2;
        this.children = children;
    }
}


public class TreeClone {

    static <A,B> B cloneTree(A a, BiFunction<A,List<B>,B> createB, Function<A,List<A>> extractAChildren) {
        List<B> children = extractAChildren.apply(a)
                .stream()
                .map(anA -> cloneTree(anA, createB, extractAChildren))
                .collect(Collectors.toList());
        return createB.apply(a, children);
    }

    public static void main(String[] args) {
        Node n = new Node(""root"", 
                of(new Node(""child1"", 
                        of(new Node(""gchild"", of()))), 
                        new Node(""child2"", of())
                )
        );
        Node2 n2 = cloneTree(n,
                (from, children) -> new Node2(from.data, from.data.toUpperCase(), children),
                node -> node.children
        );
    }
}","                (from, children) -> new Node2(from.data, from.data.toUpperCase(), children),",StackOverflow
AvoidDuplicateLiterals,"The String literal ""null"" appears 4 times in this file; the first occurrence is on line 5","@Data
public class Person {
  @JsonProperty
  @JsonSetter(nulls = Nulls.SKIP)
  private String name = ""null"";

  @JsonProperty
  @JsonSetter(nulls = Nulls.SKIP)
  private String surName = ""null"";
}



public class PersonTest {
  @Test
  public void testDeserializePerson() throws JsonProcessingException {
    var result = new ObjectMapper().readValue(""{\""name\"":null, \""surName\"":null}"", Person.class);
    assertEquals(result.getName(), ""null"");
    assertEquals(result.getSurName(), ""null"");
  }
}","  private String name = ""null"";",StackOverflow
TestClassWithoutTestCases,"The class 'PersonTest' might be a test class, but it contains no test cases.","@Data
public class Person {
  @JsonProperty
  @JsonSetter(nulls = Nulls.SKIP)
  private String name = ""null"";

  @JsonProperty
  @JsonSetter(nulls = Nulls.SKIP)
  private String surName = ""null"";
}



public class PersonTest {
  @Test
  public void testDeserializePerson() throws JsonProcessingException {
    var result = new ObjectMapper().readValue(""{\""name\"":null, \""surName\"":null}"", Person.class);
    assertEquals(result.getName(), ""null"");
    assertEquals(result.getSurName(), ""null"");
  }
}",public class PersonTest {,StackOverflow
TestClassWithoutTestCases,"The class 'AspectTest' might be a test class, but it contains no test cases.","@Aspect
@Component // this aspect will be a spring bean
public class AspectForCountingMethodCalls {

    public static AtomicLong setACounter = new AtomicLong(0L);
    public static AtomicLong setBCounter = new AtomicLong(0L);

    @Before(""execution (* setA(..))"") // executed before every call setA
    public void countSetACall() {
        setACounter.getAndIncrement(); // increase counter
    }

    @Before(""execution (* setB(..))"") // executed before every call setB
    public void countSetBCall() {
        setBCounter.getAndIncrement(); // increase counter
    }

}

@SpringBootTest
public class AspectTest {

    @Autowired
    ClassWithMethods classWithMethods;

    @Test
    void testCounter() {
        // call setA 17 times
        for (int i = 0; i < 17; i++) {
            classWithMethods.setA();
        }
        // call setB 3 times
        for (int i = 0; i < 3; i++) {
            classWithMethods.setB();
        }
        // verify that our aspect works
        assertEquals(17L, AspectForCountingMethodCalls.setACounter.get());
        assertEquals(3L, AspectForCountingMethodCalls.setBCounter.get());
    }
}",public class AspectTest {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import software.amazon.awssdk.core.ResponseBytes;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.S3Exception;
import software.amazon.awssdk.services.s3.model.GetObjectResponse;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
// snippet-end:[s3.java2.getobjectdata.import]

/**
 * Before running this Java V2 code example, set up your development
 * environment, including your credentials.
 *
 * For more information, see the following documentation topic:
 *
 * https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-started.html
 */

public class GetObjectData {
    public static void main(String[] args) {
        final String usage = """"""

                Usage:
                    <bucketName> <keyName> <path>

                Where:
                    bucketName - The Amazon S3 bucket name.\s
                    keyName - The key name.\s
                    path - The path where the file is written to.\s
                """""";

        if (args.length != 3) {
            System.out.println(usage);
            System.exit(1);
        }

        String bucketName = args[0];
        String keyName = args[1];
        String path = args[2];
        Region region = Region.US_EAST_1;
        S3Client s3 = S3Client.builder()
                .region(region)
                .build();

        getObjectBytes(s3, bucketName, keyName, path);
    }

    public static void getObjectBytes(S3Client s3, String bucketName, String keyName, String path) {
        try {
            GetObjectRequest objectRequest = GetObjectRequest
                    .builder()
                    .key(keyName)
                    .bucket(bucketName)
                    .build();

            ResponseBytes<GetObjectResponse> objectBytes = s3.getObjectAsBytes(objectRequest);
            byte[] data = objectBytes.asByteArray();

            // Write the data to a local file.
            File myFile = new File(path);
            OutputStream os = new FileOutputStream(myFile);
            os.write(data);
            System.out.println(""Successfully obtained bytes from an S3 object"");
            os.close();

        } catch (IOException ex) {
            ex.printStackTrace();
        } catch (S3Exception e) {
            System.err.println(e.awsErrorDetails().errorMessage());
            System.exit(1);
        }
    }
}",        if (args.length != 3) {,StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import software.amazon.awssdk.core.ResponseBytes;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.S3Exception;
import software.amazon.awssdk.services.s3.model.GetObjectResponse;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
// snippet-end:[s3.java2.getobjectdata.import]

/**
 * Before running this Java V2 code example, set up your development
 * environment, including your credentials.
 *
 * For more information, see the following documentation topic:
 *
 * https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-started.html
 */

public class GetObjectData {
    public static void main(String[] args) {
        final String usage = """"""

                Usage:
                    <bucketName> <keyName> <path>

                Where:
                    bucketName - The Amazon S3 bucket name.\s
                    keyName - The key name.\s
                    path - The path where the file is written to.\s
                """""";

        if (args.length != 3) {
            System.out.println(usage);
            System.exit(1);
        }

        String bucketName = args[0];
        String keyName = args[1];
        String path = args[2];
        Region region = Region.US_EAST_1;
        S3Client s3 = S3Client.builder()
                .region(region)
                .build();

        getObjectBytes(s3, bucketName, keyName, path);
    }

    public static void getObjectBytes(S3Client s3, String bucketName, String keyName, String path) {
        try {
            GetObjectRequest objectRequest = GetObjectRequest
                    .builder()
                    .key(keyName)
                    .bucket(bucketName)
                    .build();

            ResponseBytes<GetObjectResponse> objectBytes = s3.getObjectAsBytes(objectRequest);
            byte[] data = objectBytes.asByteArray();

            // Write the data to a local file.
            File myFile = new File(path);
            OutputStream os = new FileOutputStream(myFile);
            os.write(data);
            System.out.println(""Successfully obtained bytes from an S3 object"");
            os.close();

        } catch (IOException ex) {
            ex.printStackTrace();
        } catch (S3Exception e) {
            System.err.println(e.awsErrorDetails().errorMessage());
            System.exit(1);
        }
    }
}",            OutputStream os = new FileOutputStream(myFile);,StackOverflow
DoNotTerminateVM,System.exit() should not be used in J2EE/JEE apps,"import software.amazon.awssdk.core.ResponseBytes;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.S3Exception;
import software.amazon.awssdk.services.s3.model.GetObjectResponse;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
// snippet-end:[s3.java2.getobjectdata.import]

/**
 * Before running this Java V2 code example, set up your development
 * environment, including your credentials.
 *
 * For more information, see the following documentation topic:
 *
 * https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-started.html
 */

public class GetObjectData {
    public static void main(String[] args) {
        final String usage = """"""

                Usage:
                    <bucketName> <keyName> <path>

                Where:
                    bucketName - The Amazon S3 bucket name.\s
                    keyName - The key name.\s
                    path - The path where the file is written to.\s
                """""";

        if (args.length != 3) {
            System.out.println(usage);
            System.exit(1);
        }

        String bucketName = args[0];
        String keyName = args[1];
        String path = args[2];
        Region region = Region.US_EAST_1;
        S3Client s3 = S3Client.builder()
                .region(region)
                .build();

        getObjectBytes(s3, bucketName, keyName, path);
    }

    public static void getObjectBytes(S3Client s3, String bucketName, String keyName, String path) {
        try {
            GetObjectRequest objectRequest = GetObjectRequest
                    .builder()
                    .key(keyName)
                    .bucket(bucketName)
                    .build();

            ResponseBytes<GetObjectResponse> objectBytes = s3.getObjectAsBytes(objectRequest);
            byte[] data = objectBytes.asByteArray();

            // Write the data to a local file.
            File myFile = new File(path);
            OutputStream os = new FileOutputStream(myFile);
            os.write(data);
            System.out.println(""Successfully obtained bytes from an S3 object"");
            os.close();

        } catch (IOException ex) {
            ex.printStackTrace();
        } catch (S3Exception e) {
            System.err.println(e.awsErrorDetails().errorMessage());
            System.exit(1);
        }
    }
}",            System.exit(1);,StackOverflow
ReturnEmptyCollectionRatherThanNull,Return an empty collection rather than null.,"package com.amansprojects.craftclaw;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import org.apache.http.HttpEntity;
import org.apache.http.NameValuePair;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;

import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

/**
 * A class to interface with the Firebase Auth REST API.
 */
public class FirebaseAuthManager {
    private static final String BASE_URL = ""https://www.googleapis.com/identitytoolkit/v3/relyingparty/"";
    private static final String OPERATION_AUTH = ""verifyPassword"";
    private static final String OPERATION_ACCOUNT_INFO = ""getAccountInfo"";
    private static final String OPERATION_SEND_PASSWORD_RESET = ""getOobConfirmationCode"";

    private final String firebaseKey;

    private static FirebaseAuthManager instance = null;

    protected FirebaseAuthManager() {
        firebaseKey = ""YOUR_KEY_HERE"";
    }

    public static FirebaseAuthManager getInstance() {
        if (instance == null) {
            instance = new FirebaseAuthManager();
        }
        return instance;
    }

    /**
     * Exchange an email and password with the Firebase Auth REST API for an ID token.
     * @param username A username or email registered with Firebase Authentication.
     * @param password The password associated with the username or email.
     * @return An ID token from Firebase.
     * @throws FirebaseAuthException
     */
    public String auth(String username, String password) throws FirebaseAuthException {
        String token;
        try {
            HttpClient httpclient = HttpClients.createDefault();
            HttpPost httppost = new HttpPost(BASE_URL + OPERATION_AUTH + ""?key="" + firebaseKey);
            List<NameValuePair> params = new ArrayList<NameValuePair>(1);
            params.add(new BasicNameValuePair(""email"", username));
            params.add(new BasicNameValuePair(""password"", password));
            params.add(new BasicNameValuePair(""returnSecureToken"", ""true""));
            httppost.setEntity(new UrlEncodedFormEntity(params, StandardCharsets.UTF_8));
            HttpEntity entity = httpclient.execute(httppost).getEntity();

            JsonParser jp = new JsonParser();
            JsonElement root = jp.parse(new InputStreamReader(entity.getContent()));
            JsonObject rootObj = root.getAsJsonObject();

            if (rootObj.get(""error"") != null) {
                throw new FirebaseAuthException(rootObj.get(""error"").getAsJsonObject().get(""message"").getAsString());
            }
            token = rootObj.get(""idToken"").getAsString();
        } catch (IOException e) { System.out.println(e.getMessage()); return null; }
        return token;
    }

    /**
     * Exchange an ID token with the Firebase Auth REST API for a User object.
     * @param token An ID token from Firebase.
     * @return A user object with the email and UID returned by Firebase.
     */
    public User getAccountInfo(String token) {
        try {
            HttpClient httpclient = HttpClients.createDefault();
            HttpPost httppost = new HttpPost(BASE_URL + OPERATION_ACCOUNT_INFO + ""?key="" + firebaseKey);
            List<NameValuePair> params = new ArrayList<NameValuePair>(1);
            params.add(new BasicNameValuePair(""idToken"", token));
            httppost.setEntity(new UrlEncodedFormEntity(params, ""UTF-8""));
            HttpEntity entity = httpclient.execute(httppost).getEntity();

            JsonParser jp = new JsonParser();
            JsonElement root = jp.parse(new InputStreamReader(entity.getContent()));
            JsonObject rootObj = root.getAsJsonObject();

            JsonObject userObj = rootObj.get(""users"").getAsJsonArray().get(0).getAsJsonObject();
            return new User(userObj.get(""email"").getAsString(), userObj.get(""localId"").getAsString(), token);
        } catch (IOException e) { System.out.println(e.getMessage()); return null; }
    }

    /**
     * Send a reset password email via Firebase.
     * @param email The email address to send the reset password email to.
     */
    public void sendResetPasswordLink(String email) {
        try {
            HttpClient httpclient = HttpClients.createDefault();
            HttpPost httppost = new HttpPost(BASE_URL + OPERATION_SEND_PASSWORD_RESET + ""?key="" + firebaseKey);
            List<NameValuePair> params = new ArrayList<NameValuePair>(2);
            params.add(new BasicNameValuePair(""requestType"", ""PASSWORD_RESET""));
            params.add(new BasicNameValuePair(""email"", email));
            httppost.setEntity(new UrlEncodedFormEntity(params, ""UTF-8""));
            httpclient.execute(httppost);
        } catch (IOException e) { e.printStackTrace(); }
    }

    /**
     * Exchange a refresh token with the Firebase Auth REST API for a new ID token.
     * @param refreshToken The refresh token used to receive an ID token.
     * @return A new ID token from Firebase.
     */
    public String[] exchangeRefreshToken(String refreshToken) {
        try {
            HttpClient httpclient = HttpClients.createDefault();
            HttpPost httppost = new HttpPost(""https://securetoken.googleapis.com/v1/token?key=""+ firebaseKey);
            List<NameValuePair> params = new ArrayList<NameValuePair>(2);
            params.add(new BasicNameValuePair(""grant_type"", ""refresh_token""));
            params.add(new BasicNameValuePair(""refresh_token"", refreshToken));
            httppost.setEntity(new UrlEncodedFormEntity(params, ""UTF-8""));
            HttpEntity entity = httpclient.execute(httppost).getEntity();
            if (entity != null) {
                JsonParser jp = new JsonParser();
                JsonElement root = jp.parse(new InputStreamReader(entity.getContent()));
                JsonObject rootObj = root.getAsJsonObject();
                return new String[]{ rootObj.get(""id_token"").getAsString(), rootObj.get(""refresh_token"").getAsString() };
            }
        } catch (IOException e) { e.printStackTrace(); }
        return null;
    }
}",        return null;,StackOverflow
AvoidBranchingStatementAsLastInLoop,Avoid using a branching statement as the last in a loop.,"public class Main {
    public static void main(String[] args) {
        int coord1 = 0, coord2 = 0;
        do {
            coord1 = readCoordinate(""Enter first coordinate: "");
            coord2 = readCoordinate(""Enter second coordinate: "");

            //Showing an error message if the coords refer to an occupied cell
            if (cellOccupied(field, coord1, coord2)) {
                System.out.println(""This cell is occupied! Choose another one!"");
            }
        } while (cellOccupied(field, coord1, coord2));
    }

    private static int readCoordinate(String message) {
        int coord;
        Scanner scanner = new Scanner(System.in);
        while (true) {
            System.out.print(message);
            if (scanner.hasNextInt()) {
                coord = scanner.nextInt();

                //getting rid of the new line character after reading the int
                scanner.nextLine();

                //Checking coordinate value
                if (coord < 1 || coord > 3) {
                    System.out.println(""Coordinates should be from 1 to 3!"");
                    continue;
                }
            } else {
                //assigning an undesired value (since your coords must be between 1 and 3
                coord = 0;

                //getting rid of the wrong user input
                scanner.nextLine();

                //Showing an error message
                System.out.println(""Please enter an int value"");

                //Skipping directly to the loop's condition
                continue;
            }

            break;
        }

        return coord;
    }
}",            break;,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","public class Test {
    public static void main(String[] args) {
        // Case 1
        List<String> order1 = Arrays.asList(""A"", ""B"");
        List<String> sended1 = Arrays.asList(""A"", ""B"");
        System.out.println(""Case 1: "" + getMissingItems(order1,sended1));

        // Case 2
        List<String> order2 = Arrays.asList(""A"", ""B"", ""C"");
        List<String> sended2 = Arrays.asList(""B"", ""C"");
        System.out.println(""Case 2: "" + getMissingItems(order2,sended2));

        // Case 3
        List<String> order3 = Arrays.asList(""A"", ""D"");
        List<String> sended3 = Arrays.asList(""A"", ""B"", ""C"", ""D"");
        System.out.println(""Case 3: "" + getMissingItems(order3,sended3));

        // Case 4
        List<String> order4 = Arrays.asList(""A"", ""D"", ""F"");
        List<String> sended4 = Arrays.asList(""A"", ""B"", ""C"", ""D"");
        System.out.println(""Case 4: "" + getMissingItems(order4,sended4));
    }

    private static String getMissingItems(List<String> order, 
                                          List<String> sended){
        StringBuilder sb = new StringBuilder();
        List<String> missingInOrder = getMissingInList(order, sended);
        createMessage(sb, missingInOrder,"" item(s) missing in order: "");
        List<String> missingInSended = getMissingInList(sended, order);
        if(!missingInOrder.isEmpty() && !missingInSended.isEmpty()){
            sb.append("" && "");
        }
        createMessage(sb, missingInSended,"" item(s) missing in sended: "");
        return sb.isEmpty() ? ""No difference"":sb.toString();
    }

    private static void createMessage(StringBuilder sb, 
                                      List<String> diffInList,
                                      String msg) {
        if(!diffInList.isEmpty()){
            sb.append(diffInList.size())
              .append(msg)
              .append(String.join("","", diffInList));
        }
    }

    private static List<String> getMissingInList(List<String> list1, 
                                                 List<String> list2) {
        return list2.stream()
                    .filter(e -> !list1.contains(e))
                    .collect(Collectors.toList());
    }
}",public class Test {,StackOverflow
AvoidDuplicateLiterals,"The String literal ""name"" appears 4 times in this file; the first occurrence is on line 124","package com.example.javafx;

import com.example.javafx.Person.Altruism;
import com.example.javafx.Person.Goodness;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import javafx.application.Application;
import javafx.beans.binding.*;
import javafx.beans.property.*;
import javafx.collections.*;
import javafx.collections.transformation.*;
import javafx.geometry.*;
import javafx.scene.*;
import javafx.scene.control.*;
import javafx.scene.control.TableView.TableViewSelectionModel;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import org.controlsfx.control.CheckComboBox;

public class Solution extends Application {

    CheckComboBox altruismSelector
            = new CheckComboBox(FXCollections.observableArrayList(Altruism.values()));

    public static void main(String[] args) {
        launch(args);
    }
    
    Database db = new Database();

    @Override
    public void start(Stage stage) throws Exception {
        BorderPane layout = new BorderPane();
        VBox controls = new VBox(5);

        Button clearFilter = new Button(""reset filter"");
        clearFilter.setOnAction(event -> {
            resetChecks();
        });

        controls.getChildren().setAll(
                new Label(""altruism:""),
                altruismSelector,
                clearFilter);

        ObjectProperty<Predicate<Person>> altruismPredicate = new SimpleObjectProperty<>();
        altruismPredicate.bind(Bindings.createObjectBinding(
                () -> person -> {
                    final Altruism a = person.getAltruism();
                    final ObservableList<Altruism> checkedItems = altruismSelector.getCheckModel().getCheckedItems();
                    return checkedItems.contains(a) || checkedItems.isEmpty();
                }, altruismSelector.getCheckModel().getCheckedItems()));

        ObservableList<Person> people = FXCollections.observableArrayList(db.fetchAll());
        FilteredList<Person> filteredPeople = people.filtered(p -> true);
        ObservableList<Person> sortedPeople = FXCollections.observableArrayList(filteredPeople);
        TableView<Person> peopleTableView = setupAllPeopleTableView(sortedPeople);
        
        filteredPeople.addListener(new ListChangeListener<Person>() {
            @Override
            public void onChanged(ListChangeListener.Change<? extends Person>c) {
                TableViewSelectionModel selection = peopleTableView.getSelectionModel();
                // capture existing selection from the table's selection model
                List<Person> selectedPeople = new ArrayList<>(selection.getSelectedItems());
                // clear table's selection
                selection.clearSelection();
                // jam the contents of the change into the people list
                sortedPeople.setAll(c.getList());
                // restore selections if they're still in the list after the change
                for (Person p : selectedPeople) {
                    if (c.getList().contains(p)) {
                        selection.select(p);
                    }
                }
                // help out the GC?
                selectedPeople.clear();
            }
        });

        filteredPeople.predicateProperty()
                .bind(Bindings.createObjectBinding(
                        () -> altruismPredicate.get()/*.and(goodnessPredicate.get())*/,
                        altruismPredicate /*, goodnessPredicate*/));

        
        ObservableList<Person> selectedPeople = FXCollections.observableArrayList();
        TableView<Person> detailTableView = setupDetailedPersonTableView(selectedPeople);

        sortedPeople.addListener(new ListChangeListener<Person>() {
            @Override
            public void onChanged(ListChangeListener.Change<? extends Person> c) {
                System.out.println(c.getList().size() + "" items in visible list: "" + c.getList());
            }
        });

        peopleTableView.getSelectionModel().getSelectedItems().addListener(new ListChangeListener<Person>() {
            @Override
            public void onChanged(ListChangeListener.Change<? extends Person> c) {
                System.out.println(c.getList().size() + "" items selected: "" + c.getList());
                selectedPeople.clear();
                List<Integer> ids = c.getList().stream()
                        .map(e->e.getId())
                        .distinct()
                        .collect(Collectors.toList());
                selectedPeople.setAll(db.fetchByIds(ids));
            }
        });

        SplitPane tableViews = new SplitPane(peopleTableView, detailTableView);
        tableViews.setOrientation(Orientation.HORIZONTAL);
        
        layout.setCenter(tableViews);
        layout.setLeft(controls);

        resetChecks();

        stage.setScene(new Scene(layout));
        stage.show();
    }

    private TableView<Person> setupAllPeopleTableView(ObservableList<Person> people) {
        
        TableColumn<Person, String> nameColumn = new TableColumn(""name"");
        nameColumn.setId(""name"");
        nameColumn.setCellValueFactory(cell -> cell.getValue().nameProperty());
        
        TableColumn<Person, Altruism> altruismColumn = new TableColumn(""altruism"");
        altruismColumn.setId(""altruism"");
        altruismColumn.setCellValueFactory(cell -> cell.getValue().altruismProperty());
        
        TableView<Person> peopleTableView = new TableView<>();
        peopleTableView.getColumns().setAll(
                nameColumn,
                altruismColumn
        );
        peopleTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        peopleTableView.setItems(people);
        return peopleTableView;
    }

    private TableView<Person> setupDetailedPersonTableView(ObservableList<Person> people) {

        TableColumn<Person, String> nameColumn = new TableColumn(""name"");
        nameColumn.setId(""name"");
        nameColumn.setCellValueFactory(cell -> cell.getValue().nameProperty());

        TableColumn<Person, String> emailColumn = new TableColumn(""email"");
        emailColumn.setId(""email"");
        emailColumn.setCellValueFactory(cell -> cell.getValue().emailProperty());

        TableColumn<Person, Altruism> altruismColumn = new TableColumn(""altruism"");
        altruismColumn.setId(""altruism"");
        altruismColumn.setCellValueFactory(cell -> cell.getValue().altruismProperty());
        
        TableColumn<Person, Goodness> goodnessColumn = new TableColumn(""goodness"");
        goodnessColumn.setId(""goodness"");
        goodnessColumn.setCellValueFactory(cell -> cell.getValue().goodnessProperty());

        TableView<Person> tableView = new TableView<>();
        tableView.getColumns().setAll(
                nameColumn,
                emailColumn,
                altruismColumn,
                goodnessColumn
        );
        tableView.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
        tableView.setItems(people);
        
        return tableView;
    }

    private void resetChecks() {
        System.out.println(""resetChecks"");
        altruismSelector.getCheckModel().clearChecks();
    }

    private static void delay(final int delay) {
        try {
            Thread.sleep(delay);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}","        TableColumn<Person, String> nameColumn = new TableColumn(""name"");",StackOverflow
AvoidDuplicateLiterals,"The String literal ""altruism"" appears 4 times in this file; the first occurrence is on line 128","package com.example.javafx;

import com.example.javafx.Person.Altruism;
import com.example.javafx.Person.Goodness;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import javafx.application.Application;
import javafx.beans.binding.*;
import javafx.beans.property.*;
import javafx.collections.*;
import javafx.collections.transformation.*;
import javafx.geometry.*;
import javafx.scene.*;
import javafx.scene.control.*;
import javafx.scene.control.TableView.TableViewSelectionModel;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import org.controlsfx.control.CheckComboBox;

public class Solution extends Application {

    CheckComboBox altruismSelector
            = new CheckComboBox(FXCollections.observableArrayList(Altruism.values()));

    public static void main(String[] args) {
        launch(args);
    }
    
    Database db = new Database();

    @Override
    public void start(Stage stage) throws Exception {
        BorderPane layout = new BorderPane();
        VBox controls = new VBox(5);

        Button clearFilter = new Button(""reset filter"");
        clearFilter.setOnAction(event -> {
            resetChecks();
        });

        controls.getChildren().setAll(
                new Label(""altruism:""),
                altruismSelector,
                clearFilter);

        ObjectProperty<Predicate<Person>> altruismPredicate = new SimpleObjectProperty<>();
        altruismPredicate.bind(Bindings.createObjectBinding(
                () -> person -> {
                    final Altruism a = person.getAltruism();
                    final ObservableList<Altruism> checkedItems = altruismSelector.getCheckModel().getCheckedItems();
                    return checkedItems.contains(a) || checkedItems.isEmpty();
                }, altruismSelector.getCheckModel().getCheckedItems()));

        ObservableList<Person> people = FXCollections.observableArrayList(db.fetchAll());
        FilteredList<Person> filteredPeople = people.filtered(p -> true);
        ObservableList<Person> sortedPeople = FXCollections.observableArrayList(filteredPeople);
        TableView<Person> peopleTableView = setupAllPeopleTableView(sortedPeople);
        
        filteredPeople.addListener(new ListChangeListener<Person>() {
            @Override
            public void onChanged(ListChangeListener.Change<? extends Person>c) {
                TableViewSelectionModel selection = peopleTableView.getSelectionModel();
                // capture existing selection from the table's selection model
                List<Person> selectedPeople = new ArrayList<>(selection.getSelectedItems());
                // clear table's selection
                selection.clearSelection();
                // jam the contents of the change into the people list
                sortedPeople.setAll(c.getList());
                // restore selections if they're still in the list after the change
                for (Person p : selectedPeople) {
                    if (c.getList().contains(p)) {
                        selection.select(p);
                    }
                }
                // help out the GC?
                selectedPeople.clear();
            }
        });

        filteredPeople.predicateProperty()
                .bind(Bindings.createObjectBinding(
                        () -> altruismPredicate.get()/*.and(goodnessPredicate.get())*/,
                        altruismPredicate /*, goodnessPredicate*/));

        
        ObservableList<Person> selectedPeople = FXCollections.observableArrayList();
        TableView<Person> detailTableView = setupDetailedPersonTableView(selectedPeople);

        sortedPeople.addListener(new ListChangeListener<Person>() {
            @Override
            public void onChanged(ListChangeListener.Change<? extends Person> c) {
                System.out.println(c.getList().size() + "" items in visible list: "" + c.getList());
            }
        });

        peopleTableView.getSelectionModel().getSelectedItems().addListener(new ListChangeListener<Person>() {
            @Override
            public void onChanged(ListChangeListener.Change<? extends Person> c) {
                System.out.println(c.getList().size() + "" items selected: "" + c.getList());
                selectedPeople.clear();
                List<Integer> ids = c.getList().stream()
                        .map(e->e.getId())
                        .distinct()
                        .collect(Collectors.toList());
                selectedPeople.setAll(db.fetchByIds(ids));
            }
        });

        SplitPane tableViews = new SplitPane(peopleTableView, detailTableView);
        tableViews.setOrientation(Orientation.HORIZONTAL);
        
        layout.setCenter(tableViews);
        layout.setLeft(controls);

        resetChecks();

        stage.setScene(new Scene(layout));
        stage.show();
    }

    private TableView<Person> setupAllPeopleTableView(ObservableList<Person> people) {
        
        TableColumn<Person, String> nameColumn = new TableColumn(""name"");
        nameColumn.setId(""name"");
        nameColumn.setCellValueFactory(cell -> cell.getValue().nameProperty());
        
        TableColumn<Person, Altruism> altruismColumn = new TableColumn(""altruism"");
        altruismColumn.setId(""altruism"");
        altruismColumn.setCellValueFactory(cell -> cell.getValue().altruismProperty());
        
        TableView<Person> peopleTableView = new TableView<>();
        peopleTableView.getColumns().setAll(
                nameColumn,
                altruismColumn
        );
        peopleTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        peopleTableView.setItems(people);
        return peopleTableView;
    }

    private TableView<Person> setupDetailedPersonTableView(ObservableList<Person> people) {

        TableColumn<Person, String> nameColumn = new TableColumn(""name"");
        nameColumn.setId(""name"");
        nameColumn.setCellValueFactory(cell -> cell.getValue().nameProperty());

        TableColumn<Person, String> emailColumn = new TableColumn(""email"");
        emailColumn.setId(""email"");
        emailColumn.setCellValueFactory(cell -> cell.getValue().emailProperty());

        TableColumn<Person, Altruism> altruismColumn = new TableColumn(""altruism"");
        altruismColumn.setId(""altruism"");
        altruismColumn.setCellValueFactory(cell -> cell.getValue().altruismProperty());
        
        TableColumn<Person, Goodness> goodnessColumn = new TableColumn(""goodness"");
        goodnessColumn.setId(""goodness"");
        goodnessColumn.setCellValueFactory(cell -> cell.getValue().goodnessProperty());

        TableView<Person> tableView = new TableView<>();
        tableView.getColumns().setAll(
                nameColumn,
                emailColumn,
                altruismColumn,
                goodnessColumn
        );
        tableView.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
        tableView.setItems(people);
        
        return tableView;
    }

    private void resetChecks() {
        System.out.println(""resetChecks"");
        altruismSelector.getCheckModel().clearChecks();
    }

    private static void delay(final int delay) {
        try {
            Thread.sleep(delay);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}","        TableColumn<Person, Altruism> altruismColumn = new TableColumn(""altruism"");",StackOverflow
TestClassWithoutTestCases,"The class 'TestKafkaProducerConfig' might be a test class, but it contains no test cases.","@TestConfiguration
public static class TestKafkaProducerConfig {

    @Bean
    public KafkaTemplate<String, MyEvent> kafkaTemplate(
            @Value(""${kafka.consumer.my-topic-name}"") String topicName, EmbeddedKafkaBroker embeddedKafka) {

        var template = new KafkaTemplate<>(producerFactory(embeddedKafka));
        template.setDefaultTopic(topicName);

        // Use SimpleKafkaHeaderMapper which does not add the json types header, `spring_json_header_types`.
        // The mapAllStringsOut when set to true, all string-valued headers will be converted to byte[] using
        // the charset property (default UTF-8).
        var headerMapper = new SimpleKafkaHeaderMapper();
        headerMapper.setMapAllStringsOut(true);

        var messageConverter = new MessagingMessageConverter();
        messageConverter.setHeaderMapper(headerMapper);

        template.setMessageConverter(messageConverter);
        return template;
    }

    @Bean
    public ProducerFactory<String, MyEvent> producerFactory(EmbeddedKafkaBroker embeddedKafka) {
        return new DefaultKafkaProducerFactory<>(producerConfig(embeddedKafka));
    }

    public Map<String, Object> producerConfig(EmbeddedKafkaBroker embeddedKafka) {
        Map<String, Object> props = KafkaTestUtils.producerProps(embeddedKafka);
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        props.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, false);
        return props;
    }
}",public static class TestKafkaProducerConfig {,StackOverflow
TestClassWithoutTestCases,"The class 'TestCustomBlockageWithVTs' might be a test class, but it contains no test cases.","package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",public class TestCustomBlockageWithVTs {,StackOverflow
AvoidCatchingThrowable,A catch statement should never catch throwable since it includes errors.,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",        } catch (Throwable e) {,StackOverflow
AvoidDuplicateLiterals,"The String literal "" sec"" appears 4 times in this file; the first occurrence is on line 102","package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}","        p(""Whole test took "" + d + "" sec"");",StackOverflow
CloseResource,Ensure that resources like this ExecutorService object are closed after use,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());,StackOverflow
CloseResource,Ensure that resources like this ServerSocket object are closed after use,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",        ServerSocket ss = new ServerSocket(PORT);,StackOverflow
EmptyCatchBlock,Avoid empty catch blocks,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}","            } catch (IOException e) {
                //e.printStackTrace();
            }",StackOverflow
CloseResource,Ensure that resources like this InputStream object are closed after use,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",                InputStream is = s.getInputStream();,StackOverflow
CloseResource,Ensure that resources like this DataInputStream object are closed after use,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",                DataInputStream dis = new DataInputStream(is);,StackOverflow
CloseResource,Ensure that resources like this OutputStream object are closed after use,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",                OutputStream os = s.getOutputStream();,StackOverflow
CloseResource,Ensure that resources like this OutputStream object are closed after use,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",            OutputStream os = s.getOutputStream();,StackOverflow
CloseResource,Ensure that resources like this DataOutputStream object are closed after use,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",            DataOutputStream dos = new DataOutputStream(os);,StackOverflow
CloseResource,Ensure that resources like this InputStream object are closed after use,"package vttests;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class TestCustomBlockageWithVTs {
    static final boolean DEBUGGING = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(""-agentlib:jdwp"");
    static final boolean TRACELOG = false;
    
    static final int PORT = 42000;
    static final int BLOCKAGE_DURATION_MS = 1000;
    static final int NUM_REPETITION = 3;
    
    static MethodHandle getTidMH;
    static {
        System.loadLibrary(""kernel32"");
        SymbolLookup.loaderLookup().find(""GetCurrentThreadId"").ifPresent(mseg -> {
            FunctionDescriptor mdesc = FunctionDescriptor.of(ValueLayout.JAVA_INT);
            getTidMH = Linker.nativeLinker().downcallHandle(mseg, mdesc);
        });
    }
    
    static Integer tid() {
        try {
            return getTidMH != null ? (int)getTidMH.invokeExact() : null;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    static void p(Object msg) {
        System.out.println(""[""
            + (Thread.currentThread().isVirtual() ? ""V"" : ""P"")
            + ""/""+ Thread.currentThread().getName()
            + ""(""+tid()+"")]: "" 
            + msg
        );
    }
    
    public static void main(String[] args) throws Exception {
        //NOTE: jdk.tracePinnedThreads hangs the JVM in debug mode
        if(!DEBUGGING)
            System.setProperty(""jdk.tracePinnedThreads"", ""short""); //or ""full""
        
        boolean useVirtual = true;
        
        runTest(""synchronized waits"", useVirtual, SyncWaitTask.class);
        runTest(""synchronized sleep"", useVirtual, SyncSleepTask.class);
        runTest(""reentrant lock waits"", useVirtual, RLWaitTask.class);
        runTest(""reentrant lock sleep"", useVirtual, RLSleepTask.class);
        runTest(""sleep"", useVirtual, SleepTask.class);
        
        try(Closeable startServer = startServer()) {
            runTest(""net read"", useVirtual, NetTask.class);
            runTest(""sync net read"", useVirtual, SyncNetTask.class);
        }           
    }
    
    static void runTest(String title, boolean useVT, Class<? extends AbstractBlockingTask> clazz) throws InterruptedException, ExecutionException {
        Map<Integer,Set<Integer>> tid2id = new ConcurrentHashMap<>();
        Map<Integer,Set<Integer>> id2tid = new ConcurrentHashMap<>();
        BiConsumer<Integer,Integer> recorder = (tid,taskId) -> {
            tid2id.computeIfAbsent(tid, _tid -> Collections.synchronizedSet(new TreeSet<>())).add(taskId);
            id2tid.computeIfAbsent(taskId, _id -> Collections.synchronizedSet(new TreeSet<>())).add(tid);
        };
        
        AtomicInteger nextTaskId = new AtomicInteger(0);
        Supplier<Runnable> taskFactory = () -> newTask(clazz, nextTaskId.getAndIncrement(), BLOCKAGE_DURATION_MS, recorder);
        
        long t = System.nanoTime();
        runTasks(title, useVT, taskFactory);
        double d = 1e-9*(System.nanoTime() - t);
        p(""Whole test took "" + d + "" sec"");
        
        double expectedLow = 1e-3 * BLOCKAGE_DURATION_MS * NUM_REPETITION;
        double expectedHigh = 1.10 * expectedLow;
        if(d<expectedLow || d>expectedHigh) {
            p(""\n\n>>>>>>>>>>>> ""+title+"": test lasted outside of expected time of ~""+expectedLow+"" sec : ""+d+"" sec <<<<<<<<<<\n\n"");
        }
        
        p(""thread-taskid mappings recorded ""+tid2id.size()+"" distinct native threads"");
        tid2id.values().removeIf(set -> set.size()<=1);
        tid2id.forEach( (tid,id) -> p(""\tThread ""+tid+"" was shared among tasks ids ""+id));
        
        p(""task-thread mappings recorded ""+id2tid.size()+"" distinct tasks"");
        id2tid.values().removeIf(set -> set.size()<=1);
        id2tid.forEach( (id,tid) -> p(""\tTask ""+id+"" was carried with thread ids ""+tid));
    }
    
    static AbstractBlockingTask newTask(Class<? extends AbstractBlockingTask> clazz, int taskId, int delayms, BiConsumer<Integer, Integer> recorder) {
        AbstractBlockingTask t;
        try {
            t = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
            throw new RuntimeException(e);
        }
        t.taskId = taskId;
        t.indent = ""\t"".repeat(taskId) +""#"";
        t.delayMs = delayms;
        t.recorder = recorder;
        return t;
    }
    
    static void runTasks(String title, boolean useVT, Supplier<Runnable> taskFactory) throws InterruptedException, ExecutionException {
        int cores = Runtime.getRuntime().availableProcessors();
        int N = 3 * cores;
        
        p(""\n\n=========== ""+title+"" ""+(useVT?""using VT"":""using platform"")+"" threads ===============\n"");
        p(""Processors count  = "" + cores+""; threads to create = "" + N);
        
        long t0;
        long d;
        
        ExecutorService es = useVT ? Executors.newVirtualThreadPerTaskExecutor() : Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        try (es) {
            t0 = System.nanoTime();
            List<? extends Future<?>> futures = IntStream
                .range(0, N)
                .mapToObj(i -> taskFactory.get())
                .map(es::submit)
                .toList();
            
            //--------
            
            if(TRACELOG) p(""waiting for all futures..."");
            for(Future<?> future: futures) {
                        future.get();
            }
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""waiting futures took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""shutting down es and await termination..."");
            t0 = System.nanoTime();
            es.shutdown();
            es.awaitTermination(1, TimeUnit.SECONDS);
            d = System.nanoTime()-t0;
            if(TRACELOG) p(""shut down took ""+1e-9*d+"" sec"");
            
            //--------
            
            if(TRACELOG) p(""closing executor..."");
            t0 = System.nanoTime();
        }
        
        if(TRACELOG) p(""closing executor took "" + 1e-9*d + "" sec"");
    }
    
    
    static abstract class AbstractBlockingTask implements Runnable {
        int taskId;
        private int delayMs;
        private String indent;
        BiConsumer<Integer,Integer> recorder;
        
        AbstractBlockingTask() {
        }
        
        @Override
        public void run() {
            if(TRACELOG) p(indent + ""task "" + taskId + "" started."");
            work();
            if(TRACELOG) p(indent + ""task "" + taskId + "" ended."");
        }
        
        void work() {
            for(int i=1; i<=NUM_REPETITION; i++) {
                if(TRACELOG) p(indent + ""call ""+i+"" starting ... "");
                try {
                    block(delayMs);
                } catch (InterruptedException e) {
                    p(""call ""+i+"" interrupted!"");
                }
                if(TRACELOG) p(indent + ""call ""+i+"" finished."");
            }
        }
        
        abstract void block(int delayms) throws InterruptedException;
    }
    
    
    //======= blocking tasks variants ====================
    
    static class SyncWaitTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                this.wait(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class SyncSleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static class RLWaitTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                cond.await(delayms, TimeUnit.MILLISECONDS);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class RLSleepTask extends AbstractBlockingTask {
        ReentrantLock rl = new ReentrantLock();
        Condition cond = rl.newCondition();
        @Override
        void block(int delayms) throws InterruptedException {
            rl.lock();
            try {
                recorder.accept(tid(), taskId);
                Thread.sleep(delayms);
                recorder.accept(tid(), taskId);
            } finally {
                rl.unlock();
            }
        }
    }
    
    static class SleepTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            Thread.sleep(delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class NetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            recorder.accept(tid(), taskId);
            connectAndRead(PORT, delayms);
            recorder.accept(tid(), taskId);
        }
    }
    
    static class SyncNetTask extends AbstractBlockingTask {
        @Override
        void block(int delayms) throws InterruptedException {
            synchronized(this) {
                recorder.accept(tid(), taskId);
                connectAndRead(PORT, delayms);
                recorder.accept(tid(), taskId);
            }
        }
    }
    
    static Closeable startServer() throws IOException {
        ExecutorService exsvc = Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory());
        
        ServerSocket ss = new ServerSocket(PORT);
        Future<?> f = exsvc.submit(() -> {
            try {
                while(!Thread.interrupted() && !ss.isClosed()) {
                    Socket s = ss.accept();
                    exsvc.submit(() -> serviceOne(s));
                }
            } catch (IOException e) {
                //e.printStackTrace();
            }
        });
        
        return () -> {
            f.cancel(true);
            exsvc.shutdownNow();
            ss.close();
        };
    }
    
    static void serviceOne(Socket s) {
        try {
            try(s) {
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);
                int delayms = dis.readInt();
                
                OutputStream os = s.getOutputStream();
                Thread.sleep(delayms);
                os.write(42);
                os.flush();
                os.close();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    static void connectAndRead(int port, int delayms) {
        try (Socket s = new Socket(""localhost"", port)) {
            OutputStream os = s.getOutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(delayms);
            dos.flush();
            
            InputStream is = s.getInputStream();
            is.read();//should be delayed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}",            InputStream is = s.getInputStream();,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class JsonOutputStream extends OutputStream {
    private final ByteArrayOutputStream buffer = new ByteArrayOutputStream(4);
    private final Base64.Encoder encoder = Base64.getMimeEncoder();

    @Getter
    private int count = 0;

    @Override
    public void write(int b) throws IOException {
        buffer.write(b);
        if (buffer.size() % 4 == 0) { // Process in chunks of 4 Base64 characters
            flushBuffer();
        }
    }

    public void resetCount() {
        count = 0;
    }

    private void flushBuffer() {
        if (buffer.size() < 4) return; // Only decode full Base64 chunks
        byte[] encoded = encoder.encode(buffer.toByteArray());
        buffer.reset();
    }
}

public class ChunkReaderBasedJsonParser extends ReaderBasedJsonParser {
    private boolean finishedStringBuffer = false;

    public ChunkReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st, char[] inputBuffer, int start, int end, boolean bufferRecyclable) {
        super(ctxt, features, r, codec, st, inputBuffer, start, end, bufferRecyclable);
    }

    public ChunkReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) {
        super(ctxt, features, r, codec, st);
    }

    @Override
    public int getText(Writer writer) throws IOException {
        JsonToken t = _currToken;
        if (t == JsonToken.VALUE_STRING) {
            int total = 0;
            while (_tokenIncomplete) {
                _tokenIncomplete = getNextStringChunk();
                total += _textBuffer.contentsToWriter(writer);
                _textBuffer.resetWithEmpty();
            }
            return total;
        }
        if (t == JsonToken.FIELD_NAME) {
            String n = _parsingContext.getCurrentName();
            writer.write(n);
            return n.length();
        }
        if (t != null) {
            if (t.isNumeric()) {
                return _textBuffer.contentsToWriter(writer);
            }
            char[] ch = t.asCharArray();
            writer.write(ch);
            return ch.length;
        }
        return 0;
    }

    /**
     *
     * @return true if the token is still incomplete, false if it is complete
     */
    private boolean getNextStringChunk() throws IOException {
        finishedStringBuffer = false;
        _finishString();
        return finishedStringBuffer;
    }

    @Override
    protected void _finishString2() throws IOException {
        char[] outBuf = _textBuffer.getCurrentSegment();
        int outPtr = _textBuffer.getCurrentSegmentSize();
        final int[] codes = INPUT_CODES_LATIN1;
        final int maxCode = codes.length;

        while (true) {
            // we ran out of buffer?
            if (outPtr >= outBuf.length) {
                finishedStringBuffer = true;
                return;
            }

            if (_inputPtr >= _inputEnd) {
                if (!_loadMore()) {
                    _reportInvalidEOF("": was expecting closing quote for a string value"",
                            JsonToken.VALUE_STRING);
                }
            }
            char c = _inputBuffer[_inputPtr++];
            int i = c;
            if (i < maxCode && codes[i] != 0) {
                if (i == INT_QUOTE) {
                    break;
                } else if (i == INT_BACKSLASH) {
                    /* Although chars outside of BMP are to be escaped as
                     * an UTF-16 surrogate pair, does that affect decoding?
                     * For now let's assume it does not.
                     */
                    c = _decodeEscaped();
                } else if (i < INT_SPACE) {
                    _throwUnquotedSpace(i, ""string value"");
                } // anything else?
            }

            // Ok, let's add char to output:
            outBuf[outPtr++] = c;
        }
        _textBuffer.setCurrentLength(outPtr);
    }
}

public class JsonWriter extends Writer {

    @Getter
    @Setter
    private int count;

    @Setter
    private char letterToCount = 'a';

    @Override
    public void write(char[] cbuf, int off, int len) throws IOException {
        for (int i = off; i < off + len; i++) {
            if (cbuf[i] == letterToCount) {
                count++;
            }
        }
    }
}",        if (buffer.size() < 4) return; // Only decode full Base64 chunks,StackOverflow
AvoidCatchingThrowable,A catch statement should never catch throwable since it includes errors.,"public class Main {
    
    static final MethodHandle MH_LoadLibraryA;
    static final MethodHandle MH_FreeLibrary;
    static final MethodHandle MH_GetProcAddress;

    static {
        System.loadLibrary(""Kernel32"");
        SymbolLookup lookup = SymbolLookup.loaderLookup();
        CLinker linker = CLinker.systemCLinker();
        MH_LoadLibraryA = linker.downcallHandle(
            lookup.lookup(""LoadLibraryA"").orElseThrow(),
            FunctionDescriptor.of(ADDRESS, ADDRESS));
        MH_FreeLibrary = linker.downcallHandle(
            lookup.lookup(""FreeLibrary"").orElseThrow(),
            FunctionDescriptor.of(JAVA_INT, ADDRESS));
        MH_GetProcAddress = linker.downcallHandle(
            lookup.lookup(""GetProcAddress"").orElseThrow(),
            FunctionDescriptor.of(ADDRESS, ADDRESS, ADDRESS));
    }

    static MemoryAddress LoadLibraryA(String name) {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SegmentAllocator allocator = SegmentAllocator.nativeAllocator(scope);
            return (MemoryAddress) MH_LoadLibraryA.invokeExact((Addressable) allocator.allocateUtf8String(name));
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }

    static boolean FreeLibrary(MemoryAddress handle) {
        try {
            return ((int) MH_FreeLibrary.invokeExact((Addressable) handle)) != 0;
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }

    static MemoryAddress GetProcAddress(MemoryAddress handle, String name) {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SegmentAllocator allocator = SegmentAllocator.nativeAllocator(scope);
            return (MemoryAddress) MH_GetProcAddress.invokeExact((Addressable) handle, (Addressable) allocator.allocateUtf8String(name));
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }
    
    static SymbolLookup libraryLookup(String libraryName, ResourceScope scope) {
        MemoryAddress handle = LoadLibraryA(libraryName);
        if (handle == MemoryAddress.NULL) {
            throw new IllegalArgumentException(""Cannot find library: "" + libraryName);
        }
        scope.addCloseAction(() -> FreeLibrary(handle));
        return name -> {
            var addr = GetProcAddress(handle, name);
            return addr == MemoryAddress.NULL ?
                Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, scope));
        };
    }

    public static void main(String[] args) throws Throwable {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SymbolLookup lookup = libraryLookup(""gg"", scope);
            MethodHandle handle = CLinker.systemCLinker().downcallHandle(
                lookup.lookup(""get_gg"").orElseThrow(),
                FunctionDescriptor.of(JAVA_INT));
            int x = (int) handle.invoke();
            System.out.println(x);
        }
    }
}",        } catch (Throwable t) {,StackOverflow
AvoidCatchingThrowable,A catch statement should never catch throwable since it includes errors.,"public class Main {
    
    static final MethodHandle MH_LoadLibraryA;
    static final MethodHandle MH_FreeLibrary;
    static final MethodHandle MH_GetProcAddress;

    static {
        System.loadLibrary(""Kernel32"");
        SymbolLookup lookup = SymbolLookup.loaderLookup();
        CLinker linker = CLinker.systemCLinker();
        MH_LoadLibraryA = linker.downcallHandle(
            lookup.lookup(""LoadLibraryA"").orElseThrow(),
            FunctionDescriptor.of(ADDRESS, ADDRESS));
        MH_FreeLibrary = linker.downcallHandle(
            lookup.lookup(""FreeLibrary"").orElseThrow(),
            FunctionDescriptor.of(JAVA_INT, ADDRESS));
        MH_GetProcAddress = linker.downcallHandle(
            lookup.lookup(""GetProcAddress"").orElseThrow(),
            FunctionDescriptor.of(ADDRESS, ADDRESS, ADDRESS));
    }

    static MemoryAddress LoadLibraryA(String name) {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SegmentAllocator allocator = SegmentAllocator.nativeAllocator(scope);
            return (MemoryAddress) MH_LoadLibraryA.invokeExact((Addressable) allocator.allocateUtf8String(name));
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }

    static boolean FreeLibrary(MemoryAddress handle) {
        try {
            return ((int) MH_FreeLibrary.invokeExact((Addressable) handle)) != 0;
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }

    static MemoryAddress GetProcAddress(MemoryAddress handle, String name) {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SegmentAllocator allocator = SegmentAllocator.nativeAllocator(scope);
            return (MemoryAddress) MH_GetProcAddress.invokeExact((Addressable) handle, (Addressable) allocator.allocateUtf8String(name));
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }
    
    static SymbolLookup libraryLookup(String libraryName, ResourceScope scope) {
        MemoryAddress handle = LoadLibraryA(libraryName);
        if (handle == MemoryAddress.NULL) {
            throw new IllegalArgumentException(""Cannot find library: "" + libraryName);
        }
        scope.addCloseAction(() -> FreeLibrary(handle));
        return name -> {
            var addr = GetProcAddress(handle, name);
            return addr == MemoryAddress.NULL ?
                Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, scope));
        };
    }

    public static void main(String[] args) throws Throwable {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SymbolLookup lookup = libraryLookup(""gg"", scope);
            MethodHandle handle = CLinker.systemCLinker().downcallHandle(
                lookup.lookup(""get_gg"").orElseThrow(),
                FunctionDescriptor.of(JAVA_INT));
            int x = (int) handle.invoke();
            System.out.println(x);
        }
    }
}",        } catch (Throwable t) {,StackOverflow
AvoidCatchingThrowable,A catch statement should never catch throwable since it includes errors.,"public class Main {
    
    static final MethodHandle MH_LoadLibraryA;
    static final MethodHandle MH_FreeLibrary;
    static final MethodHandle MH_GetProcAddress;

    static {
        System.loadLibrary(""Kernel32"");
        SymbolLookup lookup = SymbolLookup.loaderLookup();
        CLinker linker = CLinker.systemCLinker();
        MH_LoadLibraryA = linker.downcallHandle(
            lookup.lookup(""LoadLibraryA"").orElseThrow(),
            FunctionDescriptor.of(ADDRESS, ADDRESS));
        MH_FreeLibrary = linker.downcallHandle(
            lookup.lookup(""FreeLibrary"").orElseThrow(),
            FunctionDescriptor.of(JAVA_INT, ADDRESS));
        MH_GetProcAddress = linker.downcallHandle(
            lookup.lookup(""GetProcAddress"").orElseThrow(),
            FunctionDescriptor.of(ADDRESS, ADDRESS, ADDRESS));
    }

    static MemoryAddress LoadLibraryA(String name) {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SegmentAllocator allocator = SegmentAllocator.nativeAllocator(scope);
            return (MemoryAddress) MH_LoadLibraryA.invokeExact((Addressable) allocator.allocateUtf8String(name));
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }

    static boolean FreeLibrary(MemoryAddress handle) {
        try {
            return ((int) MH_FreeLibrary.invokeExact((Addressable) handle)) != 0;
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }

    static MemoryAddress GetProcAddress(MemoryAddress handle, String name) {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SegmentAllocator allocator = SegmentAllocator.nativeAllocator(scope);
            return (MemoryAddress) MH_GetProcAddress.invokeExact((Addressable) handle, (Addressable) allocator.allocateUtf8String(name));
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }
    
    static SymbolLookup libraryLookup(String libraryName, ResourceScope scope) {
        MemoryAddress handle = LoadLibraryA(libraryName);
        if (handle == MemoryAddress.NULL) {
            throw new IllegalArgumentException(""Cannot find library: "" + libraryName);
        }
        scope.addCloseAction(() -> FreeLibrary(handle));
        return name -> {
            var addr = GetProcAddress(handle, name);
            return addr == MemoryAddress.NULL ?
                Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, scope));
        };
    }

    public static void main(String[] args) throws Throwable {
        try (ResourceScope scope = ResourceScope.newConfinedScope()) {
            SymbolLookup lookup = libraryLookup(""gg"", scope);
            MethodHandle handle = CLinker.systemCLinker().downcallHandle(
                lookup.lookup(""get_gg"").orElseThrow(),
                FunctionDescriptor.of(JAVA_INT));
            int x = (int) handle.invoke();
            System.out.println(x);
        }
    }
}",        } catch (Throwable t) {,StackOverflow
AvoidFieldNameMatchingMethodName,Field header has the same name as a method,"// Interface given by the library

interface Shape {
    double calculateArea();
    double calculatePerimeter();
}

// Triangle 

class Triangle implements Shape {

    private final double side1,side2,side3;

    public Triangle(double side1, double side2, double side3) {
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }

    @Override
    public double calculateArea() {
        // Heron's formula to calculate area of a triangle
        double s = (side1 + side2 + side3) / 2;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }

    @Override
    public double calculatePerimeter() {
        return side1 + side2 + side3;
    }
}

// Square

class Square implements Shape {
    
    private final double side;

    public Square(double side) {
        this.side = side;
    }

    @Override
    public double calculateArea() {
        return side * side;
    }

    @Override
    public double calculatePerimeter() {
        return 4 * side;
    }

    public void squareSpecificMethod(){
        // Does something specific for squares only
        System.out.println(""I AM A SQUARE"");
    }
}

// Circle

class Circle implements Shape {
    private final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}

// Something which can mangle a Shape in Shape-specific ways

interface ShapeMangler {

   String header();
   void mangle(Shape shape);

}

// Something which can mangle a Square

class SquareMangler implements ShapeMangler {

  public String header() { return ""square""; }

  public void mangle(Shape shape) {
     // This is the one and only cast.
     // If 'shape' is not a Square, this will raise an
     // exception, and rightly so.
     ((Square)shape).squareSpecificMethod(); 
  }

}

// Something which can mangle anything in a default way

class DefaultMangler implements ShapeMangler {

  private final String header;
  
  public DefaultMangler(String header) {
      this.header = header;
  }
  public String header() { return header; }
  public void mangle(Shape shape) { }

}

// Let's roll

class Main {

    // Do something very general which only depends on the
    // interface Shape and ShapeMangler and absolutely does not
    // subclass testing or type casting!

    public static void compute(Shape shape, ShapeMangler mangler) {
        // One should use logging instead.
        // Note that we use the mangler already to get the shape's
        // name.
        final String txt1 = mangler.header() + "" area: "" + shape.calculateArea();
        final String txt2 = mangler.header() + "" perimeter: "" + shape.calculatePerimeter();
        System.out.println(txt1);
        System.out.println(txt2);
        // do sth specific that cannot be expressed as a method 
        // of the Shape interface but about which the mangler
        // knows more!
        mangler.mangle(shape);
    }

    public static void main(String[] args) {
        compute(new Triangle(3, 4, 5),new DefaultMangler(""triangle""));
        compute(new Circle(3),new DefaultMangler(""circle""));
        compute(new Square(5),new SquareMangler());
    }
}",  private final String header;,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Stroke;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.Locale;
import javax.swing.JFrame;
import javax.swing.JPanel;
import org.jfree.chart.ChartColor;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYLineAnnotation;
import org.jfree.chart.axis.AxisLocation;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.SymbolAxis;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.chart.ui.HorizontalAlignment;
import org.jfree.chart.ui.Layer;
import org.jfree.chart.ui.RectangleEdge;

/**
 * @see https://stackoverflow.com/q/74592572/230513
 * @see https://github.com/jfree/jfreechart/discussions/327
 */
public class GitHub327 {
    
    public static void main(String[] args) {
        EventQueue.invokeLater(() -> {
            PlotWindow pw = new PlotWindow();
            pw.setLocationRelativeTo(null);
            pw.setVisible(true);
        });
    }
    
    private static class PlotWindow extends JFrame {
        
        final double t_init = 0;
        final double step = 0.1;
        final double t_fin = 10;
        int lengthValues;
        double[] yValues;
        double[] xValues;

        //params
        double Fmax = 5;
        double Tau = 3;
        double alpha = 3;
        double deltaX;
        
        public PlotWindow() {
            super(""Test JFreechart"");
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            this.setLocationRelativeTo(null);

            // x y values
            this.lengthValues = (int) ((this.t_fin - t_init) / this.step) + 1;
            this.setTimeValues();
            this.computeDeltaX();
            this.setForceValues();
            
            this.add(createChartPanel(), BorderLayout.CENTER);
            this.pack();
        }
        
        private void setTimeValues() {
            this.xValues = new double[this.lengthValues];
            for (int i = 0; i < this.lengthValues; ++i) {
                this.xValues[i] = this.t_init + i * this.step;
            }
        }
        
        private void computeDeltaX() {
            this.deltaX = Math.sqrt(-this.Tau * Math.log(this.alpha / (1 + this.alpha)));
        }
        
        private void setForceValues() {
            this.yValues = new double[lengthValues];
            for (int i = 0; i < lengthValues; ++i) {
                double A = this.Fmax * (1 + 1 / this.alpha);
                double B = 1 - Math.exp(-Math.pow(this.xValues[i] - this.deltaX, 2) / this.Tau);
                this.yValues[i] = A * B - this.Fmax / this.alpha;
            }
        }
        
        private XYSeriesCollection createDataset() {
            boolean autoSort = false;
            boolean allowDuplicateXValues = false;
            XYSeriesCollection dataset = new XYSeriesCollection();
            XYSeries series1 = new XYSeries("""", autoSort, allowDuplicateXValues);
            
            for (int i = 0; i < lengthValues; ++i) {
                series1.add(this.xValues[i], this.yValues[i]);
            }
            dataset.addSeries(series1);
            var series2 = new XYSeries(""S"");
            dataset.addSeries(series2);
            return dataset;
        }
        
        private JPanel createChartPanel() {
            String chartTitle = ""Wetting balance curve"";
            String xAxisLabel = ""X"";
            String yAxisLabel = ""Y"";
            XYSeriesCollection dataset = createDataset();
            JFreeChart chart = ChartFactory.createXYLineChart(chartTitle,
                xAxisLabel, yAxisLabel, dataset, PlotOrientation.VERTICAL, false, true, false);
            XYPlot plot = chart.getXYPlot();

            //title
            TextTitle tt = new TextTitle();
            tt.setText(""C:\\MENISCO ST60\\Mesures\\22-5912-100.PM1"");
            tt.setPaint(Color.BLUE);
            tt.setFont(new Font(""SansSerif"", Font.PLAIN, 12));
            tt.setPadding(8, 8, 8, 8);
            chart.setTitle(tt);

            // norm subtitle
            TextTitle normtt = new TextTitle(""Norme : J-STD-002E"");
            normtt.setFont(new Font(""SansSerif"", Font.BOLD, 12));
            normtt.setPosition(RectangleEdge.BOTTOM);
            normtt.setPaint(Color.BLACK);
            normtt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            normtt.setPadding(0, 16, 8, 0);
            chart.addSubtitle(normtt);

            // fmoy subtitle
            TextTitle fmoytt = new TextTitle(""Force moyenne Ã  0.900 S: 0.25mN"");
            fmoytt.setFont(new Font(""SansSerif"", Font.PLAIN, 10));
            fmoytt.setPosition(RectangleEdge.BOTTOM);
            fmoytt.setPaint(Color.BLUE);
            fmoytt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            fmoytt.setPadding(0, 16, 2, 0);
            chart.addSubtitle(fmoytt);

            // axis
            //domain axis
            plot.getDomainAxis().setLowerMargin(0.0);
            plot.getDomainAxis().setUpperMargin(0.0);
            NumberAxis domain = (NumberAxis) plot.getDomainAxis();
            NumberFormat formatterd = DecimalFormat.getInstance();
            formatterd.setMinimumFractionDigits(0);
            domain.setNumberFormatOverride(formatterd);
            domain.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
            domain.setTickMarksVisible(false);
            //domain.setAxisLineVisible(false);

            //range axis
            plot.getRangeAxis().setLabelAngle(Math.PI / 2);
            NumberAxis range = (NumberAxis) plot.getRangeAxis();
            NumberFormat formatter = DecimalFormat.getInstance(Locale.ENGLISH);
            formatter.setMinimumFractionDigits(2);
            range.setNumberFormatOverride(formatter);
            plot.getRangeAxis().setAxisLineStroke(new BasicStroke(1.5f));
            plot.getRangeAxis().setAxisLinePaint(Color.BLUE);
            plot.getRangeAxis().setTickMarksVisible(true);
            plot.getRangeAxis().setTickMarkPaint(Color.BLACK);
            plot.getRangeAxis().setTickMarkStroke(new BasicStroke(1.5f));
            float lg = plot.getRangeAxis().getTickMarkOutsideLength();
            plot.getRangeAxis().setTickMarkInsideLength(lg);
            plot.getRangeAxis().setRange(-3, 6);

            // background;gridline;outline 
            //plot.setAxisOffset(new RectangleInsets(0, 0, 0, 0));
            plot.setDomainGridlinePaint(Color.DARK_GRAY);
            plot.setRangeGridlinePaint(Color.DARK_GRAY);
            plot.setBackgroundPaint(Color.white);
            plot.setOutlineStroke(plot.getDomainGridlineStroke()); //dashed outline
            plot.setOutlinePaint(Color.DARK_GRAY);
            XYItemRenderer renderer = plot.getRenderer();
            renderer.setSeriesPaint(0, ChartColor.VERY_DARK_GREEN); // set green color to the xyline

            // vertical lines
            ValueMarker marker0 = new ValueMarker(0.2, Color.MAGENTA, new BasicStroke(1.5f));  // position is the value on the axis
            ValueMarker marker1 = new ValueMarker(1, Color.MAGENTA, new BasicStroke(1.5f));
            ValueMarker marker2 = new ValueMarker(4, Color.GREEN, new BasicStroke(1.5f));  // position is the value on the axis
            plot.addDomainMarker(marker0, Layer.FOREGROUND);
            plot.addDomainMarker(marker1, Layer.FOREGROUND);
            plot.addDomainMarker(marker2, Layer.FOREGROUND);
            
            var marker3 = new ValueMarker(10, Color.GREEN, new BasicStroke(1.5f));
            plot.addDomainMarker(marker3, Layer.FOREGROUND);

            //horizontal lines
            XYLineAnnotation line = new XYLineAnnotation(0, 4, 10, 4, new BasicStroke(2.0f), Color.green);
            plot.addAnnotation(line);
            XYLineAnnotation line0 = new XYLineAnnotation(0, 0, 10, 0, new BasicStroke(1.0f), Color.BLUE);
            plot.addAnnotation(line0);

            //dashed horizontal line
            float[] dash = {10.0f, 3.0f, 3.0f};
            Stroke dashed = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
            XYLineAnnotation line1 = new XYLineAnnotation(0, -1, 10, -1, dashed, Color.MAGENTA);
            plot.addAnnotation(line1);

            //right side axis
            String[] syms = new String[]{"""", """", """", ""t(s)"", """", """", """", ""4.0"", """", """"};
            var range2 = new SymbolAxis("""", syms);
            range2.setGridBandsVisible(false);
            plot.setRangeAxis(1, range2);
            plot.setRangeAxisLocation(1, AxisLocation.BOTTOM_OR_RIGHT);
            plot.mapDatasetToRangeAxis(1, 0);
            
            return new ChartPanel(chart) {
                @Override
                public Dimension getPreferredSize() {
                    return new Dimension(640, 480);
                }
            };
        }
    }
}",    private static class PlotWindow extends JFrame {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.setDefaultCloseOperation(int) ,"import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Stroke;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.Locale;
import javax.swing.JFrame;
import javax.swing.JPanel;
import org.jfree.chart.ChartColor;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYLineAnnotation;
import org.jfree.chart.axis.AxisLocation;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.SymbolAxis;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.chart.ui.HorizontalAlignment;
import org.jfree.chart.ui.Layer;
import org.jfree.chart.ui.RectangleEdge;

/**
 * @see https://stackoverflow.com/q/74592572/230513
 * @see https://github.com/jfree/jfreechart/discussions/327
 */
public class GitHub327 {
    
    public static void main(String[] args) {
        EventQueue.invokeLater(() -> {
            PlotWindow pw = new PlotWindow();
            pw.setLocationRelativeTo(null);
            pw.setVisible(true);
        });
    }
    
    private static class PlotWindow extends JFrame {
        
        final double t_init = 0;
        final double step = 0.1;
        final double t_fin = 10;
        int lengthValues;
        double[] yValues;
        double[] xValues;

        //params
        double Fmax = 5;
        double Tau = 3;
        double alpha = 3;
        double deltaX;
        
        public PlotWindow() {
            super(""Test JFreechart"");
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            this.setLocationRelativeTo(null);

            // x y values
            this.lengthValues = (int) ((this.t_fin - t_init) / this.step) + 1;
            this.setTimeValues();
            this.computeDeltaX();
            this.setForceValues();
            
            this.add(createChartPanel(), BorderLayout.CENTER);
            this.pack();
        }
        
        private void setTimeValues() {
            this.xValues = new double[this.lengthValues];
            for (int i = 0; i < this.lengthValues; ++i) {
                this.xValues[i] = this.t_init + i * this.step;
            }
        }
        
        private void computeDeltaX() {
            this.deltaX = Math.sqrt(-this.Tau * Math.log(this.alpha / (1 + this.alpha)));
        }
        
        private void setForceValues() {
            this.yValues = new double[lengthValues];
            for (int i = 0; i < lengthValues; ++i) {
                double A = this.Fmax * (1 + 1 / this.alpha);
                double B = 1 - Math.exp(-Math.pow(this.xValues[i] - this.deltaX, 2) / this.Tau);
                this.yValues[i] = A * B - this.Fmax / this.alpha;
            }
        }
        
        private XYSeriesCollection createDataset() {
            boolean autoSort = false;
            boolean allowDuplicateXValues = false;
            XYSeriesCollection dataset = new XYSeriesCollection();
            XYSeries series1 = new XYSeries("""", autoSort, allowDuplicateXValues);
            
            for (int i = 0; i < lengthValues; ++i) {
                series1.add(this.xValues[i], this.yValues[i]);
            }
            dataset.addSeries(series1);
            var series2 = new XYSeries(""S"");
            dataset.addSeries(series2);
            return dataset;
        }
        
        private JPanel createChartPanel() {
            String chartTitle = ""Wetting balance curve"";
            String xAxisLabel = ""X"";
            String yAxisLabel = ""Y"";
            XYSeriesCollection dataset = createDataset();
            JFreeChart chart = ChartFactory.createXYLineChart(chartTitle,
                xAxisLabel, yAxisLabel, dataset, PlotOrientation.VERTICAL, false, true, false);
            XYPlot plot = chart.getXYPlot();

            //title
            TextTitle tt = new TextTitle();
            tt.setText(""C:\\MENISCO ST60\\Mesures\\22-5912-100.PM1"");
            tt.setPaint(Color.BLUE);
            tt.setFont(new Font(""SansSerif"", Font.PLAIN, 12));
            tt.setPadding(8, 8, 8, 8);
            chart.setTitle(tt);

            // norm subtitle
            TextTitle normtt = new TextTitle(""Norme : J-STD-002E"");
            normtt.setFont(new Font(""SansSerif"", Font.BOLD, 12));
            normtt.setPosition(RectangleEdge.BOTTOM);
            normtt.setPaint(Color.BLACK);
            normtt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            normtt.setPadding(0, 16, 8, 0);
            chart.addSubtitle(normtt);

            // fmoy subtitle
            TextTitle fmoytt = new TextTitle(""Force moyenne Ã  0.900 S: 0.25mN"");
            fmoytt.setFont(new Font(""SansSerif"", Font.PLAIN, 10));
            fmoytt.setPosition(RectangleEdge.BOTTOM);
            fmoytt.setPaint(Color.BLUE);
            fmoytt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            fmoytt.setPadding(0, 16, 2, 0);
            chart.addSubtitle(fmoytt);

            // axis
            //domain axis
            plot.getDomainAxis().setLowerMargin(0.0);
            plot.getDomainAxis().setUpperMargin(0.0);
            NumberAxis domain = (NumberAxis) plot.getDomainAxis();
            NumberFormat formatterd = DecimalFormat.getInstance();
            formatterd.setMinimumFractionDigits(0);
            domain.setNumberFormatOverride(formatterd);
            domain.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
            domain.setTickMarksVisible(false);
            //domain.setAxisLineVisible(false);

            //range axis
            plot.getRangeAxis().setLabelAngle(Math.PI / 2);
            NumberAxis range = (NumberAxis) plot.getRangeAxis();
            NumberFormat formatter = DecimalFormat.getInstance(Locale.ENGLISH);
            formatter.setMinimumFractionDigits(2);
            range.setNumberFormatOverride(formatter);
            plot.getRangeAxis().setAxisLineStroke(new BasicStroke(1.5f));
            plot.getRangeAxis().setAxisLinePaint(Color.BLUE);
            plot.getRangeAxis().setTickMarksVisible(true);
            plot.getRangeAxis().setTickMarkPaint(Color.BLACK);
            plot.getRangeAxis().setTickMarkStroke(new BasicStroke(1.5f));
            float lg = plot.getRangeAxis().getTickMarkOutsideLength();
            plot.getRangeAxis().setTickMarkInsideLength(lg);
            plot.getRangeAxis().setRange(-3, 6);

            // background;gridline;outline 
            //plot.setAxisOffset(new RectangleInsets(0, 0, 0, 0));
            plot.setDomainGridlinePaint(Color.DARK_GRAY);
            plot.setRangeGridlinePaint(Color.DARK_GRAY);
            plot.setBackgroundPaint(Color.white);
            plot.setOutlineStroke(plot.getDomainGridlineStroke()); //dashed outline
            plot.setOutlinePaint(Color.DARK_GRAY);
            XYItemRenderer renderer = plot.getRenderer();
            renderer.setSeriesPaint(0, ChartColor.VERY_DARK_GREEN); // set green color to the xyline

            // vertical lines
            ValueMarker marker0 = new ValueMarker(0.2, Color.MAGENTA, new BasicStroke(1.5f));  // position is the value on the axis
            ValueMarker marker1 = new ValueMarker(1, Color.MAGENTA, new BasicStroke(1.5f));
            ValueMarker marker2 = new ValueMarker(4, Color.GREEN, new BasicStroke(1.5f));  // position is the value on the axis
            plot.addDomainMarker(marker0, Layer.FOREGROUND);
            plot.addDomainMarker(marker1, Layer.FOREGROUND);
            plot.addDomainMarker(marker2, Layer.FOREGROUND);
            
            var marker3 = new ValueMarker(10, Color.GREEN, new BasicStroke(1.5f));
            plot.addDomainMarker(marker3, Layer.FOREGROUND);

            //horizontal lines
            XYLineAnnotation line = new XYLineAnnotation(0, 4, 10, 4, new BasicStroke(2.0f), Color.green);
            plot.addAnnotation(line);
            XYLineAnnotation line0 = new XYLineAnnotation(0, 0, 10, 0, new BasicStroke(1.0f), Color.BLUE);
            plot.addAnnotation(line0);

            //dashed horizontal line
            float[] dash = {10.0f, 3.0f, 3.0f};
            Stroke dashed = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
            XYLineAnnotation line1 = new XYLineAnnotation(0, -1, 10, -1, dashed, Color.MAGENTA);
            plot.addAnnotation(line1);

            //right side axis
            String[] syms = new String[]{"""", """", """", ""t(s)"", """", """", """", ""4.0"", """", """"};
            var range2 = new SymbolAxis("""", syms);
            range2.setGridBandsVisible(false);
            plot.setRangeAxis(1, range2);
            plot.setRangeAxisLocation(1, AxisLocation.BOTTOM_OR_RIGHT);
            plot.mapDatasetToRangeAxis(1, 0);
            
            return new ChartPanel(chart) {
                @Override
                public Dimension getPreferredSize() {
                    return new Dimension(640, 480);
                }
            };
        }
    }
}",            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setLocationRelativeTo(Component) ,"import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Stroke;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.Locale;
import javax.swing.JFrame;
import javax.swing.JPanel;
import org.jfree.chart.ChartColor;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYLineAnnotation;
import org.jfree.chart.axis.AxisLocation;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.SymbolAxis;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.chart.ui.HorizontalAlignment;
import org.jfree.chart.ui.Layer;
import org.jfree.chart.ui.RectangleEdge;

/**
 * @see https://stackoverflow.com/q/74592572/230513
 * @see https://github.com/jfree/jfreechart/discussions/327
 */
public class GitHub327 {
    
    public static void main(String[] args) {
        EventQueue.invokeLater(() -> {
            PlotWindow pw = new PlotWindow();
            pw.setLocationRelativeTo(null);
            pw.setVisible(true);
        });
    }
    
    private static class PlotWindow extends JFrame {
        
        final double t_init = 0;
        final double step = 0.1;
        final double t_fin = 10;
        int lengthValues;
        double[] yValues;
        double[] xValues;

        //params
        double Fmax = 5;
        double Tau = 3;
        double alpha = 3;
        double deltaX;
        
        public PlotWindow() {
            super(""Test JFreechart"");
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            this.setLocationRelativeTo(null);

            // x y values
            this.lengthValues = (int) ((this.t_fin - t_init) / this.step) + 1;
            this.setTimeValues();
            this.computeDeltaX();
            this.setForceValues();
            
            this.add(createChartPanel(), BorderLayout.CENTER);
            this.pack();
        }
        
        private void setTimeValues() {
            this.xValues = new double[this.lengthValues];
            for (int i = 0; i < this.lengthValues; ++i) {
                this.xValues[i] = this.t_init + i * this.step;
            }
        }
        
        private void computeDeltaX() {
            this.deltaX = Math.sqrt(-this.Tau * Math.log(this.alpha / (1 + this.alpha)));
        }
        
        private void setForceValues() {
            this.yValues = new double[lengthValues];
            for (int i = 0; i < lengthValues; ++i) {
                double A = this.Fmax * (1 + 1 / this.alpha);
                double B = 1 - Math.exp(-Math.pow(this.xValues[i] - this.deltaX, 2) / this.Tau);
                this.yValues[i] = A * B - this.Fmax / this.alpha;
            }
        }
        
        private XYSeriesCollection createDataset() {
            boolean autoSort = false;
            boolean allowDuplicateXValues = false;
            XYSeriesCollection dataset = new XYSeriesCollection();
            XYSeries series1 = new XYSeries("""", autoSort, allowDuplicateXValues);
            
            for (int i = 0; i < lengthValues; ++i) {
                series1.add(this.xValues[i], this.yValues[i]);
            }
            dataset.addSeries(series1);
            var series2 = new XYSeries(""S"");
            dataset.addSeries(series2);
            return dataset;
        }
        
        private JPanel createChartPanel() {
            String chartTitle = ""Wetting balance curve"";
            String xAxisLabel = ""X"";
            String yAxisLabel = ""Y"";
            XYSeriesCollection dataset = createDataset();
            JFreeChart chart = ChartFactory.createXYLineChart(chartTitle,
                xAxisLabel, yAxisLabel, dataset, PlotOrientation.VERTICAL, false, true, false);
            XYPlot plot = chart.getXYPlot();

            //title
            TextTitle tt = new TextTitle();
            tt.setText(""C:\\MENISCO ST60\\Mesures\\22-5912-100.PM1"");
            tt.setPaint(Color.BLUE);
            tt.setFont(new Font(""SansSerif"", Font.PLAIN, 12));
            tt.setPadding(8, 8, 8, 8);
            chart.setTitle(tt);

            // norm subtitle
            TextTitle normtt = new TextTitle(""Norme : J-STD-002E"");
            normtt.setFont(new Font(""SansSerif"", Font.BOLD, 12));
            normtt.setPosition(RectangleEdge.BOTTOM);
            normtt.setPaint(Color.BLACK);
            normtt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            normtt.setPadding(0, 16, 8, 0);
            chart.addSubtitle(normtt);

            // fmoy subtitle
            TextTitle fmoytt = new TextTitle(""Force moyenne Ã  0.900 S: 0.25mN"");
            fmoytt.setFont(new Font(""SansSerif"", Font.PLAIN, 10));
            fmoytt.setPosition(RectangleEdge.BOTTOM);
            fmoytt.setPaint(Color.BLUE);
            fmoytt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            fmoytt.setPadding(0, 16, 2, 0);
            chart.addSubtitle(fmoytt);

            // axis
            //domain axis
            plot.getDomainAxis().setLowerMargin(0.0);
            plot.getDomainAxis().setUpperMargin(0.0);
            NumberAxis domain = (NumberAxis) plot.getDomainAxis();
            NumberFormat formatterd = DecimalFormat.getInstance();
            formatterd.setMinimumFractionDigits(0);
            domain.setNumberFormatOverride(formatterd);
            domain.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
            domain.setTickMarksVisible(false);
            //domain.setAxisLineVisible(false);

            //range axis
            plot.getRangeAxis().setLabelAngle(Math.PI / 2);
            NumberAxis range = (NumberAxis) plot.getRangeAxis();
            NumberFormat formatter = DecimalFormat.getInstance(Locale.ENGLISH);
            formatter.setMinimumFractionDigits(2);
            range.setNumberFormatOverride(formatter);
            plot.getRangeAxis().setAxisLineStroke(new BasicStroke(1.5f));
            plot.getRangeAxis().setAxisLinePaint(Color.BLUE);
            plot.getRangeAxis().setTickMarksVisible(true);
            plot.getRangeAxis().setTickMarkPaint(Color.BLACK);
            plot.getRangeAxis().setTickMarkStroke(new BasicStroke(1.5f));
            float lg = plot.getRangeAxis().getTickMarkOutsideLength();
            plot.getRangeAxis().setTickMarkInsideLength(lg);
            plot.getRangeAxis().setRange(-3, 6);

            // background;gridline;outline 
            //plot.setAxisOffset(new RectangleInsets(0, 0, 0, 0));
            plot.setDomainGridlinePaint(Color.DARK_GRAY);
            plot.setRangeGridlinePaint(Color.DARK_GRAY);
            plot.setBackgroundPaint(Color.white);
            plot.setOutlineStroke(plot.getDomainGridlineStroke()); //dashed outline
            plot.setOutlinePaint(Color.DARK_GRAY);
            XYItemRenderer renderer = plot.getRenderer();
            renderer.setSeriesPaint(0, ChartColor.VERY_DARK_GREEN); // set green color to the xyline

            // vertical lines
            ValueMarker marker0 = new ValueMarker(0.2, Color.MAGENTA, new BasicStroke(1.5f));  // position is the value on the axis
            ValueMarker marker1 = new ValueMarker(1, Color.MAGENTA, new BasicStroke(1.5f));
            ValueMarker marker2 = new ValueMarker(4, Color.GREEN, new BasicStroke(1.5f));  // position is the value on the axis
            plot.addDomainMarker(marker0, Layer.FOREGROUND);
            plot.addDomainMarker(marker1, Layer.FOREGROUND);
            plot.addDomainMarker(marker2, Layer.FOREGROUND);
            
            var marker3 = new ValueMarker(10, Color.GREEN, new BasicStroke(1.5f));
            plot.addDomainMarker(marker3, Layer.FOREGROUND);

            //horizontal lines
            XYLineAnnotation line = new XYLineAnnotation(0, 4, 10, 4, new BasicStroke(2.0f), Color.green);
            plot.addAnnotation(line);
            XYLineAnnotation line0 = new XYLineAnnotation(0, 0, 10, 0, new BasicStroke(1.0f), Color.BLUE);
            plot.addAnnotation(line0);

            //dashed horizontal line
            float[] dash = {10.0f, 3.0f, 3.0f};
            Stroke dashed = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
            XYLineAnnotation line1 = new XYLineAnnotation(0, -1, 10, -1, dashed, Color.MAGENTA);
            plot.addAnnotation(line1);

            //right side axis
            String[] syms = new String[]{"""", """", """", ""t(s)"", """", """", """", ""4.0"", """", """"};
            var range2 = new SymbolAxis("""", syms);
            range2.setGridBandsVisible(false);
            plot.setRangeAxis(1, range2);
            plot.setRangeAxisLocation(1, AxisLocation.BOTTOM_OR_RIGHT);
            plot.mapDatasetToRangeAxis(1, 0);
            
            return new ChartPanel(chart) {
                @Override
                public Dimension getPreferredSize() {
                    return new Dimension(640, 480);
                }
            };
        }
    }
}",            this.setLocationRelativeTo(null);,StackOverflow
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Stroke;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.Locale;
import javax.swing.JFrame;
import javax.swing.JPanel;
import org.jfree.chart.ChartColor;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYLineAnnotation;
import org.jfree.chart.axis.AxisLocation;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.SymbolAxis;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.chart.ui.HorizontalAlignment;
import org.jfree.chart.ui.Layer;
import org.jfree.chart.ui.RectangleEdge;

/**
 * @see https://stackoverflow.com/q/74592572/230513
 * @see https://github.com/jfree/jfreechart/discussions/327
 */
public class GitHub327 {
    
    public static void main(String[] args) {
        EventQueue.invokeLater(() -> {
            PlotWindow pw = new PlotWindow();
            pw.setLocationRelativeTo(null);
            pw.setVisible(true);
        });
    }
    
    private static class PlotWindow extends JFrame {
        
        final double t_init = 0;
        final double step = 0.1;
        final double t_fin = 10;
        int lengthValues;
        double[] yValues;
        double[] xValues;

        //params
        double Fmax = 5;
        double Tau = 3;
        double alpha = 3;
        double deltaX;
        
        public PlotWindow() {
            super(""Test JFreechart"");
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            this.setLocationRelativeTo(null);

            // x y values
            this.lengthValues = (int) ((this.t_fin - t_init) / this.step) + 1;
            this.setTimeValues();
            this.computeDeltaX();
            this.setForceValues();
            
            this.add(createChartPanel(), BorderLayout.CENTER);
            this.pack();
        }
        
        private void setTimeValues() {
            this.xValues = new double[this.lengthValues];
            for (int i = 0; i < this.lengthValues; ++i) {
                this.xValues[i] = this.t_init + i * this.step;
            }
        }
        
        private void computeDeltaX() {
            this.deltaX = Math.sqrt(-this.Tau * Math.log(this.alpha / (1 + this.alpha)));
        }
        
        private void setForceValues() {
            this.yValues = new double[lengthValues];
            for (int i = 0; i < lengthValues; ++i) {
                double A = this.Fmax * (1 + 1 / this.alpha);
                double B = 1 - Math.exp(-Math.pow(this.xValues[i] - this.deltaX, 2) / this.Tau);
                this.yValues[i] = A * B - this.Fmax / this.alpha;
            }
        }
        
        private XYSeriesCollection createDataset() {
            boolean autoSort = false;
            boolean allowDuplicateXValues = false;
            XYSeriesCollection dataset = new XYSeriesCollection();
            XYSeries series1 = new XYSeries("""", autoSort, allowDuplicateXValues);
            
            for (int i = 0; i < lengthValues; ++i) {
                series1.add(this.xValues[i], this.yValues[i]);
            }
            dataset.addSeries(series1);
            var series2 = new XYSeries(""S"");
            dataset.addSeries(series2);
            return dataset;
        }
        
        private JPanel createChartPanel() {
            String chartTitle = ""Wetting balance curve"";
            String xAxisLabel = ""X"";
            String yAxisLabel = ""Y"";
            XYSeriesCollection dataset = createDataset();
            JFreeChart chart = ChartFactory.createXYLineChart(chartTitle,
                xAxisLabel, yAxisLabel, dataset, PlotOrientation.VERTICAL, false, true, false);
            XYPlot plot = chart.getXYPlot();

            //title
            TextTitle tt = new TextTitle();
            tt.setText(""C:\\MENISCO ST60\\Mesures\\22-5912-100.PM1"");
            tt.setPaint(Color.BLUE);
            tt.setFont(new Font(""SansSerif"", Font.PLAIN, 12));
            tt.setPadding(8, 8, 8, 8);
            chart.setTitle(tt);

            // norm subtitle
            TextTitle normtt = new TextTitle(""Norme : J-STD-002E"");
            normtt.setFont(new Font(""SansSerif"", Font.BOLD, 12));
            normtt.setPosition(RectangleEdge.BOTTOM);
            normtt.setPaint(Color.BLACK);
            normtt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            normtt.setPadding(0, 16, 8, 0);
            chart.addSubtitle(normtt);

            // fmoy subtitle
            TextTitle fmoytt = new TextTitle(""Force moyenne Ã  0.900 S: 0.25mN"");
            fmoytt.setFont(new Font(""SansSerif"", Font.PLAIN, 10));
            fmoytt.setPosition(RectangleEdge.BOTTOM);
            fmoytt.setPaint(Color.BLUE);
            fmoytt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            fmoytt.setPadding(0, 16, 2, 0);
            chart.addSubtitle(fmoytt);

            // axis
            //domain axis
            plot.getDomainAxis().setLowerMargin(0.0);
            plot.getDomainAxis().setUpperMargin(0.0);
            NumberAxis domain = (NumberAxis) plot.getDomainAxis();
            NumberFormat formatterd = DecimalFormat.getInstance();
            formatterd.setMinimumFractionDigits(0);
            domain.setNumberFormatOverride(formatterd);
            domain.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
            domain.setTickMarksVisible(false);
            //domain.setAxisLineVisible(false);

            //range axis
            plot.getRangeAxis().setLabelAngle(Math.PI / 2);
            NumberAxis range = (NumberAxis) plot.getRangeAxis();
            NumberFormat formatter = DecimalFormat.getInstance(Locale.ENGLISH);
            formatter.setMinimumFractionDigits(2);
            range.setNumberFormatOverride(formatter);
            plot.getRangeAxis().setAxisLineStroke(new BasicStroke(1.5f));
            plot.getRangeAxis().setAxisLinePaint(Color.BLUE);
            plot.getRangeAxis().setTickMarksVisible(true);
            plot.getRangeAxis().setTickMarkPaint(Color.BLACK);
            plot.getRangeAxis().setTickMarkStroke(new BasicStroke(1.5f));
            float lg = plot.getRangeAxis().getTickMarkOutsideLength();
            plot.getRangeAxis().setTickMarkInsideLength(lg);
            plot.getRangeAxis().setRange(-3, 6);

            // background;gridline;outline 
            //plot.setAxisOffset(new RectangleInsets(0, 0, 0, 0));
            plot.setDomainGridlinePaint(Color.DARK_GRAY);
            plot.setRangeGridlinePaint(Color.DARK_GRAY);
            plot.setBackgroundPaint(Color.white);
            plot.setOutlineStroke(plot.getDomainGridlineStroke()); //dashed outline
            plot.setOutlinePaint(Color.DARK_GRAY);
            XYItemRenderer renderer = plot.getRenderer();
            renderer.setSeriesPaint(0, ChartColor.VERY_DARK_GREEN); // set green color to the xyline

            // vertical lines
            ValueMarker marker0 = new ValueMarker(0.2, Color.MAGENTA, new BasicStroke(1.5f));  // position is the value on the axis
            ValueMarker marker1 = new ValueMarker(1, Color.MAGENTA, new BasicStroke(1.5f));
            ValueMarker marker2 = new ValueMarker(4, Color.GREEN, new BasicStroke(1.5f));  // position is the value on the axis
            plot.addDomainMarker(marker0, Layer.FOREGROUND);
            plot.addDomainMarker(marker1, Layer.FOREGROUND);
            plot.addDomainMarker(marker2, Layer.FOREGROUND);
            
            var marker3 = new ValueMarker(10, Color.GREEN, new BasicStroke(1.5f));
            plot.addDomainMarker(marker3, Layer.FOREGROUND);

            //horizontal lines
            XYLineAnnotation line = new XYLineAnnotation(0, 4, 10, 4, new BasicStroke(2.0f), Color.green);
            plot.addAnnotation(line);
            XYLineAnnotation line0 = new XYLineAnnotation(0, 0, 10, 0, new BasicStroke(1.0f), Color.BLUE);
            plot.addAnnotation(line0);

            //dashed horizontal line
            float[] dash = {10.0f, 3.0f, 3.0f};
            Stroke dashed = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
            XYLineAnnotation line1 = new XYLineAnnotation(0, -1, 10, -1, dashed, Color.MAGENTA);
            plot.addAnnotation(line1);

            //right side axis
            String[] syms = new String[]{"""", """", """", ""t(s)"", """", """", """", ""4.0"", """", """"};
            var range2 = new SymbolAxis("""", syms);
            range2.setGridBandsVisible(false);
            plot.setRangeAxis(1, range2);
            plot.setRangeAxisLocation(1, AxisLocation.BOTTOM_OR_RIGHT);
            plot.mapDatasetToRangeAxis(1, 0);
            
            return new ChartPanel(chart) {
                @Override
                public Dimension getPreferredSize() {
                    return new Dimension(640, 480);
                }
            };
        }
    }
}","            this.add(createChartPanel(), BorderLayout.CENTER);",StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.pack() ,"import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Stroke;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.Locale;
import javax.swing.JFrame;
import javax.swing.JPanel;
import org.jfree.chart.ChartColor;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYLineAnnotation;
import org.jfree.chart.axis.AxisLocation;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.SymbolAxis;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.chart.ui.HorizontalAlignment;
import org.jfree.chart.ui.Layer;
import org.jfree.chart.ui.RectangleEdge;

/**
 * @see https://stackoverflow.com/q/74592572/230513
 * @see https://github.com/jfree/jfreechart/discussions/327
 */
public class GitHub327 {
    
    public static void main(String[] args) {
        EventQueue.invokeLater(() -> {
            PlotWindow pw = new PlotWindow();
            pw.setLocationRelativeTo(null);
            pw.setVisible(true);
        });
    }
    
    private static class PlotWindow extends JFrame {
        
        final double t_init = 0;
        final double step = 0.1;
        final double t_fin = 10;
        int lengthValues;
        double[] yValues;
        double[] xValues;

        //params
        double Fmax = 5;
        double Tau = 3;
        double alpha = 3;
        double deltaX;
        
        public PlotWindow() {
            super(""Test JFreechart"");
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            this.setLocationRelativeTo(null);

            // x y values
            this.lengthValues = (int) ((this.t_fin - t_init) / this.step) + 1;
            this.setTimeValues();
            this.computeDeltaX();
            this.setForceValues();
            
            this.add(createChartPanel(), BorderLayout.CENTER);
            this.pack();
        }
        
        private void setTimeValues() {
            this.xValues = new double[this.lengthValues];
            for (int i = 0; i < this.lengthValues; ++i) {
                this.xValues[i] = this.t_init + i * this.step;
            }
        }
        
        private void computeDeltaX() {
            this.deltaX = Math.sqrt(-this.Tau * Math.log(this.alpha / (1 + this.alpha)));
        }
        
        private void setForceValues() {
            this.yValues = new double[lengthValues];
            for (int i = 0; i < lengthValues; ++i) {
                double A = this.Fmax * (1 + 1 / this.alpha);
                double B = 1 - Math.exp(-Math.pow(this.xValues[i] - this.deltaX, 2) / this.Tau);
                this.yValues[i] = A * B - this.Fmax / this.alpha;
            }
        }
        
        private XYSeriesCollection createDataset() {
            boolean autoSort = false;
            boolean allowDuplicateXValues = false;
            XYSeriesCollection dataset = new XYSeriesCollection();
            XYSeries series1 = new XYSeries("""", autoSort, allowDuplicateXValues);
            
            for (int i = 0; i < lengthValues; ++i) {
                series1.add(this.xValues[i], this.yValues[i]);
            }
            dataset.addSeries(series1);
            var series2 = new XYSeries(""S"");
            dataset.addSeries(series2);
            return dataset;
        }
        
        private JPanel createChartPanel() {
            String chartTitle = ""Wetting balance curve"";
            String xAxisLabel = ""X"";
            String yAxisLabel = ""Y"";
            XYSeriesCollection dataset = createDataset();
            JFreeChart chart = ChartFactory.createXYLineChart(chartTitle,
                xAxisLabel, yAxisLabel, dataset, PlotOrientation.VERTICAL, false, true, false);
            XYPlot plot = chart.getXYPlot();

            //title
            TextTitle tt = new TextTitle();
            tt.setText(""C:\\MENISCO ST60\\Mesures\\22-5912-100.PM1"");
            tt.setPaint(Color.BLUE);
            tt.setFont(new Font(""SansSerif"", Font.PLAIN, 12));
            tt.setPadding(8, 8, 8, 8);
            chart.setTitle(tt);

            // norm subtitle
            TextTitle normtt = new TextTitle(""Norme : J-STD-002E"");
            normtt.setFont(new Font(""SansSerif"", Font.BOLD, 12));
            normtt.setPosition(RectangleEdge.BOTTOM);
            normtt.setPaint(Color.BLACK);
            normtt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            normtt.setPadding(0, 16, 8, 0);
            chart.addSubtitle(normtt);

            // fmoy subtitle
            TextTitle fmoytt = new TextTitle(""Force moyenne Ã  0.900 S: 0.25mN"");
            fmoytt.setFont(new Font(""SansSerif"", Font.PLAIN, 10));
            fmoytt.setPosition(RectangleEdge.BOTTOM);
            fmoytt.setPaint(Color.BLUE);
            fmoytt.setHorizontalAlignment(HorizontalAlignment.LEFT);
            fmoytt.setPadding(0, 16, 2, 0);
            chart.addSubtitle(fmoytt);

            // axis
            //domain axis
            plot.getDomainAxis().setLowerMargin(0.0);
            plot.getDomainAxis().setUpperMargin(0.0);
            NumberAxis domain = (NumberAxis) plot.getDomainAxis();
            NumberFormat formatterd = DecimalFormat.getInstance();
            formatterd.setMinimumFractionDigits(0);
            domain.setNumberFormatOverride(formatterd);
            domain.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
            domain.setTickMarksVisible(false);
            //domain.setAxisLineVisible(false);

            //range axis
            plot.getRangeAxis().setLabelAngle(Math.PI / 2);
            NumberAxis range = (NumberAxis) plot.getRangeAxis();
            NumberFormat formatter = DecimalFormat.getInstance(Locale.ENGLISH);
            formatter.setMinimumFractionDigits(2);
            range.setNumberFormatOverride(formatter);
            plot.getRangeAxis().setAxisLineStroke(new BasicStroke(1.5f));
            plot.getRangeAxis().setAxisLinePaint(Color.BLUE);
            plot.getRangeAxis().setTickMarksVisible(true);
            plot.getRangeAxis().setTickMarkPaint(Color.BLACK);
            plot.getRangeAxis().setTickMarkStroke(new BasicStroke(1.5f));
            float lg = plot.getRangeAxis().getTickMarkOutsideLength();
            plot.getRangeAxis().setTickMarkInsideLength(lg);
            plot.getRangeAxis().setRange(-3, 6);

            // background;gridline;outline 
            //plot.setAxisOffset(new RectangleInsets(0, 0, 0, 0));
            plot.setDomainGridlinePaint(Color.DARK_GRAY);
            plot.setRangeGridlinePaint(Color.DARK_GRAY);
            plot.setBackgroundPaint(Color.white);
            plot.setOutlineStroke(plot.getDomainGridlineStroke()); //dashed outline
            plot.setOutlinePaint(Color.DARK_GRAY);
            XYItemRenderer renderer = plot.getRenderer();
            renderer.setSeriesPaint(0, ChartColor.VERY_DARK_GREEN); // set green color to the xyline

            // vertical lines
            ValueMarker marker0 = new ValueMarker(0.2, Color.MAGENTA, new BasicStroke(1.5f));  // position is the value on the axis
            ValueMarker marker1 = new ValueMarker(1, Color.MAGENTA, new BasicStroke(1.5f));
            ValueMarker marker2 = new ValueMarker(4, Color.GREEN, new BasicStroke(1.5f));  // position is the value on the axis
            plot.addDomainMarker(marker0, Layer.FOREGROUND);
            plot.addDomainMarker(marker1, Layer.FOREGROUND);
            plot.addDomainMarker(marker2, Layer.FOREGROUND);
            
            var marker3 = new ValueMarker(10, Color.GREEN, new BasicStroke(1.5f));
            plot.addDomainMarker(marker3, Layer.FOREGROUND);

            //horizontal lines
            XYLineAnnotation line = new XYLineAnnotation(0, 4, 10, 4, new BasicStroke(2.0f), Color.green);
            plot.addAnnotation(line);
            XYLineAnnotation line0 = new XYLineAnnotation(0, 0, 10, 0, new BasicStroke(1.0f), Color.BLUE);
            plot.addAnnotation(line0);

            //dashed horizontal line
            float[] dash = {10.0f, 3.0f, 3.0f};
            Stroke dashed = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
            XYLineAnnotation line1 = new XYLineAnnotation(0, -1, 10, -1, dashed, Color.MAGENTA);
            plot.addAnnotation(line1);

            //right side axis
            String[] syms = new String[]{"""", """", """", ""t(s)"", """", """", """", ""4.0"", """", """"};
            var range2 = new SymbolAxis("""", syms);
            range2.setGridBandsVisible(false);
            plot.setRangeAxis(1, range2);
            plot.setRangeAxisLocation(1, AxisLocation.BOTTOM_OR_RIGHT);
            plot.mapDatasetToRangeAxis(1, 0);
            
            return new ChartPanel(chart) {
                @Override
                public Dimension getPreferredSize() {
                    return new Dimension(640, 480);
                }
            };
        }
    }
}",            this.pack();,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Base.Base() ,"class Base {
    int id = 1000;

    Base() {
        System.out.println(""Base constructor called"");
        Base();
    }

    void Base() {
        System.out.println(""Base called"");
        System.out.println(++this.id);
    }
}

class Derived extends Base {
    int id = 2000;

    Derived() {
        System.out.println(""==Super finished=="");
        Base();
    }

    void Base() {
        System.out.println(""Derived base called"");
        System.out.println(--this.id);
    }
}

public class Test {
    public static void main(String[] args) {
        new Derived();
    }
}

public class test {
    public static void main(String[] args) {
        new Base();
    }
}",        Base();,StackOverflow
MethodWithSameNameAsEnclosingClass,A method should not have the same name as its containing class,"class Base {
    int id = 1000;

    Base() {
        System.out.println(""Base constructor called"");
        Base();
    }

    void Base() {
        System.out.println(""Base called"");
        System.out.println(++this.id);
    }
}

class Derived extends Base {
    int id = 2000;

    Derived() {
        System.out.println(""==Super finished=="");
        Base();
    }

    void Base() {
        System.out.println(""Derived base called"");
        System.out.println(--this.id);
    }
}

public class Test {
    public static void main(String[] args) {
        new Derived();
    }
}

public class test {
    public static void main(String[] args) {
        new Base();
    }
}",    void Base() {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Derived.Base() ,"class Base {
    int id = 1000;

    Base() {
        System.out.println(""Base constructor called"");
        Base();
    }

    void Base() {
        System.out.println(""Base called"");
        System.out.println(++this.id);
    }
}

class Derived extends Base {
    int id = 2000;

    Derived() {
        System.out.println(""==Super finished=="");
        Base();
    }

    void Base() {
        System.out.println(""Derived base called"");
        System.out.println(--this.id);
    }
}

public class Test {
    public static void main(String[] args) {
        new Derived();
    }
}

public class test {
    public static void main(String[] args) {
        new Base();
    }
}",        Base();,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","class Base {
    int id = 1000;

    Base() {
        System.out.println(""Base constructor called"");
        Base();
    }

    void Base() {
        System.out.println(""Base called"");
        System.out.println(++this.id);
    }
}

class Derived extends Base {
    int id = 2000;

    Derived() {
        System.out.println(""==Super finished=="");
        Base();
    }

    void Base() {
        System.out.println(""Derived base called"");
        System.out.println(--this.id);
    }
}

public class Test {
    public static void main(String[] args) {
        new Derived();
    }
}

public class test {
    public static void main(String[] args) {
        new Base();
    }
}",public class Test {,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.*;
    
    class HelloWorld {
        public static void main(String[] args) {
            boolean excep = false;
            try {
                Scanner sc = new Scanner(System.in);
                int n = sc.nextInt();
            }
            catch(Exception e) {
                System.out.println(e);
                excep = true;
            }
            finally{
               if(!excep){
                  System.out.println(""no exceptions"");
               }
            }
        }
    }",                Scanner sc = new Scanner(System.in);,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

public class SOQ_20220514
{

   public static class Student {
      private String lName;
      private int idNumber;
      private int age;
   
      public Student() {
         lName = """";
         idNumber = 0;
         age = 0;
      }
      public Student(String l, int i, int a) {
         lName = l;
         idNumber = i;
         age = a;
      }
   
      public void setName(String last) {
         lName = last;
      }
   
      public String getName() {
         return lName;
      }
   
      public void setIdNum(int num) {
         idNumber = num;
      }
   
      public int getIdNum() {
         return idNumber;
      }
   
      public void setAge(int a) {
         age = a;
      }
   
      public int getAge() {
         return age;
      }
   }

   public static void main(String[] args) throws IOException {
      String file = ""studentData.txt"";
      Scanner reader = new Scanner(file);
   
      ArrayList<Student> users = readFile(file);
      Student s = new Student();
      users.add(s);
   
   
      Scanner input = new Scanner(System.in);
    //user enters idNumber to display age
      System.out.println(""Enter ID Number""); //exception handling to be added
      int idNum = input.nextInt();
   
   //this part is where I'm stuck 
      for(int i = 0; i < users.size(); i++){
         if(idNum == users.get(i).getIdNum()){
            final Student temp = users.get(i);
            System.out.println(""Student with an ID of "" + temp.getIdNum() + "" has an age of "" + temp.getAge());
         }
      }
   
   }
//METHOD FOR READING FILE
   public static ArrayList<Student> readFile(String file)throws IOException{
      Scanner reader = new Scanner(new File(file));
   
      ArrayList<Student> list = new ArrayList<Student>();//creates ArrayList with student object
   
      reader.nextLine();//skips first line
      while(reader.hasNext()){//splits all text in the file into words
         String lName = reader.next();
         int idNum = reader.nextInt();
         int age = reader.nextInt();
      
         Student users = new Student(lName ,idNum, age); 
         list.add(users);
      }
    
      return list;
   
   }//end method

}",      Scanner reader = new Scanner(file);,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

public class SOQ_20220514
{

   public static class Student {
      private String lName;
      private int idNumber;
      private int age;
   
      public Student() {
         lName = """";
         idNumber = 0;
         age = 0;
      }
      public Student(String l, int i, int a) {
         lName = l;
         idNumber = i;
         age = a;
      }
   
      public void setName(String last) {
         lName = last;
      }
   
      public String getName() {
         return lName;
      }
   
      public void setIdNum(int num) {
         idNumber = num;
      }
   
      public int getIdNum() {
         return idNumber;
      }
   
      public void setAge(int a) {
         age = a;
      }
   
      public int getAge() {
         return age;
      }
   }

   public static void main(String[] args) throws IOException {
      String file = ""studentData.txt"";
      Scanner reader = new Scanner(file);
   
      ArrayList<Student> users = readFile(file);
      Student s = new Student();
      users.add(s);
   
   
      Scanner input = new Scanner(System.in);
    //user enters idNumber to display age
      System.out.println(""Enter ID Number""); //exception handling to be added
      int idNum = input.nextInt();
   
   //this part is where I'm stuck 
      for(int i = 0; i < users.size(); i++){
         if(idNum == users.get(i).getIdNum()){
            final Student temp = users.get(i);
            System.out.println(""Student with an ID of "" + temp.getIdNum() + "" has an age of "" + temp.getAge());
         }
      }
   
   }
//METHOD FOR READING FILE
   public static ArrayList<Student> readFile(String file)throws IOException{
      Scanner reader = new Scanner(new File(file));
   
      ArrayList<Student> list = new ArrayList<Student>();//creates ArrayList with student object
   
      reader.nextLine();//skips first line
      while(reader.hasNext()){//splits all text in the file into words
         String lName = reader.next();
         int idNum = reader.nextInt();
         int age = reader.nextInt();
      
         Student users = new Student(lName ,idNum, age); 
         list.add(users);
      }
    
      return list;
   
   }//end method

}",      Scanner input = new Scanner(System.in);,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

public class SOQ_20220514
{

   public static class Student {
      private String lName;
      private int idNumber;
      private int age;
   
      public Student() {
         lName = """";
         idNumber = 0;
         age = 0;
      }
      public Student(String l, int i, int a) {
         lName = l;
         idNumber = i;
         age = a;
      }
   
      public void setName(String last) {
         lName = last;
      }
   
      public String getName() {
         return lName;
      }
   
      public void setIdNum(int num) {
         idNumber = num;
      }
   
      public int getIdNum() {
         return idNumber;
      }
   
      public void setAge(int a) {
         age = a;
      }
   
      public int getAge() {
         return age;
      }
   }

   public static void main(String[] args) throws IOException {
      String file = ""studentData.txt"";
      Scanner reader = new Scanner(file);
   
      ArrayList<Student> users = readFile(file);
      Student s = new Student();
      users.add(s);
   
   
      Scanner input = new Scanner(System.in);
    //user enters idNumber to display age
      System.out.println(""Enter ID Number""); //exception handling to be added
      int idNum = input.nextInt();
   
   //this part is where I'm stuck 
      for(int i = 0; i < users.size(); i++){
         if(idNum == users.get(i).getIdNum()){
            final Student temp = users.get(i);
            System.out.println(""Student with an ID of "" + temp.getIdNum() + "" has an age of "" + temp.getAge());
         }
      }
   
   }
//METHOD FOR READING FILE
   public static ArrayList<Student> readFile(String file)throws IOException{
      Scanner reader = new Scanner(new File(file));
   
      ArrayList<Student> list = new ArrayList<Student>();//creates ArrayList with student object
   
      reader.nextLine();//skips first line
      while(reader.hasNext()){//splits all text in the file into words
         String lName = reader.next();
         int idNum = reader.nextInt();
         int age = reader.nextInt();
      
         Student users = new Student(lName ,idNum, age); 
         list.add(users);
      }
    
      return list;
   
   }//end method

}",      Scanner reader = new Scanner(new File(file));,StackOverflow
AvoidCatchingThrowable,A catch statement should never catch throwable since it includes errors.,"import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;

public class Windows1252Tester {
    public static void main(String[] args) {
        try {
            // Can we encode the incoming UTF-8 (per OP) as Windows-1252?
            Charset cs = Charset.forName(""Windows-1252"");
            CharsetEncoder enc = cs.newEncoder();
            System.out.printf(""Can charset %s encode sequence %s? %b%n"", cs, args[0], enc.canEncode(args[0]));
        }
        catch(Throwable t) {
            t.printStackTrace();
        }
    }
}",        catch(Throwable t) {,StackOverflow
TestClassWithoutTestCases,"The class 'ScrollTest' might be a test class, but it contains no test cases.","import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

/** @see https://stackoverflow.com/q/72485336/230513 */
public class ScrollTest extends Application {

    private static final double W = 640;
    private static final double H = 480;

    @Override
    public void start(Stage stage) {
        Pane content = new StackPane();
        content.getChildren().addAll(new Rectangle(W, H, Color.BLUE),
            new Circle(Math.min(W, H) / 2, Color.LIGHTBLUE));
        ScrollPane scrollPane = new ScrollPane(content);
        scrollPane.setPrefViewportWidth(2 * W / 3);
        scrollPane.setPrefViewportHeight(2 * H / 3);
        content.setOnScroll(event -> System.out.println(
            ""dx dy: "" + event.getDeltaX() + "" "" + event.getDeltaY()));
        stage.setScene(new Scene(scrollPane));
        stage.show();
    }

    public static void main(String[] args) {
        System.out.println(System.getProperty(""os.name"")
            + "" v"" + System.getProperty(""os.version"")
            + ""; Java v"" + System.getProperty(""java.version"")
            + ""; JavaFX v"" + System.getProperty(""javafx.runtime.version""));
        launch(args);
    }
}",public class ScrollTest extends Application {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.Path2D;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame(""Test"");
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    protected class TestPane extends JPanel {

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(300, 300);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            g2d.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
            g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
            g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);

            g2d.setColor(Color.RED);
            RoundedShape shape = new RoundedShape(
                    20,
                    100, 200,
                    RoundedShape.Corner.TOP_LEFT,
                    RoundedShape.Corner.TOP_RIGHT,
                    RoundedShape.Corner.BOTTOM_RIGHT,
                    RoundedShape.Corner.BOTTOM_LEFT
            );
            g2d.translate(10, 10);
            g2d.draw(shape);

            g2d.dispose();
        }
    }

    public class RoundedShape extends Path2D.Double {

        enum Corner {
            TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT;
        }

        private double radius = 20;
        private Set<Corner> corners;
        private Dimension size;

        public RoundedShape(double radius, int width, int height, Corner... corners) {
            this.corners = new HashSet(Arrays.asList(corners));
            this.radius = radius;
            this.size = new Dimension(width, height);

            build();
        }

        protected void build() {
            moveTo(0, 0);
            if (corners.contains(Corner.TOP_LEFT)) {
                moveTo(0, radius);
                curveTo(0, radius, 0, 0, radius, 0);
            }
            if (corners.contains(Corner.TOP_RIGHT)) {
                lineTo(size.width - radius, 0);
                // Draw the curve here
                curveTo(size.width - radius, 0,
                        size.width, 0,
                        size.width, radius);
            } else {
                lineTo(size.width, 0);
            }
            if (corners.contains(Corner.BOTTOM_RIGHT)) {
                lineTo(size.width, size.height - radius);
                // Draw the curve here
                curveTo(size.width, size.height - radius,
                        size.width, size.height,
                        size.width - radius, size.height);
            } else {
                lineTo(size.width, size.height);
            }
            if (corners.contains(Corner.BOTTOM_LEFT)) {
                lineTo(radius, size.height);
                // Draw the curve here
                curveTo(radius, size.height,
                        0, size.height,
                        0, size.height - radius);
            } else {
                lineTo(0, size.height);
            }
            closePath();
        }
    }
}",    protected class TestPane extends JPanel {,StackOverflow
TestClassWithoutTestCases,"The class 'TestPane' might be a test class, but it contains no test cases.","import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.Path2D;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame(""Test"");
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    protected class TestPane extends JPanel {

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(300, 300);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            g2d.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
            g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
            g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);

            g2d.setColor(Color.RED);
            RoundedShape shape = new RoundedShape(
                    20,
                    100, 200,
                    RoundedShape.Corner.TOP_LEFT,
                    RoundedShape.Corner.TOP_RIGHT,
                    RoundedShape.Corner.BOTTOM_RIGHT,
                    RoundedShape.Corner.BOTTOM_LEFT
            );
            g2d.translate(10, 10);
            g2d.draw(shape);

            g2d.dispose();
        }
    }

    public class RoundedShape extends Path2D.Double {

        enum Corner {
            TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT;
        }

        private double radius = 20;
        private Set<Corner> corners;
        private Dimension size;

        public RoundedShape(double radius, int width, int height, Corner... corners) {
            this.corners = new HashSet(Arrays.asList(corners));
            this.radius = radius;
            this.size = new Dimension(width, height);

            build();
        }

        protected void build() {
            moveTo(0, 0);
            if (corners.contains(Corner.TOP_LEFT)) {
                moveTo(0, radius);
                curveTo(0, radius, 0, 0, radius, 0);
            }
            if (corners.contains(Corner.TOP_RIGHT)) {
                lineTo(size.width - radius, 0);
                // Draw the curve here
                curveTo(size.width - radius, 0,
                        size.width, 0,
                        size.width, radius);
            } else {
                lineTo(size.width, 0);
            }
            if (corners.contains(Corner.BOTTOM_RIGHT)) {
                lineTo(size.width, size.height - radius);
                // Draw the curve here
                curveTo(size.width, size.height - radius,
                        size.width, size.height,
                        size.width - radius, size.height);
            } else {
                lineTo(size.width, size.height);
            }
            if (corners.contains(Corner.BOTTOM_LEFT)) {
                lineTo(radius, size.height);
                // Draw the curve here
                curveTo(radius, size.height,
                        0, size.height,
                        0, size.height - radius);
            } else {
                lineTo(0, size.height);
            }
            closePath();
        }
    }
}",    protected class TestPane extends JPanel {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.Path2D;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame(""Test"");
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    protected class TestPane extends JPanel {

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(300, 300);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            g2d.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
            g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
            g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);

            g2d.setColor(Color.RED);
            RoundedShape shape = new RoundedShape(
                    20,
                    100, 200,
                    RoundedShape.Corner.TOP_LEFT,
                    RoundedShape.Corner.TOP_RIGHT,
                    RoundedShape.Corner.BOTTOM_RIGHT,
                    RoundedShape.Corner.BOTTOM_LEFT
            );
            g2d.translate(10, 10);
            g2d.draw(shape);

            g2d.dispose();
        }
    }

    public class RoundedShape extends Path2D.Double {

        enum Corner {
            TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT;
        }

        private double radius = 20;
        private Set<Corner> corners;
        private Dimension size;

        public RoundedShape(double radius, int width, int height, Corner... corners) {
            this.corners = new HashSet(Arrays.asList(corners));
            this.radius = radius;
            this.size = new Dimension(width, height);

            build();
        }

        protected void build() {
            moveTo(0, 0);
            if (corners.contains(Corner.TOP_LEFT)) {
                moveTo(0, radius);
                curveTo(0, radius, 0, 0, radius, 0);
            }
            if (corners.contains(Corner.TOP_RIGHT)) {
                lineTo(size.width - radius, 0);
                // Draw the curve here
                curveTo(size.width - radius, 0,
                        size.width, 0,
                        size.width, radius);
            } else {
                lineTo(size.width, 0);
            }
            if (corners.contains(Corner.BOTTOM_RIGHT)) {
                lineTo(size.width, size.height - radius);
                // Draw the curve here
                curveTo(size.width, size.height - radius,
                        size.width, size.height,
                        size.width - radius, size.height);
            } else {
                lineTo(size.width, size.height);
            }
            if (corners.contains(Corner.BOTTOM_LEFT)) {
                lineTo(radius, size.height);
                // Draw the curve here
                curveTo(radius, size.height,
                        0, size.height,
                        0, size.height - radius);
            } else {
                lineTo(0, size.height);
            }
            closePath();
        }
    }
}",    public class RoundedShape extends Path2D.Double {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Main#RoundedShape.build() ,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.Path2D;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame(""Test"");
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    protected class TestPane extends JPanel {

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(300, 300);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            g2d.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
            g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
            g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);

            g2d.setColor(Color.RED);
            RoundedShape shape = new RoundedShape(
                    20,
                    100, 200,
                    RoundedShape.Corner.TOP_LEFT,
                    RoundedShape.Corner.TOP_RIGHT,
                    RoundedShape.Corner.BOTTOM_RIGHT,
                    RoundedShape.Corner.BOTTOM_LEFT
            );
            g2d.translate(10, 10);
            g2d.draw(shape);

            g2d.dispose();
        }
    }

    public class RoundedShape extends Path2D.Double {

        enum Corner {
            TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT;
        }

        private double radius = 20;
        private Set<Corner> corners;
        private Dimension size;

        public RoundedShape(double radius, int width, int height, Corner... corners) {
            this.corners = new HashSet(Arrays.asList(corners));
            this.radius = radius;
            this.size = new Dimension(width, height);

            build();
        }

        protected void build() {
            moveTo(0, 0);
            if (corners.contains(Corner.TOP_LEFT)) {
                moveTo(0, radius);
                curveTo(0, radius, 0, 0, radius, 0);
            }
            if (corners.contains(Corner.TOP_RIGHT)) {
                lineTo(size.width - radius, 0);
                // Draw the curve here
                curveTo(size.width - radius, 0,
                        size.width, 0,
                        size.width, radius);
            } else {
                lineTo(size.width, 0);
            }
            if (corners.contains(Corner.BOTTOM_RIGHT)) {
                lineTo(size.width, size.height - radius);
                // Draw the curve here
                curveTo(size.width, size.height - radius,
                        size.width, size.height,
                        size.width - radius, size.height);
            } else {
                lineTo(size.width, size.height);
            }
            if (corners.contains(Corner.BOTTOM_LEFT)) {
                lineTo(radius, size.height);
                // Draw the curve here
                curveTo(radius, size.height,
                        0, size.height,
                        0, size.height - radius);
            } else {
                lineTo(0, size.height);
            }
            closePath();
        }
    }
}",            build();,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"private static class CustomRetrySpec extends Retry {
    private final int retries;
    private final Duration firstTime;
    private final Duration secondTime;
    private final Duration restTime;

    public CustomRetrySpec(int retries, Duration firstTime, Duration secondTime, Duration restTime) {
        this.retries = retries;
        this.firstTime = firstTime;
        this.secondTime = secondTime;
        this.restTime = restTime;
    }

    @Override
    public Publisher<?> generateCompanion(Flux<RetrySignal> retrySignals) {
        return retrySignals.flatMap(this::getRetry);
    }

    private Mono<Long> getRetry(Retry.RetrySignal rs) {
        if (rs.totalRetries() < retries) {
            Duration delay;
            if (rs.totalRetries() == 0) {
                delay = firstTime;
            } else if (rs.totalRetries() == 1) {
                delay = secondTime;
            } else {
                delay = restTime;
            }

            log.debug(""retry {} with backoff {}min"", rs.totalRetries(), delay.toMinutes());
            return Mono.delay(delay)
                    .thenReturn(rs.totalRetries());
        } else {
            log.debug(""retries exhausted with error: {}"", rs.failure().getMessage());
            throw Exceptions.propagate(rs.failure());
        }
    }
}",            } else if (rs.totalRetries() == 1) {,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","class Foo <T extends Object> {
    private final Consumer<T> cons;

    Foo(Consumer<T> cons) {
        this.cons = cons;
    }

    public void basedOnGeneric(T bar){
        cons.accept(bar);
    }
}

public class Test{
    public static void main(String[] args){
        Foo<String> a = new Foo<String>(GenericOverwrite::foo);
        a.basedOnGeneric(""I wish this could print string, but uses the object overloaded method"");

        Foo<Object> b = new Foo<Object>(GenericOverwrite::foo);
        b.basedOnGeneric(""This should print object"");
    }
}",public class Test{,StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.FileOutputStream;

import java.math.BigInteger;

import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.apache.poi.xwpf.usermodel.BreakType;
import org.apache.poi.xwpf.usermodel.Borders;

import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDocument1;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBody;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSectPr;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTColumns;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTColumn;
//import org.openxmlformats.schemas.wordprocessingml.x2006.main.STOnOff;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDocGrid;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.STDocGrid;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.STSectionMark;

public class Word2ColumnPage {
 public static void main(String[] args) throws Exception {

  XWPFDocument document= new XWPFDocument();

  XWPFParagraph paragraph = document.createParagraph();
  XWPFRun run=paragraph.createRun();  
  run.setText(""One column on top. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua."");

  paragraph = document.createParagraph();

  //paragraph with section setting for one column section above
  paragraph = document.createParagraph();
  CTSectPr ctSectPr = paragraph.getCTP().addNewPPr().addNewSectPr();
  CTColumns ctColumns = ctSectPr.addNewCols();
  ctColumns.setNum(BigInteger.valueOf(1));

  //left column

  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.setText(""The left side"");
  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.setText(""Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet."");

  paragraph = document.createParagraph();

  // right column 

  //paragraph with column break
  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.addBreak(BreakType.COLUMN);
  run=paragraph.createRun();  
  run.setText(""The right side"");

  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.setText(""Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet."");

  paragraph = document.createParagraph();

  //paragraph with section break continuous for two column section above
  paragraph = document.createParagraph();
  ctSectPr = paragraph.getCTP().addNewPPr().addNewSectPr();
  ctSectPr.addNewType().setVal(STSectionMark.CONTINUOUS);
  ctColumns = ctSectPr.addNewCols();
  ctColumns.setNum(BigInteger.valueOf(2));
  //ctColumns.setEqualWidth(STOnOff.OFF);  // up to Apache POI 4
  ctColumns.setEqualWidth(""0""); // from Apache POI 5 on 
  //ctColumns.setSep(STOnOff.ON); // up to Apache POI 4
  ctColumns.setSep(""1""); // from Apache POI 5 on 
  CTColumn ctColumn = ctColumns.addNewCol();
  ctColumn.setW(BigInteger.valueOf(6000));
  ctColumn.setSpace(BigInteger.valueOf(300));
  ctColumn = ctColumns.addNewCol();
  ctColumn.setW(BigInteger.valueOf(3000));

  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.setText(""One column on bottom"");

  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.setText(""Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet."");

  //section setting continuous for one column section above
  CTDocument1 ctDocument = document.getDocument();
  CTBody ctBody = ctDocument.getBody();
  ctSectPr = ctBody.addNewSectPr();
  ctSectPr.addNewType().setVal(STSectionMark.CONTINUOUS);
  ctColumns = ctSectPr.addNewCols();
  ctColumns.setNum(BigInteger.valueOf(1));

  FileOutputStream out = new FileOutputStream(""Word2ColumnPage.docx"");  
  document.write(out);
  out.close();
  document.close();

 }
}","  FileOutputStream out = new FileOutputStream(""Word2ColumnPage.docx"");  ",StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.FileOutputStream;

import org.apache.poi.xwpf.usermodel.*;

import org.apache.poi.xwpf.model.XWPFHeaderFooterPolicy;
import org.apache.poi.wp.usermodel.HeaderFooterType;

public class CreateWordHeaderFooter3 {
    
 static XWPFRun createRunFldCharTypeBegin(XWPFParagraph paragraph) {
  XWPFRun run = paragraph.createRun();
  org.openxmlformats.schemas.wordprocessingml.x2006.main.CTR cTR = run.getCTR();
  org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFldChar cTFldChar = org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFldChar.Factory.newInstance();
  cTFldChar.setFldCharTypeâ(org.openxmlformats.schemas.wordprocessingml.x2006.main.STFldCharType.BEGIN);
  cTR.setFldCharArrayâ(new org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFldChar[]{cTFldChar});
  return run;
 }

 static XWPFRun createRunInstrText(XWPFParagraph paragraph, String instrText) {
  XWPFRun run = paragraph.createRun();
  org.openxmlformats.schemas.wordprocessingml.x2006.main.CTR cTR = run.getCTR();
  org.openxmlformats.schemas.wordprocessingml.x2006.main.CTText cTText = org.openxmlformats.schemas.wordprocessingml.x2006.main.CTText.Factory.newInstance();
  cTText.setStringValue(instrText);
  cTR.setInstrTextArrayâ(new org.openxmlformats.schemas.wordprocessingml.x2006.main.CTText[]{cTText});
  return run;
 }
 
 static XWPFRun createRunFldCharTypeEnd(XWPFParagraph paragraph) {
  XWPFRun run = paragraph.createRun();
  org.openxmlformats.schemas.wordprocessingml.x2006.main.CTR cTR = run.getCTR();
  org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFldChar cTFldChar = org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFldChar.Factory.newInstance();
  cTFldChar.setFldCharTypeâ(org.openxmlformats.schemas.wordprocessingml.x2006.main.STFldCharType.END);
  cTR.setFldCharArrayâ(new org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFldChar[]{cTFldChar});
  return run;
 }

 public static void main(String[] args) throws Exception {

  XWPFDocument doc = new XWPFDocument();
  XWPFParagraph paragraph;
  XWPFRun run;
  
  // the body content
  paragraph = doc.createParagraph();
  run=paragraph.createRun();  
  run.setText(""The Body:"");

  paragraph = doc.createParagraph();
  run=paragraph.createRun();  
  run.setText(""Lorem ipsum.... page 1"");

  paragraph = doc.createParagraph();
  run=paragraph.createRun();
  run.addBreak(BreakType.PAGE); 
  run.setText(""Lorem ipsum.... page 2"");

  paragraph = doc.createParagraph();
  run=paragraph.createRun();
  run.addBreak(BreakType.PAGE); 
  run.setText(""Lorem ipsum.... page 3"");

  // create header-footer
  // create header start
  XWPFHeader header = doc.createHeader(HeaderFooterType.DEFAULT);

  paragraph = header.getParagraphArray(0);
  if (paragraph == null) paragraph = header.createParagraph();
  paragraph.setAlignment(ParagraphAlignment.LEFT);

  run = paragraph.createRun();  
  run.setText(""The Header:"");
  // create header end

  // create footer start
  XWPFFooter footer = doc.createFooter(HeaderFooterType.DEFAULT);

  paragraph = footer.getParagraphArray(0);
  if (paragraph == null) paragraph = footer.createParagraph();
  paragraph.setAlignment(ParagraphAlignment.CENTER);
  
  run = paragraph.createRun();  
  run.setText(""Page "");
  
  //paragraph.getCTP().addNewFldSimple().setInstr(""PAGE \\* MERGEFORMAT"");
  run = createRunFldCharTypeBegin(paragraph);
  run.setFontSize(16);
  run.setColor(""FF0000"");
  run = createRunInstrText(paragraph, ""PAGE \\* MERGEFORMAT"");
  run = createRunFldCharTypeEnd(paragraph);
  
  run = paragraph.createRun();  
  run.setText("" of "");
  
  //paragraph.getCTP().addNewFldSimple().setInstr(""NUMPAGES \\* MERGEFORMAT"");
  run = createRunFldCharTypeBegin(paragraph);
  run.setFontSize(16);
  run.setColor(""0000FF"");
  run = createRunInstrText(paragraph, ""NUMPAGES \\* MERGEFORMAT"");
  run = createRunFldCharTypeEnd(paragraph);
  
  // create footer end

  FileOutputStream out = new FileOutputStream(""CreateWordHeaderFooter.docx"");
  doc.write(out);
  out.close();
  doc.close();

 }
}","  FileOutputStream out = new FileOutputStream(""CreateWordHeaderFooter.docx"");",StackOverflow
TestClassWithoutTestCases,"The class 'MainTest' might be a test class, but it contains no test cases.","public class MainService {
  private Service someService;

  public MainService(Service service) {
    this.someService = service;
  }

  public boolean process(String flag) {
    if (Objects.equals(flag, ""flag1"")) {
      throw new IllegalArgumentException(""Oh no, exception!"");
    }
   boolean result = someService.execute(flag);
    if (result) {
      throw new IllegalArgumentException(""Oh no, exception!"");
    }
    return result;
  }
}

class MainTest {

  private Service someService;
  private MainService serviceUnderTest;
  @BeforeEach
  void setup(){
    this.someService = Mockito.mock(Service.class);
    this.serviceUnderTest = new MainService(someService);
  }

  @ParameterizedTest
  @MethodSource(""getFlags"")
  void shouldTestIfFlagWorks(String someFlag) {
    // Given
    Mockito.doReturn(true).when(someService).execute(someFlag);

    // When
    Throwable thrown = Assertions.catchThrowable(() -> 
       serviceUnderTest.process(someFlag));

    // Then
    Assertions.assertThat(thrown).hasMessage(""Oh no, exception!"");
  }

  private static Stream<Arguments> getFlags() {
    return Stream.of(
            Arguments.of(""flag1""),
            Arguments.of(""flag2"")
    );
  }
}",class MainTest {,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.util.Scanner;
import java.util.UUID;


public class Verification {
    static File credentials = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\userData.txt""); //Clarifying filepath
    static String uniUserID = "" "";
    static File gameData = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\gameData.txt"");

    public boolean Verify(String ID, String Pass) {
        String tempName = "" "";           //the data read from the .txt file would be stored in these temporary variables
        String tempPass = "" "";
        boolean found = false;//declaring some boolean variables so that the do while and if else statements work smoothly
        boolean verified = false;

        try //Try and catch block is initialized in case the file is not found
        {
            do {
                Scanner s2 = new Scanner(credentials); //Reading the .txt file
                s2.useDelimiter(""[,\n]"");// The file reader will stop once it encounters any of the following delimiters
                while (s2.hasNext() && !found) {
                    tempName = s2.next();                     //assigning the data read from the file to these variables
                    tempPass = s2.next();
                    uniUserID = s2.next();
                    if (tempName.trim().equals(ID) && tempPass.trim().equals(Pass))//comparing the data read from the file and the data entered by the user
                    {
                        verified = true;
                        found = true;
                    }
                }
            }
            while (found = false);
        } catch (Exception ex) {
            System.out.println(""Error"");
        }

        return verified;
    }

    public void Write(String newUser, String newPass) {
        String uniID = "" "";
        try {// try catch is used in case the file is not found
            uniID = UUID.randomUUID().toString();
            FileWriter writer = new FileWriter(credentials, true);// initializing the FileWriter, to make sure that it doesn't overwrite true is used so that it appends
            BufferedWriter buffwrite = new BufferedWriter(writer);                    // creating buffered writer object
            buffwrite.write(""\n"");                          // Writing the new user's credentials into the .txt file
            buffwrite.write(newUser);
            buffwrite.write("","");
            buffwrite.write(newPass);
            buffwrite.write("","");
            buffwrite.write(uniID);
            buffwrite.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
        try {
            FileWriter writer2 = new FileWriter(gameData, true);
            BufferedWriter buffwrite2 = new BufferedWriter(writer2);
            buffwrite2.write(""\n"");
            buffwrite2.write(uniID);
            buffwrite2.write("","");
            buffwrite2.write(""0"");
            buffwrite2.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
    }

    public static void Game(String uniqueID) throws FileNotFoundException {
        Scanner s3 = new Scanner(gameData);
        String waste = "" "";
        String coins = "" "";
        while (s3.hasNextLine()) {
            String fileLine = s3.nextLine();
            if (fileLine.contains(uniUserID)) {
                /*s3.useDelimiter((""[\n]""));
                s3.skip(uniUserID);
                coins = s3.next();*/
                coins = fileLine.split("","")[1];
                break;
            }
        }
        System.out.println(coins);
    }

    public static void main(String[] args) throws FileNotFoundException {
        Verification obj = new Verification();
        Scanner s1 = new Scanner(System.in);                                                   //Creating scanner object
        boolean end = false;                                    //declaring the variable that will end the do while loop
        do                          //do while loop is used so that the user gets taken to the main menu again and again
        {
            System.out.println(""Welcome to the economic bot!"");
            System.out.println(""Select one option to proceed"");
            System.out.println(""1. Login"");
            System.out.println(""2. Register"");
            int choice = s1.nextInt(); //accepting user's choice

            switch (choice) {
                case 1:
                    System.out.println(""Enter your username:"");
                    String userID = s1.next();                                                //taking user credentials
                    System.out.println(""Enter your password"");
                    String userPass = s1.next();

                    boolean validated = obj.Verify(userID, userPass);

                    if (validated == true) { //if the login details are correct
                        System.out.println(""Login Successful!"");
                        System.out.println(""Redirecting..."");
                        System.out.println();
                        end = true;
                        Game(uniUserID);
                    } else { //if the details entered are wrong
                        System.out.println(""Login failed! Possibly due to wrong user credentials."");
                        System.out.println(""Please try again!"");
                    }
                    break;

                case 2:
                    System.out.println(""Enter the username you'd like to keep:"");
                    String regUserID = s1.next(); //accepting user details
                    System.out.println(""Enter the password:"");
                    String regUserPass = s1.next();

                    obj.Write(regUserID, regUserPass);
                    break;

                default:
                    System.out.println(""Invalid Option chosen."");              // In case the user enters a wrong choice
            }
        }
        while (!end); // condition for the initial do loop
    }
}",                Scanner s2 = new Scanner(credentials); //Reading the .txt file,StackOverflow
CloseResource,Ensure that resources like this FileWriter object are closed after use,"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.util.Scanner;
import java.util.UUID;


public class Verification {
    static File credentials = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\userData.txt""); //Clarifying filepath
    static String uniUserID = "" "";
    static File gameData = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\gameData.txt"");

    public boolean Verify(String ID, String Pass) {
        String tempName = "" "";           //the data read from the .txt file would be stored in these temporary variables
        String tempPass = "" "";
        boolean found = false;//declaring some boolean variables so that the do while and if else statements work smoothly
        boolean verified = false;

        try //Try and catch block is initialized in case the file is not found
        {
            do {
                Scanner s2 = new Scanner(credentials); //Reading the .txt file
                s2.useDelimiter(""[,\n]"");// The file reader will stop once it encounters any of the following delimiters
                while (s2.hasNext() && !found) {
                    tempName = s2.next();                     //assigning the data read from the file to these variables
                    tempPass = s2.next();
                    uniUserID = s2.next();
                    if (tempName.trim().equals(ID) && tempPass.trim().equals(Pass))//comparing the data read from the file and the data entered by the user
                    {
                        verified = true;
                        found = true;
                    }
                }
            }
            while (found = false);
        } catch (Exception ex) {
            System.out.println(""Error"");
        }

        return verified;
    }

    public void Write(String newUser, String newPass) {
        String uniID = "" "";
        try {// try catch is used in case the file is not found
            uniID = UUID.randomUUID().toString();
            FileWriter writer = new FileWriter(credentials, true);// initializing the FileWriter, to make sure that it doesn't overwrite true is used so that it appends
            BufferedWriter buffwrite = new BufferedWriter(writer);                    // creating buffered writer object
            buffwrite.write(""\n"");                          // Writing the new user's credentials into the .txt file
            buffwrite.write(newUser);
            buffwrite.write("","");
            buffwrite.write(newPass);
            buffwrite.write("","");
            buffwrite.write(uniID);
            buffwrite.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
        try {
            FileWriter writer2 = new FileWriter(gameData, true);
            BufferedWriter buffwrite2 = new BufferedWriter(writer2);
            buffwrite2.write(""\n"");
            buffwrite2.write(uniID);
            buffwrite2.write("","");
            buffwrite2.write(""0"");
            buffwrite2.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
    }

    public static void Game(String uniqueID) throws FileNotFoundException {
        Scanner s3 = new Scanner(gameData);
        String waste = "" "";
        String coins = "" "";
        while (s3.hasNextLine()) {
            String fileLine = s3.nextLine();
            if (fileLine.contains(uniUserID)) {
                /*s3.useDelimiter((""[\n]""));
                s3.skip(uniUserID);
                coins = s3.next();*/
                coins = fileLine.split("","")[1];
                break;
            }
        }
        System.out.println(coins);
    }

    public static void main(String[] args) throws FileNotFoundException {
        Verification obj = new Verification();
        Scanner s1 = new Scanner(System.in);                                                   //Creating scanner object
        boolean end = false;                                    //declaring the variable that will end the do while loop
        do                          //do while loop is used so that the user gets taken to the main menu again and again
        {
            System.out.println(""Welcome to the economic bot!"");
            System.out.println(""Select one option to proceed"");
            System.out.println(""1. Login"");
            System.out.println(""2. Register"");
            int choice = s1.nextInt(); //accepting user's choice

            switch (choice) {
                case 1:
                    System.out.println(""Enter your username:"");
                    String userID = s1.next();                                                //taking user credentials
                    System.out.println(""Enter your password"");
                    String userPass = s1.next();

                    boolean validated = obj.Verify(userID, userPass);

                    if (validated == true) { //if the login details are correct
                        System.out.println(""Login Successful!"");
                        System.out.println(""Redirecting..."");
                        System.out.println();
                        end = true;
                        Game(uniUserID);
                    } else { //if the details entered are wrong
                        System.out.println(""Login failed! Possibly due to wrong user credentials."");
                        System.out.println(""Please try again!"");
                    }
                    break;

                case 2:
                    System.out.println(""Enter the username you'd like to keep:"");
                    String regUserID = s1.next(); //accepting user details
                    System.out.println(""Enter the password:"");
                    String regUserPass = s1.next();

                    obj.Write(regUserID, regUserPass);
                    break;

                default:
                    System.out.println(""Invalid Option chosen."");              // In case the user enters a wrong choice
            }
        }
        while (!end); // condition for the initial do loop
    }
}","            FileWriter writer = new FileWriter(credentials, true);// initializing the FileWriter, to make sure that it doesn't overwrite true is used so that it appends",StackOverflow
CloseResource,Ensure that resources like this BufferedWriter object are closed after use,"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.util.Scanner;
import java.util.UUID;


public class Verification {
    static File credentials = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\userData.txt""); //Clarifying filepath
    static String uniUserID = "" "";
    static File gameData = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\gameData.txt"");

    public boolean Verify(String ID, String Pass) {
        String tempName = "" "";           //the data read from the .txt file would be stored in these temporary variables
        String tempPass = "" "";
        boolean found = false;//declaring some boolean variables so that the do while and if else statements work smoothly
        boolean verified = false;

        try //Try and catch block is initialized in case the file is not found
        {
            do {
                Scanner s2 = new Scanner(credentials); //Reading the .txt file
                s2.useDelimiter(""[,\n]"");// The file reader will stop once it encounters any of the following delimiters
                while (s2.hasNext() && !found) {
                    tempName = s2.next();                     //assigning the data read from the file to these variables
                    tempPass = s2.next();
                    uniUserID = s2.next();
                    if (tempName.trim().equals(ID) && tempPass.trim().equals(Pass))//comparing the data read from the file and the data entered by the user
                    {
                        verified = true;
                        found = true;
                    }
                }
            }
            while (found = false);
        } catch (Exception ex) {
            System.out.println(""Error"");
        }

        return verified;
    }

    public void Write(String newUser, String newPass) {
        String uniID = "" "";
        try {// try catch is used in case the file is not found
            uniID = UUID.randomUUID().toString();
            FileWriter writer = new FileWriter(credentials, true);// initializing the FileWriter, to make sure that it doesn't overwrite true is used so that it appends
            BufferedWriter buffwrite = new BufferedWriter(writer);                    // creating buffered writer object
            buffwrite.write(""\n"");                          // Writing the new user's credentials into the .txt file
            buffwrite.write(newUser);
            buffwrite.write("","");
            buffwrite.write(newPass);
            buffwrite.write("","");
            buffwrite.write(uniID);
            buffwrite.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
        try {
            FileWriter writer2 = new FileWriter(gameData, true);
            BufferedWriter buffwrite2 = new BufferedWriter(writer2);
            buffwrite2.write(""\n"");
            buffwrite2.write(uniID);
            buffwrite2.write("","");
            buffwrite2.write(""0"");
            buffwrite2.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
    }

    public static void Game(String uniqueID) throws FileNotFoundException {
        Scanner s3 = new Scanner(gameData);
        String waste = "" "";
        String coins = "" "";
        while (s3.hasNextLine()) {
            String fileLine = s3.nextLine();
            if (fileLine.contains(uniUserID)) {
                /*s3.useDelimiter((""[\n]""));
                s3.skip(uniUserID);
                coins = s3.next();*/
                coins = fileLine.split("","")[1];
                break;
            }
        }
        System.out.println(coins);
    }

    public static void main(String[] args) throws FileNotFoundException {
        Verification obj = new Verification();
        Scanner s1 = new Scanner(System.in);                                                   //Creating scanner object
        boolean end = false;                                    //declaring the variable that will end the do while loop
        do                          //do while loop is used so that the user gets taken to the main menu again and again
        {
            System.out.println(""Welcome to the economic bot!"");
            System.out.println(""Select one option to proceed"");
            System.out.println(""1. Login"");
            System.out.println(""2. Register"");
            int choice = s1.nextInt(); //accepting user's choice

            switch (choice) {
                case 1:
                    System.out.println(""Enter your username:"");
                    String userID = s1.next();                                                //taking user credentials
                    System.out.println(""Enter your password"");
                    String userPass = s1.next();

                    boolean validated = obj.Verify(userID, userPass);

                    if (validated == true) { //if the login details are correct
                        System.out.println(""Login Successful!"");
                        System.out.println(""Redirecting..."");
                        System.out.println();
                        end = true;
                        Game(uniUserID);
                    } else { //if the details entered are wrong
                        System.out.println(""Login failed! Possibly due to wrong user credentials."");
                        System.out.println(""Please try again!"");
                    }
                    break;

                case 2:
                    System.out.println(""Enter the username you'd like to keep:"");
                    String regUserID = s1.next(); //accepting user details
                    System.out.println(""Enter the password:"");
                    String regUserPass = s1.next();

                    obj.Write(regUserID, regUserPass);
                    break;

                default:
                    System.out.println(""Invalid Option chosen."");              // In case the user enters a wrong choice
            }
        }
        while (!end); // condition for the initial do loop
    }
}",            BufferedWriter buffwrite = new BufferedWriter(writer);                    // creating buffered writer object,StackOverflow
CloseResource,Ensure that resources like this FileWriter object are closed after use,"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.util.Scanner;
import java.util.UUID;


public class Verification {
    static File credentials = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\userData.txt""); //Clarifying filepath
    static String uniUserID = "" "";
    static File gameData = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\gameData.txt"");

    public boolean Verify(String ID, String Pass) {
        String tempName = "" "";           //the data read from the .txt file would be stored in these temporary variables
        String tempPass = "" "";
        boolean found = false;//declaring some boolean variables so that the do while and if else statements work smoothly
        boolean verified = false;

        try //Try and catch block is initialized in case the file is not found
        {
            do {
                Scanner s2 = new Scanner(credentials); //Reading the .txt file
                s2.useDelimiter(""[,\n]"");// The file reader will stop once it encounters any of the following delimiters
                while (s2.hasNext() && !found) {
                    tempName = s2.next();                     //assigning the data read from the file to these variables
                    tempPass = s2.next();
                    uniUserID = s2.next();
                    if (tempName.trim().equals(ID) && tempPass.trim().equals(Pass))//comparing the data read from the file and the data entered by the user
                    {
                        verified = true;
                        found = true;
                    }
                }
            }
            while (found = false);
        } catch (Exception ex) {
            System.out.println(""Error"");
        }

        return verified;
    }

    public void Write(String newUser, String newPass) {
        String uniID = "" "";
        try {// try catch is used in case the file is not found
            uniID = UUID.randomUUID().toString();
            FileWriter writer = new FileWriter(credentials, true);// initializing the FileWriter, to make sure that it doesn't overwrite true is used so that it appends
            BufferedWriter buffwrite = new BufferedWriter(writer);                    // creating buffered writer object
            buffwrite.write(""\n"");                          // Writing the new user's credentials into the .txt file
            buffwrite.write(newUser);
            buffwrite.write("","");
            buffwrite.write(newPass);
            buffwrite.write("","");
            buffwrite.write(uniID);
            buffwrite.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
        try {
            FileWriter writer2 = new FileWriter(gameData, true);
            BufferedWriter buffwrite2 = new BufferedWriter(writer2);
            buffwrite2.write(""\n"");
            buffwrite2.write(uniID);
            buffwrite2.write("","");
            buffwrite2.write(""0"");
            buffwrite2.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
    }

    public static void Game(String uniqueID) throws FileNotFoundException {
        Scanner s3 = new Scanner(gameData);
        String waste = "" "";
        String coins = "" "";
        while (s3.hasNextLine()) {
            String fileLine = s3.nextLine();
            if (fileLine.contains(uniUserID)) {
                /*s3.useDelimiter((""[\n]""));
                s3.skip(uniUserID);
                coins = s3.next();*/
                coins = fileLine.split("","")[1];
                break;
            }
        }
        System.out.println(coins);
    }

    public static void main(String[] args) throws FileNotFoundException {
        Verification obj = new Verification();
        Scanner s1 = new Scanner(System.in);                                                   //Creating scanner object
        boolean end = false;                                    //declaring the variable that will end the do while loop
        do                          //do while loop is used so that the user gets taken to the main menu again and again
        {
            System.out.println(""Welcome to the economic bot!"");
            System.out.println(""Select one option to proceed"");
            System.out.println(""1. Login"");
            System.out.println(""2. Register"");
            int choice = s1.nextInt(); //accepting user's choice

            switch (choice) {
                case 1:
                    System.out.println(""Enter your username:"");
                    String userID = s1.next();                                                //taking user credentials
                    System.out.println(""Enter your password"");
                    String userPass = s1.next();

                    boolean validated = obj.Verify(userID, userPass);

                    if (validated == true) { //if the login details are correct
                        System.out.println(""Login Successful!"");
                        System.out.println(""Redirecting..."");
                        System.out.println();
                        end = true;
                        Game(uniUserID);
                    } else { //if the details entered are wrong
                        System.out.println(""Login failed! Possibly due to wrong user credentials."");
                        System.out.println(""Please try again!"");
                    }
                    break;

                case 2:
                    System.out.println(""Enter the username you'd like to keep:"");
                    String regUserID = s1.next(); //accepting user details
                    System.out.println(""Enter the password:"");
                    String regUserPass = s1.next();

                    obj.Write(regUserID, regUserPass);
                    break;

                default:
                    System.out.println(""Invalid Option chosen."");              // In case the user enters a wrong choice
            }
        }
        while (!end); // condition for the initial do loop
    }
}","            FileWriter writer2 = new FileWriter(gameData, true);",StackOverflow
CloseResource,Ensure that resources like this BufferedWriter object are closed after use,"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.util.Scanner;
import java.util.UUID;


public class Verification {
    static File credentials = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\userData.txt""); //Clarifying filepath
    static String uniUserID = "" "";
    static File gameData = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\gameData.txt"");

    public boolean Verify(String ID, String Pass) {
        String tempName = "" "";           //the data read from the .txt file would be stored in these temporary variables
        String tempPass = "" "";
        boolean found = false;//declaring some boolean variables so that the do while and if else statements work smoothly
        boolean verified = false;

        try //Try and catch block is initialized in case the file is not found
        {
            do {
                Scanner s2 = new Scanner(credentials); //Reading the .txt file
                s2.useDelimiter(""[,\n]"");// The file reader will stop once it encounters any of the following delimiters
                while (s2.hasNext() && !found) {
                    tempName = s2.next();                     //assigning the data read from the file to these variables
                    tempPass = s2.next();
                    uniUserID = s2.next();
                    if (tempName.trim().equals(ID) && tempPass.trim().equals(Pass))//comparing the data read from the file and the data entered by the user
                    {
                        verified = true;
                        found = true;
                    }
                }
            }
            while (found = false);
        } catch (Exception ex) {
            System.out.println(""Error"");
        }

        return verified;
    }

    public void Write(String newUser, String newPass) {
        String uniID = "" "";
        try {// try catch is used in case the file is not found
            uniID = UUID.randomUUID().toString();
            FileWriter writer = new FileWriter(credentials, true);// initializing the FileWriter, to make sure that it doesn't overwrite true is used so that it appends
            BufferedWriter buffwrite = new BufferedWriter(writer);                    // creating buffered writer object
            buffwrite.write(""\n"");                          // Writing the new user's credentials into the .txt file
            buffwrite.write(newUser);
            buffwrite.write("","");
            buffwrite.write(newPass);
            buffwrite.write("","");
            buffwrite.write(uniID);
            buffwrite.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
        try {
            FileWriter writer2 = new FileWriter(gameData, true);
            BufferedWriter buffwrite2 = new BufferedWriter(writer2);
            buffwrite2.write(""\n"");
            buffwrite2.write(uniID);
            buffwrite2.write("","");
            buffwrite2.write(""0"");
            buffwrite2.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
    }

    public static void Game(String uniqueID) throws FileNotFoundException {
        Scanner s3 = new Scanner(gameData);
        String waste = "" "";
        String coins = "" "";
        while (s3.hasNextLine()) {
            String fileLine = s3.nextLine();
            if (fileLine.contains(uniUserID)) {
                /*s3.useDelimiter((""[\n]""));
                s3.skip(uniUserID);
                coins = s3.next();*/
                coins = fileLine.split("","")[1];
                break;
            }
        }
        System.out.println(coins);
    }

    public static void main(String[] args) throws FileNotFoundException {
        Verification obj = new Verification();
        Scanner s1 = new Scanner(System.in);                                                   //Creating scanner object
        boolean end = false;                                    //declaring the variable that will end the do while loop
        do                          //do while loop is used so that the user gets taken to the main menu again and again
        {
            System.out.println(""Welcome to the economic bot!"");
            System.out.println(""Select one option to proceed"");
            System.out.println(""1. Login"");
            System.out.println(""2. Register"");
            int choice = s1.nextInt(); //accepting user's choice

            switch (choice) {
                case 1:
                    System.out.println(""Enter your username:"");
                    String userID = s1.next();                                                //taking user credentials
                    System.out.println(""Enter your password"");
                    String userPass = s1.next();

                    boolean validated = obj.Verify(userID, userPass);

                    if (validated == true) { //if the login details are correct
                        System.out.println(""Login Successful!"");
                        System.out.println(""Redirecting..."");
                        System.out.println();
                        end = true;
                        Game(uniUserID);
                    } else { //if the details entered are wrong
                        System.out.println(""Login failed! Possibly due to wrong user credentials."");
                        System.out.println(""Please try again!"");
                    }
                    break;

                case 2:
                    System.out.println(""Enter the username you'd like to keep:"");
                    String regUserID = s1.next(); //accepting user details
                    System.out.println(""Enter the password:"");
                    String regUserPass = s1.next();

                    obj.Write(regUserID, regUserPass);
                    break;

                default:
                    System.out.println(""Invalid Option chosen."");              // In case the user enters a wrong choice
            }
        }
        while (!end); // condition for the initial do loop
    }
}",            BufferedWriter buffwrite2 = new BufferedWriter(writer2);,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.util.Scanner;
import java.util.UUID;


public class Verification {
    static File credentials = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\userData.txt""); //Clarifying filepath
    static String uniUserID = "" "";
    static File gameData = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\gameData.txt"");

    public boolean Verify(String ID, String Pass) {
        String tempName = "" "";           //the data read from the .txt file would be stored in these temporary variables
        String tempPass = "" "";
        boolean found = false;//declaring some boolean variables so that the do while and if else statements work smoothly
        boolean verified = false;

        try //Try and catch block is initialized in case the file is not found
        {
            do {
                Scanner s2 = new Scanner(credentials); //Reading the .txt file
                s2.useDelimiter(""[,\n]"");// The file reader will stop once it encounters any of the following delimiters
                while (s2.hasNext() && !found) {
                    tempName = s2.next();                     //assigning the data read from the file to these variables
                    tempPass = s2.next();
                    uniUserID = s2.next();
                    if (tempName.trim().equals(ID) && tempPass.trim().equals(Pass))//comparing the data read from the file and the data entered by the user
                    {
                        verified = true;
                        found = true;
                    }
                }
            }
            while (found = false);
        } catch (Exception ex) {
            System.out.println(""Error"");
        }

        return verified;
    }

    public void Write(String newUser, String newPass) {
        String uniID = "" "";
        try {// try catch is used in case the file is not found
            uniID = UUID.randomUUID().toString();
            FileWriter writer = new FileWriter(credentials, true);// initializing the FileWriter, to make sure that it doesn't overwrite true is used so that it appends
            BufferedWriter buffwrite = new BufferedWriter(writer);                    // creating buffered writer object
            buffwrite.write(""\n"");                          // Writing the new user's credentials into the .txt file
            buffwrite.write(newUser);
            buffwrite.write("","");
            buffwrite.write(newPass);
            buffwrite.write("","");
            buffwrite.write(uniID);
            buffwrite.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
        try {
            FileWriter writer2 = new FileWriter(gameData, true);
            BufferedWriter buffwrite2 = new BufferedWriter(writer2);
            buffwrite2.write(""\n"");
            buffwrite2.write(uniID);
            buffwrite2.write("","");
            buffwrite2.write(""0"");
            buffwrite2.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
    }

    public static void Game(String uniqueID) throws FileNotFoundException {
        Scanner s3 = new Scanner(gameData);
        String waste = "" "";
        String coins = "" "";
        while (s3.hasNextLine()) {
            String fileLine = s3.nextLine();
            if (fileLine.contains(uniUserID)) {
                /*s3.useDelimiter((""[\n]""));
                s3.skip(uniUserID);
                coins = s3.next();*/
                coins = fileLine.split("","")[1];
                break;
            }
        }
        System.out.println(coins);
    }

    public static void main(String[] args) throws FileNotFoundException {
        Verification obj = new Verification();
        Scanner s1 = new Scanner(System.in);                                                   //Creating scanner object
        boolean end = false;                                    //declaring the variable that will end the do while loop
        do                          //do while loop is used so that the user gets taken to the main menu again and again
        {
            System.out.println(""Welcome to the economic bot!"");
            System.out.println(""Select one option to proceed"");
            System.out.println(""1. Login"");
            System.out.println(""2. Register"");
            int choice = s1.nextInt(); //accepting user's choice

            switch (choice) {
                case 1:
                    System.out.println(""Enter your username:"");
                    String userID = s1.next();                                                //taking user credentials
                    System.out.println(""Enter your password"");
                    String userPass = s1.next();

                    boolean validated = obj.Verify(userID, userPass);

                    if (validated == true) { //if the login details are correct
                        System.out.println(""Login Successful!"");
                        System.out.println(""Redirecting..."");
                        System.out.println();
                        end = true;
                        Game(uniUserID);
                    } else { //if the details entered are wrong
                        System.out.println(""Login failed! Possibly due to wrong user credentials."");
                        System.out.println(""Please try again!"");
                    }
                    break;

                case 2:
                    System.out.println(""Enter the username you'd like to keep:"");
                    String regUserID = s1.next(); //accepting user details
                    System.out.println(""Enter the password:"");
                    String regUserPass = s1.next();

                    obj.Write(regUserID, regUserPass);
                    break;

                default:
                    System.out.println(""Invalid Option chosen."");              // In case the user enters a wrong choice
            }
        }
        while (!end); // condition for the initial do loop
    }
}",        Scanner s3 = new Scanner(gameData);,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.util.Scanner;
import java.util.UUID;


public class Verification {
    static File credentials = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\userData.txt""); //Clarifying filepath
    static String uniUserID = "" "";
    static File gameData = new File(""C:\\Users\\user\\IdeaProjects\\Economic Bot\\out\\gameData.txt"");

    public boolean Verify(String ID, String Pass) {
        String tempName = "" "";           //the data read from the .txt file would be stored in these temporary variables
        String tempPass = "" "";
        boolean found = false;//declaring some boolean variables so that the do while and if else statements work smoothly
        boolean verified = false;

        try //Try and catch block is initialized in case the file is not found
        {
            do {
                Scanner s2 = new Scanner(credentials); //Reading the .txt file
                s2.useDelimiter(""[,\n]"");// The file reader will stop once it encounters any of the following delimiters
                while (s2.hasNext() && !found) {
                    tempName = s2.next();                     //assigning the data read from the file to these variables
                    tempPass = s2.next();
                    uniUserID = s2.next();
                    if (tempName.trim().equals(ID) && tempPass.trim().equals(Pass))//comparing the data read from the file and the data entered by the user
                    {
                        verified = true;
                        found = true;
                    }
                }
            }
            while (found = false);
        } catch (Exception ex) {
            System.out.println(""Error"");
        }

        return verified;
    }

    public void Write(String newUser, String newPass) {
        String uniID = "" "";
        try {// try catch is used in case the file is not found
            uniID = UUID.randomUUID().toString();
            FileWriter writer = new FileWriter(credentials, true);// initializing the FileWriter, to make sure that it doesn't overwrite true is used so that it appends
            BufferedWriter buffwrite = new BufferedWriter(writer);                    // creating buffered writer object
            buffwrite.write(""\n"");                          // Writing the new user's credentials into the .txt file
            buffwrite.write(newUser);
            buffwrite.write("","");
            buffwrite.write(newPass);
            buffwrite.write("","");
            buffwrite.write(uniID);
            buffwrite.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
        try {
            FileWriter writer2 = new FileWriter(gameData, true);
            BufferedWriter buffwrite2 = new BufferedWriter(writer2);
            buffwrite2.write(""\n"");
            buffwrite2.write(uniID);
            buffwrite2.write("","");
            buffwrite2.write(""0"");
            buffwrite2.close();
        } catch (Exception ex) {
            System.out.println(""Error"");
        }
    }

    public static void Game(String uniqueID) throws FileNotFoundException {
        Scanner s3 = new Scanner(gameData);
        String waste = "" "";
        String coins = "" "";
        while (s3.hasNextLine()) {
            String fileLine = s3.nextLine();
            if (fileLine.contains(uniUserID)) {
                /*s3.useDelimiter((""[\n]""));
                s3.skip(uniUserID);
                coins = s3.next();*/
                coins = fileLine.split("","")[1];
                break;
            }
        }
        System.out.println(coins);
    }

    public static void main(String[] args) throws FileNotFoundException {
        Verification obj = new Verification();
        Scanner s1 = new Scanner(System.in);                                                   //Creating scanner object
        boolean end = false;                                    //declaring the variable that will end the do while loop
        do                          //do while loop is used so that the user gets taken to the main menu again and again
        {
            System.out.println(""Welcome to the economic bot!"");
            System.out.println(""Select one option to proceed"");
            System.out.println(""1. Login"");
            System.out.println(""2. Register"");
            int choice = s1.nextInt(); //accepting user's choice

            switch (choice) {
                case 1:
                    System.out.println(""Enter your username:"");
                    String userID = s1.next();                                                //taking user credentials
                    System.out.println(""Enter your password"");
                    String userPass = s1.next();

                    boolean validated = obj.Verify(userID, userPass);

                    if (validated == true) { //if the login details are correct
                        System.out.println(""Login Successful!"");
                        System.out.println(""Redirecting..."");
                        System.out.println();
                        end = true;
                        Game(uniUserID);
                    } else { //if the details entered are wrong
                        System.out.println(""Login failed! Possibly due to wrong user credentials."");
                        System.out.println(""Please try again!"");
                    }
                    break;

                case 2:
                    System.out.println(""Enter the username you'd like to keep:"");
                    String regUserID = s1.next(); //accepting user details
                    System.out.println(""Enter the password:"");
                    String regUserPass = s1.next();

                    obj.Write(regUserID, regUserPass);
                    break;

                default:
                    System.out.println(""Invalid Option chosen."");              // In case the user enters a wrong choice
            }
        }
        while (!end); // condition for the initial do loop
    }
}",        Scanner s1 = new Scanner(System.in);                                                   //Creating scanner object,StackOverflow
TestClassWithoutTestCases,"The class 'Testing' might be a test class, but it contains no test cases.","@Builder(toBuilder = true)
class Testing {

    @NonNull private String id;

    @NonNull
    private TestEnum test;

    private String message;

    public static class TestingBuilder {
        public TestingBuilder test(@NonNull TestEnum test) {
            if (test != TestEnum.ALPHA && test != TestEnum.BETA) {
                throw new IllegalArgumentException(""test can only be ALPHA or BETA!"");
            }
            this.test = test;
            return this;
        }
    }
}",class Testing {,StackOverflow
TestClassWithoutTestCases,"The class 'TestingBuilder' might be a test class, but it contains no test cases.","@Builder(toBuilder = true)
class Testing {

    @NonNull private String id;

    @NonNull
    private TestEnum test;

    private String message;

    public static class TestingBuilder {
        public TestingBuilder test(@NonNull TestEnum test) {
            if (test != TestEnum.ALPHA && test != TestEnum.BETA) {
                throw new IllegalArgumentException(""test can only be ALPHA or BETA!"");
            }
            this.test = test;
            return this;
        }
    }
}",    public static class TestingBuilder {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class Main {

  public static void main(String[] args) {
    test(""1(234)67""); // Expected output: ""234""
    test(""123(45))""); // Expected output: ""45)""
    test(""x)""); // Expected output: """"
    test("")x(""); // Expected output: """"
    test(""12(34)5(67)""); // Expected output: ""34)5(67""
  }

  static void test(String seq) {
    var res = clean(seq);
    System.out.printf(""clean(\""%s\"") => \""%s\""%n"", seq, res);
  }

  static String clean(String seq) {
    if (seq.isEmpty()) {
      // no result
      return """";
    } else if (seq.charAt(0) != '(') {
      // still need to find the first opening parenthesis (recursively)
      return clean(seq.substring(1));
    } else if (seq.charAt(seq.length() - 1) != ')') {
      // still need to find the last closing parenthesis (recursively)
      return clean(seq.substring(0, seq.length() - 1));
    } else {
      // Found result (use 'substring' to remove parentheses from string)
      return seq.substring(1, seq.length() - 1);
    }
  }
}",    } else if (seq.charAt(0) != '(') {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class Main {

  public static void main(String[] args) {
    test(""1(234)67""); // Expected output: ""234""
    test(""123(45))""); // Expected output: ""45)""
    test(""x)""); // Expected output: """"
    test("")x(""); // Expected output: """"
    test(""12(34)5(67)""); // Expected output: ""34)5(67""
  }

  static void test(String seq) {
    var res = clean(seq);
    System.out.printf(""clean(\""%s\"") => \""%s\""%n"", seq, res);
  }

  static String clean(String seq) {
    if (seq.isEmpty()) {
      // no result
      return """";
    } else if (seq.charAt(0) != '(') {
      // still need to find the first opening parenthesis (recursively)
      return clean(seq.substring(1));
    } else if (seq.charAt(seq.length() - 1) != ')') {
      // still need to find the last closing parenthesis (recursively)
      return clean(seq.substring(0, seq.length() - 1));
    } else {
      // Found result (use 'substring' to remove parentheses from string)
      return seq.substring(1, seq.length() - 1);
    }
  }
}",    } else if (seq.charAt(seq.length() - 1) != ')') {,StackOverflow
CloseResource,Ensure that resources like this InputStream object are closed after use,"package org.acme;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.eclipse.microprofile.openapi.OASFactory;
import org.eclipse.microprofile.openapi.OASFilter;
import org.eclipse.microprofile.openapi.models.Components;
import org.eclipse.microprofile.openapi.models.OpenAPI;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.microprofile.openapi.models.examples.Example;

public class OASModelFilter implements OASFilter {

    ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void filterOpenAPI(OpenAPI openAPI) {

        //openApi.getComponents() will result in NULL as we don't have any openapi.yaml file.
        Components defaultComponents = OASFactory.createComponents();
        if(openAPI.getComponents() == null){
            openAPI.setComponents(defaultComponents);
        }

        generateExamples().forEach(openAPI.getComponents()::addExample);
    }

    Map<String, Example> generateExamples() {


        Map<String, Example> examples = new LinkedHashMap<>();

        try {

            //loop over your Example JSON Files,..
            //In this case, the example is only for 1 file.
            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            InputStream userJsonFileInputStream = loader.getResourceAsStream(""user.json"");

            String fileJSONContents = new String(userJsonFileInputStream.readAllBytes(), StandardCharsets.UTF_8);



            //Create a unique example for each File/JSON
            Example createExample = OASFactory.createExample()
                                              .description(""User JSON Description"")
                                              .value(objectMapper.readValue(fileJSONContents, ObjectNode.class));

            // Save your Example with a Unique Map Key.
            examples.put(""createExample"", createExample);

        } catch (IOException ioException) {
            System.out.println(""An error occured"" + ioException);
        }
        return examples;
    }

}","            InputStream userJsonFileInputStream = loader.getResourceAsStream(""user.json"");",StackOverflow
TestClassWithoutTestCases,"The class 'MyClassTest' might be a test class, but it contains no test cases.","@ExtendWith(MockitoExtension.class)
public class MyClassTest {
    @Mock
    private Service service;

    @Test
    public void test() {
        try(MockedStatic<Util> dummyStatic = Mockito.mockStatic(Util.class)) {
            dummyStatic.when(() -> Util.utilFuncCallingService(service)).thenReturn(""mock-response"");
            MyClass myClass = new MyClass(service);
            myClass.method();
        }
    }
}

// Prints: Response: mock-response

@ExtendWith(MockitoExtension.class)
public class MyClassTest {
    @Mock
    private Service service;

    @Test
    public void test() {
        when(Util.utilFuncCallingService(service)).thenReturn(""mock-response"");
        System.out.println(service.doSomething());
    }
}

// Prints:
// Util class calling doSomething on service
// mock-response",public class MyClassTest {,StackOverflow
TestClassWithoutTestCases,"The class 'MyClassTest' might be a test class, but it contains no test cases.","@ExtendWith(MockitoExtension.class)
public class MyClassTest {
    @Mock
    private Service service;

    @Test
    public void test() {
        try(MockedStatic<Util> dummyStatic = Mockito.mockStatic(Util.class)) {
            dummyStatic.when(() -> Util.utilFuncCallingService(service)).thenReturn(""mock-response"");
            MyClass myClass = new MyClass(service);
            myClass.method();
        }
    }
}

// Prints: Response: mock-response

@ExtendWith(MockitoExtension.class)
public class MyClassTest {
    @Mock
    private Service service;

    @Test
    public void test() {
        when(Util.utilFuncCallingService(service)).thenReturn(""mock-response"");
        System.out.println(service.doSomething());
    }
}

// Prints:
// Util class calling doSomething on service
// mock-response",public class MyClassTest {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"package com.example.s3;

// snippet-start:[s3.java2.create_bucket_waiters.import]
import software.amazon.awssdk.auth.credentials.ProfileCredentialsProvider;
import software.amazon.awssdk.core.waiters.WaiterResponse;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.CreateBucketRequest;
import software.amazon.awssdk.services.s3.model.HeadBucketRequest;
import software.amazon.awssdk.services.s3.model.HeadBucketResponse;
import software.amazon.awssdk.services.s3.model.S3Exception;
import software.amazon.awssdk.services.s3.waiters.S3Waiter;
import java.net.URISyntaxException;
// snippet-end:[s3.java2.create_bucket_waiters.import]

/**
 * Before running this Java V2 code example, set up your development environment, including your credentials.
 *
 * For more information, see the following documentation topic:
 *
 * https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-started.html
 */

public class CreateBucket {

    public static void main(String[] args) throws URISyntaxException {

        final String usage = ""\n"" +
            ""Usage:\n"" +
            ""    <bucketName> \n\n"" +
            ""Where:\n"" +
            ""    bucketName - The name of the bucket to create. The bucket name must be unique, or an error occurs.\n\n"" ;

       if (args.length != 1) {
           System.out.println(usage);
           System.exit(1);
       }

        String bucketName = args[0];
        System.out.format(""Creating a bucket named %s\n"", bucketName);
        ProfileCredentialsProvider credentialsProvider = ProfileCredentialsProvider.create();
        Region region = Region.US_EAST_1;
        S3Client s3 = S3Client.builder()
            .region(region)
            .credentialsProvider(credentialsProvider)
            .build();

        createBucket (s3, bucketName);
        s3.close();
    }

    // snippet-start:[s3.java2.create_bucket_waiters.main]
    public static void createBucket( S3Client s3Client, String bucketName) {

        try {
            S3Waiter s3Waiter = s3Client.waiter();
            CreateBucketRequest bucketRequest = CreateBucketRequest.builder()
                .bucket(bucketName)
                .build();

            s3Client.createBucket(bucketRequest);
            HeadBucketRequest bucketRequestWait = HeadBucketRequest.builder()
                .bucket(bucketName)
                .build();

            // Wait until the bucket is created and print out the response.
            WaiterResponse<HeadBucketResponse> waiterResponse = s3Waiter.waitUntilBucketExists(bucketRequestWait);
            waiterResponse.matched().response().ifPresent(System.out::println);
            System.out.println(bucketName +"" is ready"");

        } catch (S3Exception e) {
            System.err.println(e.awsErrorDetails().errorMessage());
            System.exit(1);
        }
    }
    // snippet-end:[s3.java2.create_bucket_waiters.main]
}",       if (args.length != 1) {,StackOverflow
DoNotTerminateVM,System.exit() should not be used in J2EE/JEE apps,"package com.example.s3;

// snippet-start:[s3.java2.create_bucket_waiters.import]
import software.amazon.awssdk.auth.credentials.ProfileCredentialsProvider;
import software.amazon.awssdk.core.waiters.WaiterResponse;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.CreateBucketRequest;
import software.amazon.awssdk.services.s3.model.HeadBucketRequest;
import software.amazon.awssdk.services.s3.model.HeadBucketResponse;
import software.amazon.awssdk.services.s3.model.S3Exception;
import software.amazon.awssdk.services.s3.waiters.S3Waiter;
import java.net.URISyntaxException;
// snippet-end:[s3.java2.create_bucket_waiters.import]

/**
 * Before running this Java V2 code example, set up your development environment, including your credentials.
 *
 * For more information, see the following documentation topic:
 *
 * https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-started.html
 */

public class CreateBucket {

    public static void main(String[] args) throws URISyntaxException {

        final String usage = ""\n"" +
            ""Usage:\n"" +
            ""    <bucketName> \n\n"" +
            ""Where:\n"" +
            ""    bucketName - The name of the bucket to create. The bucket name must be unique, or an error occurs.\n\n"" ;

       if (args.length != 1) {
           System.out.println(usage);
           System.exit(1);
       }

        String bucketName = args[0];
        System.out.format(""Creating a bucket named %s\n"", bucketName);
        ProfileCredentialsProvider credentialsProvider = ProfileCredentialsProvider.create();
        Region region = Region.US_EAST_1;
        S3Client s3 = S3Client.builder()
            .region(region)
            .credentialsProvider(credentialsProvider)
            .build();

        createBucket (s3, bucketName);
        s3.close();
    }

    // snippet-start:[s3.java2.create_bucket_waiters.main]
    public static void createBucket( S3Client s3Client, String bucketName) {

        try {
            S3Waiter s3Waiter = s3Client.waiter();
            CreateBucketRequest bucketRequest = CreateBucketRequest.builder()
                .bucket(bucketName)
                .build();

            s3Client.createBucket(bucketRequest);
            HeadBucketRequest bucketRequestWait = HeadBucketRequest.builder()
                .bucket(bucketName)
                .build();

            // Wait until the bucket is created and print out the response.
            WaiterResponse<HeadBucketResponse> waiterResponse = s3Waiter.waitUntilBucketExists(bucketRequestWait);
            waiterResponse.matched().response().ifPresent(System.out::println);
            System.out.println(bucketName +"" is ready"");

        } catch (S3Exception e) {
            System.err.println(e.awsErrorDetails().errorMessage());
            System.exit(1);
        }
    }
    // snippet-end:[s3.java2.create_bucket_waiters.main]
}",            System.exit(1);,StackOverflow
TestClassWithoutTestCases,"The class 'TestSerialization' might be a test class, but it contains no test cases.","public class Serialization {

    static class TestSerialization  implements Serializable {
        int val = 0;
        public TestSerialization() {
            System.out.println(""constructor"");
            val = 1;
        }

        @Override
        public String toString() {
            return ""val is "" + val;
        }
    }


    public static void main(String[] args) throws IOException, ClassNotFoundException {
        TestSerialization testSerialization = new TestSerialization();

        // constructor
        // val is 1
        System.out.println(testSerialization);

        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(testSerialization);
        oos.close();

        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
        Object obj = ois.readObject();
        // val is 1
        System.out.println(obj);
    }
}

public class Main {

    static class TestClass {
        public int val = 0;

        public TestClass() {
            val = 1;
        }

        @Override
        public String toString() {
            return ""value is "" + val;
        }
    }

    public static void main(String[] args) throws Exception {

        // by constructor
        TestClass obj = new TestClass();
        // value is 1
        System.out.println(obj);

        // by reflect
        Constructor<TestClass> constructor = TestClass.class.getConstructor();
        obj = constructor.newInstance();
        // value is 1
        System.out.println(obj);

        // by ReflectionFactory
        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();
        Constructor<Object> objectConstructor = Object.class.getDeclaredConstructor();
        Constructor<?> targetConstructor = reflectionFactory.newConstructorForSerialization(TestClass.class, objectConstructor);
        obj = (TestClass) targetConstructor.newInstance();
        // value is 0
        System.out.println(obj);
    }
}",    static class TestSerialization  implements Serializable {,StackOverflow
TestClassWithoutTestCases,"The class 'TestClass' might be a test class, but it contains no test cases.","public class Serialization {

    static class TestSerialization  implements Serializable {
        int val = 0;
        public TestSerialization() {
            System.out.println(""constructor"");
            val = 1;
        }

        @Override
        public String toString() {
            return ""val is "" + val;
        }
    }


    public static void main(String[] args) throws IOException, ClassNotFoundException {
        TestSerialization testSerialization = new TestSerialization();

        // constructor
        // val is 1
        System.out.println(testSerialization);

        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(testSerialization);
        oos.close();

        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
        Object obj = ois.readObject();
        // val is 1
        System.out.println(obj);
    }
}

public class Main {

    static class TestClass {
        public int val = 0;

        public TestClass() {
            val = 1;
        }

        @Override
        public String toString() {
            return ""value is "" + val;
        }
    }

    public static void main(String[] args) throws Exception {

        // by constructor
        TestClass obj = new TestClass();
        // value is 1
        System.out.println(obj);

        // by reflect
        Constructor<TestClass> constructor = TestClass.class.getConstructor();
        obj = constructor.newInstance();
        // value is 1
        System.out.println(obj);

        // by ReflectionFactory
        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();
        Constructor<Object> objectConstructor = Object.class.getDeclaredConstructor();
        Constructor<?> targetConstructor = reflectionFactory.newConstructorForSerialization(TestClass.class, objectConstructor);
        obj = (TestClass) targetConstructor.newInstance();
        // value is 0
        System.out.println(obj);
    }
}",    static class TestClass {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class OracleConnectionInvocationHandler implements InvocationHandler {
    private final OracleConnection target;
    private SPELogger systemLog = null;

    public OracleConnectionInvocationHandler(OracleConnection target) {
        systemLog = AppLogger.getInstance();
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (""prepareStatement"".equals(method.getName())) {

            PreparedStatement preparedStatement = (PreparedStatement) method.invoke(target, args);

            systemLog.logInfo(this, ""Making PreparedStatement unwrap through OracleConnectionInvocationHandler"");

            return preparedStatement.unwrap(oracle.jdbc.OraclePreparedStatement.class);

        }

        return method.invoke(target, args);
    }
}","        if (""prepareStatement"".equals(method.getName())) {",StackOverflow
TestClassWithoutTestCases,"The class 'SoundTest' might be a test class, but it contains no test cases.","import javax.sound.sampled.*;
import java.io.IOException;
import java.util.Objects;
import java.util.Scanner;

public class SoundTest {
    public static void main(String[] args) throws LineUnavailableException, IOException, UnsupportedAudioFileException {
        AudioInputStream stream = AudioSystem.getAudioInputStream(
                Objects.requireNonNull(
                        SoundTest.class.getResource(
                                ""tone.wav""
                        )
                )
        );
        AudioFormat format = stream.getFormat();
        DataLine.Info info = new DataLine.Info(Clip.class, format);
        Clip clip = (Clip) AudioSystem.getLine(info);
        clip.open(stream);
        clip.loop(5);
//        clip.start();

        new Scanner(System.in).next(); // to prevent the program from closing immediately
    }
}",public class SoundTest {,StackOverflow
CloseResource,Ensure that resources like this AudioInputStream object are closed after use,"import javax.sound.sampled.*;
import java.io.IOException;
import java.util.Objects;
import java.util.Scanner;

public class SoundTest {
    public static void main(String[] args) throws LineUnavailableException, IOException, UnsupportedAudioFileException {
        AudioInputStream stream = AudioSystem.getAudioInputStream(
                Objects.requireNonNull(
                        SoundTest.class.getResource(
                                ""tone.wav""
                        )
                )
        );
        AudioFormat format = stream.getFormat();
        DataLine.Info info = new DataLine.Info(Clip.class, format);
        Clip clip = (Clip) AudioSystem.getLine(info);
        clip.open(stream);
        clip.loop(5);
//        clip.start();

        new Scanner(System.in).next(); // to prevent the program from closing immediately
    }
}",        AudioInputStream stream = AudioSystem.getAudioInputStream(,StackOverflow
CloseResource,Ensure that resources like this Clip object are closed after use,"import javax.sound.sampled.*;
import java.io.IOException;
import java.util.Objects;
import java.util.Scanner;

public class SoundTest {
    public static void main(String[] args) throws LineUnavailableException, IOException, UnsupportedAudioFileException {
        AudioInputStream stream = AudioSystem.getAudioInputStream(
                Objects.requireNonNull(
                        SoundTest.class.getResource(
                                ""tone.wav""
                        )
                )
        );
        AudioFormat format = stream.getFormat();
        DataLine.Info info = new DataLine.Info(Clip.class, format);
        Clip clip = (Clip) AudioSystem.getLine(info);
        clip.open(stream);
        clip.loop(5);
//        clip.start();

        new Scanner(System.in).next(); // to prevent the program from closing immediately
    }
}",        Clip clip = (Clip) AudioSystem.getLine(info);,StackOverflow
UseLocaleWithCaseConversions,"When doing a String.toLowerCase()/toUpperCase() call, use a Locale","import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class MatchingGameApp extends Application {
    private static final String MATCHED_VALUE = ""X"";
    private static final String[][] animalBoard = {
            { ""cat"", ""ape"" },
            { ""aardvark"", ""dog"" }
    };

    /**
     * Add actionable buttons to a grid.
     *
     * @param board A 2D array of words.
     * @param grid a GridPane to which buttons for each word will be added.
     */
    private void addButtons(String[][] board, GridPane grid) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                final String word = board[i][j];

                final Button button = new Button(word);
                button.setPrefWidth(80);
                button.setOnAction(e -> {
                    if (isRequiredWord(word)) {
                        button.setText(MATCHED_VALUE);
                    }
                });

                grid.add(button, i, j);
            }
        }
    }

    /**
     * A required word is any word starting with a letter ""a"" in any case.
     */
    public boolean isRequiredWord(String word) {
        return word != null && !word.isEmpty() &&
                word
                        .substring(0, 1)
                        .toLowerCase()
                        .startsWith(""a"");
    }

    @Override
    public void start(Stage stage) {
        GridPane layout = new GridPane(10, 10);
        layout.setPadding(new Insets(10));

        addButtons(animalBoard, layout);

        stage.setScene(new Scene(layout));
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}","                word
                        .substring(0, 1)
                        .toLowerCase()",StackOverflow
AvoidFieldNameMatchingMethodName,Field isVisited has the same name as a method,"public class Node {
    private String element;
    private List<Node> neighbours;
    private boolean isVisited;
    
    public Node(String element, List<Node> neighbours) {
        this.element = element;
        this.neighbours = neighbours;
    }
    
    public void setVisited(boolean visited) {
        isVisited = visited;
    }
    
    public boolean isVisited() {
        return isVisited;
    }
    
    public void addNeighbours(Node neighbour) {
        neighbours.add(neighbour);
    }
    
    public String getElement() {
        return element;
    }
    
    public List<Node> getNeighbours() {
        return neighbours;
    }
}",    private boolean isVisited;,StackOverflow
TestClassWithoutTestCases,"The class 'Tester' might be a test class, but it contains no test cases.","import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

import java.util.stream.Stream;

public class Tester extends Application {
    private static final int WIDTH = 300;
    private static final int HEIGHT = 400;

    @Override
    public void start(Stage stage) {
        GridPane pane = new GridPane();
        pane.setGridLinesVisible(true);
        pane.setAlignment(Pos.TOP_LEFT);
        pane.setHgap(10);
        pane.setVgap(10);
        pane.setPadding(new Insets(10, 10, 10, 10));

        Button cat = new Button(""cat"");
        Button monkey = new Button(""monkey"");
        Button elephant = new Button(""elephant and lion"");
        pane.add(cat, 0, 0);
        pane.add(monkey, 0, 1);
        pane.add(elephant, 0, 2);

        Stream.of(cat, monkey, elephant).forEach(btn -> btn.setMaxWidth(Double.POSITIVE_INFINITY));

        Scene scene = new Scene(pane, WIDTH, HEIGHT);
        stage.setScene(scene);
        stage.show();
    }
}",public class Tester extends Application {,StackOverflow
CloseResource,Ensure that resources like this InputStream object are closed after use,"import java.io.*;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.*;

import org.apache.poi.util.IOUtils;
import org.apache.poi.ss.util.ImageUtils;

import org.apache.poi.openxml4j.opc.*;
import org.apache.poi.ooxml.POIXMLDocumentPart;

import org.apache.xmlbeans.XmlObject;

import static org.apache.poi.ooxml.POIXMLTypeLoader.DEFAULT_XML_OPTIONS;

public class CreateExcelPictureInHeader {

 static void createPictureForHeader(XSSFSheet sheet, int pictureIdx, String pictureTitle, int vmlIdx, String headerPos, double scale) throws Exception {
  OPCPackage opcpackage = sheet.getWorkbook().getPackage();

  //creating /xl/drawings/vmlDrawing1.vml
  PackagePartName partname = PackagingURIHelper.createPartName(""/xl/drawings/vmlDrawing"" + vmlIdx+ "".vml"");
  PackagePart part = opcpackage.createPart(partname, ""application/vnd.openxmlformats-officedocument.vmlDrawing"");
  //creating new VmlDrawing
  VmlDrawing vmldrawing = new VmlDrawing(part);

  //creating the relation to the picture in /xl/drawings/_rels/vmlDrawing1.vml.rels
  XSSFPictureData picData = sheet.getWorkbook().getAllPictures().get(pictureIdx);
  String rIdPic = vmldrawing.addRelation(null, XSSFRelation.IMAGES, picData).getRelationship().getId();

  //get image dimension
  ByteArrayInputStream is = new ByteArrayInputStream(picData.getData());
  java.awt.Dimension imageDimension = ImageUtils.getImageDimension(is, picData.getPictureType());
  is.close();
  
  //scale image dimension
  imageDimension.setSize(imageDimension.getWidth() * scale, imageDimension.getHeight() * scale);

  //updating the VmlDrawing
  vmldrawing.setRIdPic(rIdPic);
  vmldrawing.setPictureTitle(pictureTitle);
  vmldrawing.setImageDimension(imageDimension);
  vmldrawing.setHeaderPos(headerPos);

  //creating the relation to /xl/drawings/vmlDrawing1.xml in /xl/worksheets/_rels/sheet1.xml.rels
  String rIdExtLink = sheet.addRelation(null, XSSFRelation.VML_DRAWINGS, vmldrawing).getRelationship().getId();

  //creating the <legacyDrawingHF r:id=""...""/> in /xl/worksheets/sheetN.xml
  sheet.getCTWorksheet().addNewLegacyDrawingHF().setId(rIdExtLink);

 }

 public static void main(String[] args) throws Exception {

  Workbook workbook = new XSSFWorkbook();

  Sheet sheet;
  Header header;
  InputStream is;
  byte[] bytes;

  int pictureIdx; //we need it later

  sheet = workbook.createSheet();
  
  sheet.createRow(0).createCell(0).setCellValue(""A1"");

  header = sheet.getHeader();
  header.setRight(""&G""); // &G means Graphic

  //add picture data to this workbook
  is = new FileInputStream(""./logo.png"");
  bytes = IOUtils.toByteArray(is);
  pictureIdx = workbook.addPicture(bytes, Workbook.PICTURE_TYPE_PNG);
  is.close();

  //create header picture from picture data of this workbook
  createPictureForHeader((XSSFSheet)sheet, pictureIdx, ""logo"", 1, ""RH""/*RightHeader*/, 0.5d);

  FileOutputStream out = new FileOutputStream(""CreateExcelPictureInHeader.xlsx"");
  workbook.write(out);
  out.close();
  workbook.close();    
 }

 //class for VmlDrawing
 static class VmlDrawing extends POIXMLDocumentPart {

  String rIdPic = """";
  String pictureTitle = """";
  java.awt.Dimension imageDimension = null;
  String headerPos = """";

  VmlDrawing(PackagePart part) {
   super(part);
  }

  void setRIdPic(String rIdPic) {
   this.rIdPic = rIdPic;
  }

  void setPictureTitle(String pictureTitle) {
   this.pictureTitle = pictureTitle;
  }

  void setHeaderPos(String headerPos) {
   this.headerPos = headerPos;
  }

  void setImageDimension(java.awt.Dimension imageDimension) {
   this.imageDimension = imageDimension;
  }

  @Override
  protected void commit() throws IOException {
   PackagePart part = getPackagePart();
   OutputStream out = part.getOutputStream();
   try {
    XmlObject doc = XmlObject.Factory.parse(

      ""<xml xmlns:v=\""urn:schemas-microsoft-com:vml\""""
     +"" xmlns:o=\""urn:schemas-microsoft-com:office:office\""""
     +"" xmlns:x=\""urn:schemas-microsoft-com:office:excel\"">""
     +"" <o:shapelayout v:ext=\""edit\"">""
     +""  <o:idmap v:ext=\""edit\"" data=\""1\""/>""
     +"" </o:shapelayout><v:shapetype id=\""_x0000_t75\"" coordsize=\""21600,21600\"" o:spt=\""75\""""
     +""  o:preferrelative=\""t\"" path=\""m@4@5l@4@11@9@11@9@5xe\"" filled=\""f\"" stroked=\""f\"">""
     +""  <v:stroke joinstyle=\""miter\""/>""
     +""  <v:formulas>""
     +""   <v:f eqn=\""if lineDrawn pixelLineWidth 0\""/>""
     +""   <v:f eqn=\""sum @0 1 0\""/>""
     +""   <v:f eqn=\""sum 0 0 @1\""/>""
     +""   <v:f eqn=\""prod @2 1 2\""/>""
     +""   <v:f eqn=\""prod @3 21600 pixelWidth\""/>""
     +""   <v:f eqn=\""prod @3 21600 pixelHeight\""/>""
     +""   <v:f eqn=\""sum @0 0 1\""/>""
     +""   <v:f eqn=\""prod @6 1 2\""/>""
     +""   <v:f eqn=\""prod @7 21600 pixelWidth\""/>""
     +""   <v:f eqn=\""sum @8 21600 0\""/>""
     +""   <v:f eqn=\""prod @7 21600 pixelHeight\""/>""
     +""   <v:f eqn=\""sum @10 21600 0\""/>""
     +""  </v:formulas>""
     +""  <v:path o:extrusionok=\""f\"" gradientshapeok=\""t\"" o:connecttype=\""rect\""/>""
     +""  <o:lock v:ext=\""edit\"" aspectratio=\""t\""/>""
     +"" </v:shapetype><v:shape id=\"""" + headerPos + ""\"" o:spid=\""_x0000_s1025\"" type=\""#_x0000_t75\""""
     +""  style='position:absolute;margin-left:0;margin-top:0;""
     +""width:"" + (int)imageDimension.getWidth() + ""px;height:"" + (int)imageDimension.getHeight() + ""px;""
     +""z-index:1'>""
     +""  <v:imagedata o:relid=\""""+ rIdPic + ""\"" o:title=\"""" + pictureTitle + ""\""/>""
     +""  <o:lock v:ext=\""edit\"" rotation=\""t\""/>""
     +"" </v:shape></xml>""

    );
    doc.save(out, DEFAULT_XML_OPTIONS);
    out.close();
   } catch (Exception ex) {
    ex.printStackTrace();
   }
  }

 }

}",  InputStream is;,StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.*;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.*;

import org.apache.poi.util.IOUtils;
import org.apache.poi.ss.util.ImageUtils;

import org.apache.poi.openxml4j.opc.*;
import org.apache.poi.ooxml.POIXMLDocumentPart;

import org.apache.xmlbeans.XmlObject;

import static org.apache.poi.ooxml.POIXMLTypeLoader.DEFAULT_XML_OPTIONS;

public class CreateExcelPictureInHeader {

 static void createPictureForHeader(XSSFSheet sheet, int pictureIdx, String pictureTitle, int vmlIdx, String headerPos, double scale) throws Exception {
  OPCPackage opcpackage = sheet.getWorkbook().getPackage();

  //creating /xl/drawings/vmlDrawing1.vml
  PackagePartName partname = PackagingURIHelper.createPartName(""/xl/drawings/vmlDrawing"" + vmlIdx+ "".vml"");
  PackagePart part = opcpackage.createPart(partname, ""application/vnd.openxmlformats-officedocument.vmlDrawing"");
  //creating new VmlDrawing
  VmlDrawing vmldrawing = new VmlDrawing(part);

  //creating the relation to the picture in /xl/drawings/_rels/vmlDrawing1.vml.rels
  XSSFPictureData picData = sheet.getWorkbook().getAllPictures().get(pictureIdx);
  String rIdPic = vmldrawing.addRelation(null, XSSFRelation.IMAGES, picData).getRelationship().getId();

  //get image dimension
  ByteArrayInputStream is = new ByteArrayInputStream(picData.getData());
  java.awt.Dimension imageDimension = ImageUtils.getImageDimension(is, picData.getPictureType());
  is.close();
  
  //scale image dimension
  imageDimension.setSize(imageDimension.getWidth() * scale, imageDimension.getHeight() * scale);

  //updating the VmlDrawing
  vmldrawing.setRIdPic(rIdPic);
  vmldrawing.setPictureTitle(pictureTitle);
  vmldrawing.setImageDimension(imageDimension);
  vmldrawing.setHeaderPos(headerPos);

  //creating the relation to /xl/drawings/vmlDrawing1.xml in /xl/worksheets/_rels/sheet1.xml.rels
  String rIdExtLink = sheet.addRelation(null, XSSFRelation.VML_DRAWINGS, vmldrawing).getRelationship().getId();

  //creating the <legacyDrawingHF r:id=""...""/> in /xl/worksheets/sheetN.xml
  sheet.getCTWorksheet().addNewLegacyDrawingHF().setId(rIdExtLink);

 }

 public static void main(String[] args) throws Exception {

  Workbook workbook = new XSSFWorkbook();

  Sheet sheet;
  Header header;
  InputStream is;
  byte[] bytes;

  int pictureIdx; //we need it later

  sheet = workbook.createSheet();
  
  sheet.createRow(0).createCell(0).setCellValue(""A1"");

  header = sheet.getHeader();
  header.setRight(""&G""); // &G means Graphic

  //add picture data to this workbook
  is = new FileInputStream(""./logo.png"");
  bytes = IOUtils.toByteArray(is);
  pictureIdx = workbook.addPicture(bytes, Workbook.PICTURE_TYPE_PNG);
  is.close();

  //create header picture from picture data of this workbook
  createPictureForHeader((XSSFSheet)sheet, pictureIdx, ""logo"", 1, ""RH""/*RightHeader*/, 0.5d);

  FileOutputStream out = new FileOutputStream(""CreateExcelPictureInHeader.xlsx"");
  workbook.write(out);
  out.close();
  workbook.close();    
 }

 //class for VmlDrawing
 static class VmlDrawing extends POIXMLDocumentPart {

  String rIdPic = """";
  String pictureTitle = """";
  java.awt.Dimension imageDimension = null;
  String headerPos = """";

  VmlDrawing(PackagePart part) {
   super(part);
  }

  void setRIdPic(String rIdPic) {
   this.rIdPic = rIdPic;
  }

  void setPictureTitle(String pictureTitle) {
   this.pictureTitle = pictureTitle;
  }

  void setHeaderPos(String headerPos) {
   this.headerPos = headerPos;
  }

  void setImageDimension(java.awt.Dimension imageDimension) {
   this.imageDimension = imageDimension;
  }

  @Override
  protected void commit() throws IOException {
   PackagePart part = getPackagePart();
   OutputStream out = part.getOutputStream();
   try {
    XmlObject doc = XmlObject.Factory.parse(

      ""<xml xmlns:v=\""urn:schemas-microsoft-com:vml\""""
     +"" xmlns:o=\""urn:schemas-microsoft-com:office:office\""""
     +"" xmlns:x=\""urn:schemas-microsoft-com:office:excel\"">""
     +"" <o:shapelayout v:ext=\""edit\"">""
     +""  <o:idmap v:ext=\""edit\"" data=\""1\""/>""
     +"" </o:shapelayout><v:shapetype id=\""_x0000_t75\"" coordsize=\""21600,21600\"" o:spt=\""75\""""
     +""  o:preferrelative=\""t\"" path=\""m@4@5l@4@11@9@11@9@5xe\"" filled=\""f\"" stroked=\""f\"">""
     +""  <v:stroke joinstyle=\""miter\""/>""
     +""  <v:formulas>""
     +""   <v:f eqn=\""if lineDrawn pixelLineWidth 0\""/>""
     +""   <v:f eqn=\""sum @0 1 0\""/>""
     +""   <v:f eqn=\""sum 0 0 @1\""/>""
     +""   <v:f eqn=\""prod @2 1 2\""/>""
     +""   <v:f eqn=\""prod @3 21600 pixelWidth\""/>""
     +""   <v:f eqn=\""prod @3 21600 pixelHeight\""/>""
     +""   <v:f eqn=\""sum @0 0 1\""/>""
     +""   <v:f eqn=\""prod @6 1 2\""/>""
     +""   <v:f eqn=\""prod @7 21600 pixelWidth\""/>""
     +""   <v:f eqn=\""sum @8 21600 0\""/>""
     +""   <v:f eqn=\""prod @7 21600 pixelHeight\""/>""
     +""   <v:f eqn=\""sum @10 21600 0\""/>""
     +""  </v:formulas>""
     +""  <v:path o:extrusionok=\""f\"" gradientshapeok=\""t\"" o:connecttype=\""rect\""/>""
     +""  <o:lock v:ext=\""edit\"" aspectratio=\""t\""/>""
     +"" </v:shapetype><v:shape id=\"""" + headerPos + ""\"" o:spid=\""_x0000_s1025\"" type=\""#_x0000_t75\""""
     +""  style='position:absolute;margin-left:0;margin-top:0;""
     +""width:"" + (int)imageDimension.getWidth() + ""px;height:"" + (int)imageDimension.getHeight() + ""px;""
     +""z-index:1'>""
     +""  <v:imagedata o:relid=\""""+ rIdPic + ""\"" o:title=\"""" + pictureTitle + ""\""/>""
     +""  <o:lock v:ext=\""edit\"" rotation=\""t\""/>""
     +"" </v:shape></xml>""

    );
    doc.save(out, DEFAULT_XML_OPTIONS);
    out.close();
   } catch (Exception ex) {
    ex.printStackTrace();
   }
  }

 }

}","  FileOutputStream out = new FileOutputStream(""CreateExcelPictureInHeader.xlsx"");",StackOverflow
CloseResource,Ensure that resources like this OutputStream object are closed after use,"import java.io.*;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.*;

import org.apache.poi.util.IOUtils;
import org.apache.poi.ss.util.ImageUtils;

import org.apache.poi.openxml4j.opc.*;
import org.apache.poi.ooxml.POIXMLDocumentPart;

import org.apache.xmlbeans.XmlObject;

import static org.apache.poi.ooxml.POIXMLTypeLoader.DEFAULT_XML_OPTIONS;

public class CreateExcelPictureInHeader {

 static void createPictureForHeader(XSSFSheet sheet, int pictureIdx, String pictureTitle, int vmlIdx, String headerPos, double scale) throws Exception {
  OPCPackage opcpackage = sheet.getWorkbook().getPackage();

  //creating /xl/drawings/vmlDrawing1.vml
  PackagePartName partname = PackagingURIHelper.createPartName(""/xl/drawings/vmlDrawing"" + vmlIdx+ "".vml"");
  PackagePart part = opcpackage.createPart(partname, ""application/vnd.openxmlformats-officedocument.vmlDrawing"");
  //creating new VmlDrawing
  VmlDrawing vmldrawing = new VmlDrawing(part);

  //creating the relation to the picture in /xl/drawings/_rels/vmlDrawing1.vml.rels
  XSSFPictureData picData = sheet.getWorkbook().getAllPictures().get(pictureIdx);
  String rIdPic = vmldrawing.addRelation(null, XSSFRelation.IMAGES, picData).getRelationship().getId();

  //get image dimension
  ByteArrayInputStream is = new ByteArrayInputStream(picData.getData());
  java.awt.Dimension imageDimension = ImageUtils.getImageDimension(is, picData.getPictureType());
  is.close();
  
  //scale image dimension
  imageDimension.setSize(imageDimension.getWidth() * scale, imageDimension.getHeight() * scale);

  //updating the VmlDrawing
  vmldrawing.setRIdPic(rIdPic);
  vmldrawing.setPictureTitle(pictureTitle);
  vmldrawing.setImageDimension(imageDimension);
  vmldrawing.setHeaderPos(headerPos);

  //creating the relation to /xl/drawings/vmlDrawing1.xml in /xl/worksheets/_rels/sheet1.xml.rels
  String rIdExtLink = sheet.addRelation(null, XSSFRelation.VML_DRAWINGS, vmldrawing).getRelationship().getId();

  //creating the <legacyDrawingHF r:id=""...""/> in /xl/worksheets/sheetN.xml
  sheet.getCTWorksheet().addNewLegacyDrawingHF().setId(rIdExtLink);

 }

 public static void main(String[] args) throws Exception {

  Workbook workbook = new XSSFWorkbook();

  Sheet sheet;
  Header header;
  InputStream is;
  byte[] bytes;

  int pictureIdx; //we need it later

  sheet = workbook.createSheet();
  
  sheet.createRow(0).createCell(0).setCellValue(""A1"");

  header = sheet.getHeader();
  header.setRight(""&G""); // &G means Graphic

  //add picture data to this workbook
  is = new FileInputStream(""./logo.png"");
  bytes = IOUtils.toByteArray(is);
  pictureIdx = workbook.addPicture(bytes, Workbook.PICTURE_TYPE_PNG);
  is.close();

  //create header picture from picture data of this workbook
  createPictureForHeader((XSSFSheet)sheet, pictureIdx, ""logo"", 1, ""RH""/*RightHeader*/, 0.5d);

  FileOutputStream out = new FileOutputStream(""CreateExcelPictureInHeader.xlsx"");
  workbook.write(out);
  out.close();
  workbook.close();    
 }

 //class for VmlDrawing
 static class VmlDrawing extends POIXMLDocumentPart {

  String rIdPic = """";
  String pictureTitle = """";
  java.awt.Dimension imageDimension = null;
  String headerPos = """";

  VmlDrawing(PackagePart part) {
   super(part);
  }

  void setRIdPic(String rIdPic) {
   this.rIdPic = rIdPic;
  }

  void setPictureTitle(String pictureTitle) {
   this.pictureTitle = pictureTitle;
  }

  void setHeaderPos(String headerPos) {
   this.headerPos = headerPos;
  }

  void setImageDimension(java.awt.Dimension imageDimension) {
   this.imageDimension = imageDimension;
  }

  @Override
  protected void commit() throws IOException {
   PackagePart part = getPackagePart();
   OutputStream out = part.getOutputStream();
   try {
    XmlObject doc = XmlObject.Factory.parse(

      ""<xml xmlns:v=\""urn:schemas-microsoft-com:vml\""""
     +"" xmlns:o=\""urn:schemas-microsoft-com:office:office\""""
     +"" xmlns:x=\""urn:schemas-microsoft-com:office:excel\"">""
     +"" <o:shapelayout v:ext=\""edit\"">""
     +""  <o:idmap v:ext=\""edit\"" data=\""1\""/>""
     +"" </o:shapelayout><v:shapetype id=\""_x0000_t75\"" coordsize=\""21600,21600\"" o:spt=\""75\""""
     +""  o:preferrelative=\""t\"" path=\""m@4@5l@4@11@9@11@9@5xe\"" filled=\""f\"" stroked=\""f\"">""
     +""  <v:stroke joinstyle=\""miter\""/>""
     +""  <v:formulas>""
     +""   <v:f eqn=\""if lineDrawn pixelLineWidth 0\""/>""
     +""   <v:f eqn=\""sum @0 1 0\""/>""
     +""   <v:f eqn=\""sum 0 0 @1\""/>""
     +""   <v:f eqn=\""prod @2 1 2\""/>""
     +""   <v:f eqn=\""prod @3 21600 pixelWidth\""/>""
     +""   <v:f eqn=\""prod @3 21600 pixelHeight\""/>""
     +""   <v:f eqn=\""sum @0 0 1\""/>""
     +""   <v:f eqn=\""prod @6 1 2\""/>""
     +""   <v:f eqn=\""prod @7 21600 pixelWidth\""/>""
     +""   <v:f eqn=\""sum @8 21600 0\""/>""
     +""   <v:f eqn=\""prod @7 21600 pixelHeight\""/>""
     +""   <v:f eqn=\""sum @10 21600 0\""/>""
     +""  </v:formulas>""
     +""  <v:path o:extrusionok=\""f\"" gradientshapeok=\""t\"" o:connecttype=\""rect\""/>""
     +""  <o:lock v:ext=\""edit\"" aspectratio=\""t\""/>""
     +"" </v:shapetype><v:shape id=\"""" + headerPos + ""\"" o:spid=\""_x0000_s1025\"" type=\""#_x0000_t75\""""
     +""  style='position:absolute;margin-left:0;margin-top:0;""
     +""width:"" + (int)imageDimension.getWidth() + ""px;height:"" + (int)imageDimension.getHeight() + ""px;""
     +""z-index:1'>""
     +""  <v:imagedata o:relid=\""""+ rIdPic + ""\"" o:title=\"""" + pictureTitle + ""\""/>""
     +""  <o:lock v:ext=\""edit\"" rotation=\""t\""/>""
     +"" </v:shape></xml>""

    );
    doc.save(out, DEFAULT_XML_OPTIONS);
    out.close();
   } catch (Exception ex) {
    ex.printStackTrace();
   }
  }

 }

}",   OutputStream out = part.getOutputStream();,StackOverflow
TestClassWithoutTestCases,"The class 'TestArrayPrint' might be a test class, but it contains no test cases.","public class TestArrayPrint {

    static List<Integer>[] list =  new ArrayList[5];
    static List<String> result = new ArrayList<String>();
    public static void main(String[] args) 
    {
        //dummy values 
        for(int i=0;i<list.length;i++)
        {
            list[i] = IntStream.rangeClosed(1, 25).boxed().collect(Collectors.toList());
            Collections.shuffle(list[i]);
        }
        //populate list[0] from array
    
        int dummy_arr[][] = {{1,2,3,4,5},
                             {6,7,8,9,10},
                             {11,12,13,14,15},
                             {16,17,18,19,20},
                             {21,22,23,24,25}};
        list[0].clear();
        for(int i=0;i<dummy_arr.length;i++)
        {
            for (int j=0;j<dummy_arr[i].length;j++)
            {
                list[0].add(dummy_arr[i][j]);
            }
        }
        //full scan
        for(int k=0;k<list.length;k++)
        {
            //next line
            for(int i=0;i<list.length;i++)
            {
                //add first line from first list, then first line from second list, etc
                for(int j=0;j<list.length;j++)
                {
                    //covert to 2 string digits for display 
                    String s= (list[i].get(0)<10) ? "" ""+list[i].get(0) : list[i].get(0).toString() ;
                    list[i].remove(0);
                    //elements will be in order 
                    //Line1List1 Line1List2 ...
                    //Line2List1 Line2List2 ...
                    result.add(s);
                }
            }
        }
        //result.forEach(System.out::println);
        System.out.println(""Ordered Elements to Display=""+result.size()+""\n"");
        
        //display
        //just adapt i,j,k for various matrix sizes
        for(int i=0;i<5;i++)
        {
            StringBuffer line = new StringBuffer();
            for(int j=0;j<5;j++)
            {
                for(int k=0;k<5;k++)
                {
                    if(k==0)
                    {
                        line.append(""| ""+result.get(0));
                        result.remove(0);
                    }
                    else if(k==4)
                    {
                        line.append("" ""+result.get(0)+"" |"");
                        result.remove(0);
                    }
                    
                    else
                    {
                        line.append("" ""+result.get(0));
                        result.remove(0);
                    }
                }
            }
            System.out.println(line);
        }   
    }
}",public class TestArrayPrint {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class TestArrayPrint {

    static List<Integer>[] list =  new ArrayList[5];
    static List<String> result = new ArrayList<String>();
    public static void main(String[] args) 
    {
        //dummy values 
        for(int i=0;i<list.length;i++)
        {
            list[i] = IntStream.rangeClosed(1, 25).boxed().collect(Collectors.toList());
            Collections.shuffle(list[i]);
        }
        //populate list[0] from array
    
        int dummy_arr[][] = {{1,2,3,4,5},
                             {6,7,8,9,10},
                             {11,12,13,14,15},
                             {16,17,18,19,20},
                             {21,22,23,24,25}};
        list[0].clear();
        for(int i=0;i<dummy_arr.length;i++)
        {
            for (int j=0;j<dummy_arr[i].length;j++)
            {
                list[0].add(dummy_arr[i][j]);
            }
        }
        //full scan
        for(int k=0;k<list.length;k++)
        {
            //next line
            for(int i=0;i<list.length;i++)
            {
                //add first line from first list, then first line from second list, etc
                for(int j=0;j<list.length;j++)
                {
                    //covert to 2 string digits for display 
                    String s= (list[i].get(0)<10) ? "" ""+list[i].get(0) : list[i].get(0).toString() ;
                    list[i].remove(0);
                    //elements will be in order 
                    //Line1List1 Line1List2 ...
                    //Line2List1 Line2List2 ...
                    result.add(s);
                }
            }
        }
        //result.forEach(System.out::println);
        System.out.println(""Ordered Elements to Display=""+result.size()+""\n"");
        
        //display
        //just adapt i,j,k for various matrix sizes
        for(int i=0;i<5;i++)
        {
            StringBuffer line = new StringBuffer();
            for(int j=0;j<5;j++)
            {
                for(int k=0;k<5;k++)
                {
                    if(k==0)
                    {
                        line.append(""| ""+result.get(0));
                        result.remove(0);
                    }
                    else if(k==4)
                    {
                        line.append("" ""+result.get(0)+"" |"");
                        result.remove(0);
                    }
                    
                    else
                    {
                        line.append("" ""+result.get(0));
                        result.remove(0);
                    }
                }
            }
            System.out.println(line);
        }   
    }
}",                    else if(k==4),StackOverflow
AvoidCatchingThrowable,A catch statement should never catch throwable since it includes errors.,"import java.util.stream.*;
import static java.util.stream.Collectors.*;
import java.util.*;

public class Grouping {
    public static void main(String[] args) {
        try {
            List<String> l1 = List.of(""foo"", ""bar"");
            List<String> l2 = List.of(""goo"", ""car"");
            List<String> l3 = List.of(""boo"", ""par"");
            List<String> l4 = List.of(""loo"", ""tar"");

            Map<String, List<String>> mapped = Map.of(
                    ""a.1"", l1,
                    ""a.2"", l2,
                    ""b.1"", l3,
                    ""b.2"", l4);

            Map<String, List<List<String>>> grouped = mapped.entrySet().
                stream().
                collect(groupingBy(e ->e.getKey().substring(0, 1), mapping(e ->e.getValue(), toList())));
            System.out.println(grouped);
        }
        catch(Throwable t) {
            t.printStackTrace();
        }
    }
}",        catch(Throwable t) {,StackOverflow
TestClassWithoutTestCases,"The class 'TestConfig' might be a test class, but it contains no test cases.","@TestConfiguration
public class TestConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.H2)
                .addScript(""schema-h2.sql"")
                .build();
    }

    @Bean
    public MybatisSqlSessionFactoryBean mybatisSqlSessionFactoryBean(DataSource dataSource) {
        MybatisSqlSessionFactoryBean sessionFactory = new MybatisSqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);

        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        configuration.setMapUnderscoreToCamelCase(true);

        sessionFactory.setConfiguration(configuration);

        Resource[] mapperLocations = new PathMatchingResourcePatternResolver()
                .getResources(""classpath:mapper/*.xml"");

        sessionFactory.setMapperLocations(mapperLocations);
        return sessionFactory;
    }

    @Primary
    @Bean
    public DataSourceInitializer dataSourceInitializer(DataSource dataSource) {
        ResourceDatabasePopulator resourceDatabasePopulator = new ResourceDatabasePopulator();
        resourceDatabasePopulator.addScript(new ClassPathResource(""schema-h2.sql""));

        DataSourceInitializer dataSourceInitializer = new DataSourceInitializer();
        dataSourceInitializer.setDataSource(dataSource);
        dataSourceInitializer.setDatabasePopulator(resourceDatabasePopulator);

        return dataSourceInitializer;
    }

    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);

        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        configuration.setMapUnderscoreToCamelCase(true);

        sessionFactory.setConfiguration(configuration);

        Resource[] mapperLocations = new PathMatchingResourcePatternResolver()
                .getResources(""classpath:mapper/*.xml"");

        sessionFactory.setMapperLocations(mapperLocations);
        return sessionFactory.getObject();
    }
}",public class TestConfig {,StackOverflow
AvoidDuplicateLiterals,"The String literal ""#00FFFF"" appears 9 times in this file; the first occurrence is on line 20","import javax.swing.*;
import java.awt.*;

public class withUIM {
    private static final JTextArea pad = new JTextArea();
    private static JLabel statusBar = new JLabel(""||       Ln 1, Col 1  "", JLabel.RIGHT);
    private static JFrame f = new JFrame(""Overriding UIManager"");

    public static void main(String[] args) {
        try {
            UIManager.setLookAndFeel(""com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel"");
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f.setSize(600, 600);
        f.setBackground(Color.decode(""#00FF00""));
        statusBar.setOpaque(true);
        statusBar.setBackground(Color.decode(""#00FFFF""));
        statusBar.setForeground(Color.BLACK);
        f.add(new JScrollPane(pad), BorderLayout.CENTER);
        f.add(statusBar, BorderLayout.SOUTH);
        JLabel dummy = new JLabel(""  "");
        dummy.setOpaque(true);
        dummy.setBackground(Color.decode(""#00FFFF""));
        JLabel dummy1 = new JLabel(""  "");
        dummy1.setOpaque(true);
        dummy1.setBackground(Color.decode(""#00FFFF""));
        f.add(dummy, BorderLayout.EAST);
        f.add(dummy1, BorderLayout.WEST);
        JMenuBar mb = new JMenuBar();
        mb.setBackground(Color.decode(""#00FFFF""));
        JMenu fileMenu = new JMenu(""file"");
        fileMenu.setBackground(Color.decode(""#00FFFF""));
        JMenu editMenu = new JMenu(""edit"");
        editMenu.setBackground(Color.decode(""#00FFFF""));
        JMenu formatMenu = new JMenu(""format"");
        formatMenu.setBackground(Color.decode(""#00FFFF""));
        JMenu viewMenu = new JMenu(""view"");
        viewMenu.setBackground(Color.decode(""#00FFFF""));
        JMenu helpMenu = new JMenu(""help"");
        helpMenu.setBackground(Color.decode(""#00FFFF""));
        mb.add(fileMenu);
        mb.add(editMenu);
        mb.add(formatMenu);
        mb.add(viewMenu);
        mb.add(helpMenu);
        f.add(mb, BorderLayout.NORTH);
        f.setVisible(true);
    }
}","        statusBar.setBackground(Color.decode(""#00FFFF""));",StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}",public class MainWindow extends JFrame implements ActionListener {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.setLayout(LayoutManager) ,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}",        setLayout(new BorderLayout());,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.setDefaultCloseOperation(int) ,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}",        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);,StackOverflow
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}","        add(button, BorderLayout.PAGE_START);",StackOverflow
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}","        add(center, BorderLayout.CENTER);",StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.pack() ,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}",        pack();,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setLocationRelativeTo(Component) ,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}",        setLocationRelativeTo(null);,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setVisible(boolean) ,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}",        setVisible(true);,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class MainWindow extends JFrame implements ActionListener {

    DrawPanel dp;

    public static void main(String[] args) {
        new MainWindow();
    }

    public MainWindow() {
        super(""Graphics Test"");
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(""Redraw"");
        button.addActionListener(this);
        add(button, BorderLayout.PAGE_START);

        JPanel center = new JPanel(new FlowLayout());
        dp = new DrawPanel();
        center.add(dp);
        add(center, BorderLayout.CENTER);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        dp.drawOnImage = (e.getModifiers() & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK;
        dp.repaint();
    }
}

class DrawPanel extends JComponent {

    boolean drawOnImage = false;

    public DrawPanel() {
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(400, 400);
    }

    @Override
    public void paint(Graphics gr) {
        Graphics2D g = (Graphics2D) gr;

        if (drawOnImage) {
            ScaledBufferedImage bi = new ScaledBufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB, Math.sqrt(g.getTransform().getDeterminant()));
            Graphics2D imgG = bi.createGraphics();
            imgG.setRenderingHints(g.getRenderingHints());
            paintImage(imgG);
            imgG.dispose();

            g.drawImage(bi, 0, 0, getSize().width, getSize().height,
                    0, 0, bi.getWidth(), bi.getHeight(), null);
        } else {
            paintImage(g);
        }
    }

    private void paintImage(Graphics2D g) {
        Font font = new Font(""SansSerif"", Font.BOLD, 36);
        g.setFont(font);
        g.setColor(Color.BLACK);
        g.drawString(""Test String"", 5, 40);
        g.setStroke(new BasicStroke(6.0001f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0f, null, 0f));
        g.drawRect(100, 70, 100, 100);
        font = new Font(""SansSerif"", Font.PLAIN, 16);
        g.setFont(font);
        g.drawString(""More Text to test the resolution"", 5, 200);

        Rectangle rect2 = new Rectangle(300, 40, 100, 100);
        g.rotate(Math.toRadians(45));
        g.draw(rect2);
    }
}

class ScaledBufferedImage extends BufferedImage {
    final int virtualWidth, virtualHeight;
    final double scaleFactor;

    public ScaledBufferedImage(int width, int height, int imageType, double scaleFactor) {
        super( (int) Math.round(width * scaleFactor), (int) Math.round(height * scaleFactor), imageType);
        virtualHeight = height;
        virtualWidth = width;
        this.scaleFactor = scaleFactor;
    }

    public Graphics2D createGraphics() {
        Graphics2D returnValue = super.createGraphics();
        returnValue.scale(scaleFactor, scaleFactor);
        return returnValue;
    }
}",class DrawPanel extends JComponent {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"// package sometest;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.AffineTransform;
import javax.swing.*;

public class SomeTest2 {
  public JComponent makeUI() {
    Visualization v = new Visualization();

    MouseAdapter mouseAdapter = new DragScrollListener();
    v.addMouseListener(mouseAdapter);
    v.addMouseMotionListener(mouseAdapter);

    JButton in = new JButton(""Zoom In"");
    in.addActionListener(e -> v.setZoomFactor(1.1));

    JButton out = new JButton(""Zoom Out"");
    out.addActionListener(e -> v.setZoomFactor(1 / 1.1));

    JMenuBar mb = new JMenuBar();
    mb.add(in);
    mb.add(out);
    EventQueue.invokeLater(() -> v.getRootPane().setJMenuBar(mb));
    return new JScrollPane(v);
  }

  public static void main(String[] args) {
    EventQueue.invokeLater(() -> {
      JFrame f = new JFrame();
      f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
      f.getContentPane().add(new SomeTest2().makeUI());
      f.setSize(640, 480);
      f.setLocationRelativeTo(null);
      f.setVisible(true);
    });
  }
}

class Visualization extends JPanel {
  private final AffineTransform zoomTransform = new AffineTransform();
  private final Rectangle rect = new Rectangle(2000, 750);

  public Visualization() {
    Font currentFont = getFont();
    Font newFont = currentFont.deriveFont(currentFont.getSize() * 18F);
    setFont(newFont);
    setBackground(Color.WHITE);
  }

  public void setZoomFactor(double zoomFactor) {
    zoomTransform.scale(zoomFactor, zoomFactor);
    revalidate();
    repaint();
  }

  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    Graphics2D g2d = (Graphics2D) g.create();
    AffineTransform scrollTransform = g2d.getTransform();
    scrollTransform.concatenate(zoomTransform);
    g2d.setTransform(scrollTransform);

    g2d.drawString(""1234567890"", 500, 200);

    g2d.dispose();
  }

  @Override
  public Dimension getPreferredSize() {
    Rectangle r = zoomTransform.createTransformedShape(rect).getBounds();
    return new Dimension(r.width, r.height);
  }
}

class DragScrollListener extends MouseAdapter {
  private final Point origin = new Point();

  @Override
  public void mouseDragged(MouseEvent e) {
    Component c = e.getComponent();
    Container p = SwingUtilities.getUnwrappedParent(c);
    if (p instanceof JViewport) {
      JViewport viewport = (JViewport) p;
      Point cp = SwingUtilities.convertPoint(c, e.getPoint(), viewport);
      Point vp = viewport.getViewPosition();
      vp.translate(origin.x - cp.x, origin.y - cp.y);
      ((JComponent) c).scrollRectToVisible(new Rectangle(vp, viewport.getSize()));
      origin.setLocation(cp);
    }
  }

  @Override
  public void mousePressed(MouseEvent e) {
    Component c = e.getComponent();
    Container p = SwingUtilities.getUnwrappedParent(c);
    if (p instanceof JViewport) {
      JViewport viewport = (JViewport) p;
      Point cp = SwingUtilities.convertPoint(c, e.getPoint(), viewport);
      origin.setLocation(cp);
    }
  }
}",class Visualization extends JPanel {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Component.getFont() ,"// package sometest;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.AffineTransform;
import javax.swing.*;

public class SomeTest2 {
  public JComponent makeUI() {
    Visualization v = new Visualization();

    MouseAdapter mouseAdapter = new DragScrollListener();
    v.addMouseListener(mouseAdapter);
    v.addMouseMotionListener(mouseAdapter);

    JButton in = new JButton(""Zoom In"");
    in.addActionListener(e -> v.setZoomFactor(1.1));

    JButton out = new JButton(""Zoom Out"");
    out.addActionListener(e -> v.setZoomFactor(1 / 1.1));

    JMenuBar mb = new JMenuBar();
    mb.add(in);
    mb.add(out);
    EventQueue.invokeLater(() -> v.getRootPane().setJMenuBar(mb));
    return new JScrollPane(v);
  }

  public static void main(String[] args) {
    EventQueue.invokeLater(() -> {
      JFrame f = new JFrame();
      f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
      f.getContentPane().add(new SomeTest2().makeUI());
      f.setSize(640, 480);
      f.setLocationRelativeTo(null);
      f.setVisible(true);
    });
  }
}

class Visualization extends JPanel {
  private final AffineTransform zoomTransform = new AffineTransform();
  private final Rectangle rect = new Rectangle(2000, 750);

  public Visualization() {
    Font currentFont = getFont();
    Font newFont = currentFont.deriveFont(currentFont.getSize() * 18F);
    setFont(newFont);
    setBackground(Color.WHITE);
  }

  public void setZoomFactor(double zoomFactor) {
    zoomTransform.scale(zoomFactor, zoomFactor);
    revalidate();
    repaint();
  }

  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    Graphics2D g2d = (Graphics2D) g.create();
    AffineTransform scrollTransform = g2d.getTransform();
    scrollTransform.concatenate(zoomTransform);
    g2d.setTransform(scrollTransform);

    g2d.drawString(""1234567890"", 500, 200);

    g2d.dispose();
  }

  @Override
  public Dimension getPreferredSize() {
    Rectangle r = zoomTransform.createTransformedShape(rect).getBounds();
    return new Dimension(r.width, r.height);
  }
}

class DragScrollListener extends MouseAdapter {
  private final Point origin = new Point();

  @Override
  public void mouseDragged(MouseEvent e) {
    Component c = e.getComponent();
    Container p = SwingUtilities.getUnwrappedParent(c);
    if (p instanceof JViewport) {
      JViewport viewport = (JViewport) p;
      Point cp = SwingUtilities.convertPoint(c, e.getPoint(), viewport);
      Point vp = viewport.getViewPosition();
      vp.translate(origin.x - cp.x, origin.y - cp.y);
      ((JComponent) c).scrollRectToVisible(new Rectangle(vp, viewport.getSize()));
      origin.setLocation(cp);
    }
  }

  @Override
  public void mousePressed(MouseEvent e) {
    Component c = e.getComponent();
    Container p = SwingUtilities.getUnwrappedParent(c);
    if (p instanceof JViewport) {
      JViewport viewport = (JViewport) p;
      Point cp = SwingUtilities.convertPoint(c, e.getPoint(), viewport);
      origin.setLocation(cp);
    }
  }
}",    Font currentFont = getFont();,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: JComponent.setFont(Font) ,"// package sometest;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.AffineTransform;
import javax.swing.*;

public class SomeTest2 {
  public JComponent makeUI() {
    Visualization v = new Visualization();

    MouseAdapter mouseAdapter = new DragScrollListener();
    v.addMouseListener(mouseAdapter);
    v.addMouseMotionListener(mouseAdapter);

    JButton in = new JButton(""Zoom In"");
    in.addActionListener(e -> v.setZoomFactor(1.1));

    JButton out = new JButton(""Zoom Out"");
    out.addActionListener(e -> v.setZoomFactor(1 / 1.1));

    JMenuBar mb = new JMenuBar();
    mb.add(in);
    mb.add(out);
    EventQueue.invokeLater(() -> v.getRootPane().setJMenuBar(mb));
    return new JScrollPane(v);
  }

  public static void main(String[] args) {
    EventQueue.invokeLater(() -> {
      JFrame f = new JFrame();
      f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
      f.getContentPane().add(new SomeTest2().makeUI());
      f.setSize(640, 480);
      f.setLocationRelativeTo(null);
      f.setVisible(true);
    });
  }
}

class Visualization extends JPanel {
  private final AffineTransform zoomTransform = new AffineTransform();
  private final Rectangle rect = new Rectangle(2000, 750);

  public Visualization() {
    Font currentFont = getFont();
    Font newFont = currentFont.deriveFont(currentFont.getSize() * 18F);
    setFont(newFont);
    setBackground(Color.WHITE);
  }

  public void setZoomFactor(double zoomFactor) {
    zoomTransform.scale(zoomFactor, zoomFactor);
    revalidate();
    repaint();
  }

  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    Graphics2D g2d = (Graphics2D) g.create();
    AffineTransform scrollTransform = g2d.getTransform();
    scrollTransform.concatenate(zoomTransform);
    g2d.setTransform(scrollTransform);

    g2d.drawString(""1234567890"", 500, 200);

    g2d.dispose();
  }

  @Override
  public Dimension getPreferredSize() {
    Rectangle r = zoomTransform.createTransformedShape(rect).getBounds();
    return new Dimension(r.width, r.height);
  }
}

class DragScrollListener extends MouseAdapter {
  private final Point origin = new Point();

  @Override
  public void mouseDragged(MouseEvent e) {
    Component c = e.getComponent();
    Container p = SwingUtilities.getUnwrappedParent(c);
    if (p instanceof JViewport) {
      JViewport viewport = (JViewport) p;
      Point cp = SwingUtilities.convertPoint(c, e.getPoint(), viewport);
      Point vp = viewport.getViewPosition();
      vp.translate(origin.x - cp.x, origin.y - cp.y);
      ((JComponent) c).scrollRectToVisible(new Rectangle(vp, viewport.getSize()));
      origin.setLocation(cp);
    }
  }

  @Override
  public void mousePressed(MouseEvent e) {
    Component c = e.getComponent();
    Container p = SwingUtilities.getUnwrappedParent(c);
    if (p instanceof JViewport) {
      JViewport viewport = (JViewport) p;
      Point cp = SwingUtilities.convertPoint(c, e.getPoint(), viewport);
      origin.setLocation(cp);
    }
  }
}",    setFont(newFont);,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: JComponent.setBackground(Color) ,"// package sometest;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.AffineTransform;
import javax.swing.*;

public class SomeTest2 {
  public JComponent makeUI() {
    Visualization v = new Visualization();

    MouseAdapter mouseAdapter = new DragScrollListener();
    v.addMouseListener(mouseAdapter);
    v.addMouseMotionListener(mouseAdapter);

    JButton in = new JButton(""Zoom In"");
    in.addActionListener(e -> v.setZoomFactor(1.1));

    JButton out = new JButton(""Zoom Out"");
    out.addActionListener(e -> v.setZoomFactor(1 / 1.1));

    JMenuBar mb = new JMenuBar();
    mb.add(in);
    mb.add(out);
    EventQueue.invokeLater(() -> v.getRootPane().setJMenuBar(mb));
    return new JScrollPane(v);
  }

  public static void main(String[] args) {
    EventQueue.invokeLater(() -> {
      JFrame f = new JFrame();
      f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
      f.getContentPane().add(new SomeTest2().makeUI());
      f.setSize(640, 480);
      f.setLocationRelativeTo(null);
      f.setVisible(true);
    });
  }
}

class Visualization extends JPanel {
  private final AffineTransform zoomTransform = new AffineTransform();
  private final Rectangle rect = new Rectangle(2000, 750);

  public Visualization() {
    Font currentFont = getFont();
    Font newFont = currentFont.deriveFont(currentFont.getSize() * 18F);
    setFont(newFont);
    setBackground(Color.WHITE);
  }

  public void setZoomFactor(double zoomFactor) {
    zoomTransform.scale(zoomFactor, zoomFactor);
    revalidate();
    repaint();
  }

  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    Graphics2D g2d = (Graphics2D) g.create();
    AffineTransform scrollTransform = g2d.getTransform();
    scrollTransform.concatenate(zoomTransform);
    g2d.setTransform(scrollTransform);

    g2d.drawString(""1234567890"", 500, 200);

    g2d.dispose();
  }

  @Override
  public Dimension getPreferredSize() {
    Rectangle r = zoomTransform.createTransformedShape(rect).getBounds();
    return new Dimension(r.width, r.height);
  }
}

class DragScrollListener extends MouseAdapter {
  private final Point origin = new Point();

  @Override
  public void mouseDragged(MouseEvent e) {
    Component c = e.getComponent();
    Container p = SwingUtilities.getUnwrappedParent(c);
    if (p instanceof JViewport) {
      JViewport viewport = (JViewport) p;
      Point cp = SwingUtilities.convertPoint(c, e.getPoint(), viewport);
      Point vp = viewport.getViewPosition();
      vp.translate(origin.x - cp.x, origin.y - cp.y);
      ((JComponent) c).scrollRectToVisible(new Rectangle(vp, viewport.getSize()));
      origin.setLocation(cp);
    }
  }

  @Override
  public void mousePressed(MouseEvent e) {
    Component c = e.getComponent();
    Container p = SwingUtilities.getUnwrappedParent(c);
    if (p instanceof JViewport) {
      JViewport viewport = (JViewport) p;
      Point cp = SwingUtilities.convertPoint(c, e.getPoint(), viewport);
      origin.setLocation(cp);
    }
  }
}",    setBackground(Color.WHITE);,StackOverflow
AvoidCatchingThrowable,A catch statement should never catch throwable since it includes errors.,"class Print implements Runnable {
    private String string;

    private CyclicBarrier cb = new CyclicBarrier(2);
    private CountDownLatch cdl = new CountDownLatch(1);
    private AtomicBoolean win = new AtomicBoolean();

    Print(String string) {
        this.string = string;
    }
    @Override
    public void run() {
        try {
            for (int i = string.length()-1; i >= 0; i--) {
                cb.await();

                if (i != 0) {
                    System.out.print(string.charAt(i) + ""-"");
                } else {
                    if (win.getAndSet(true)) {
                        cdl.await();
                        System.out.print(string.charAt(i));
                    } else {
                        System.out.print(string.charAt(i) + ""-"");
                        cdl.countDown();
                    }
                }
            }
        } catch (Throwable ex) {
           ex.printStackTrace();
        }
    }
}",        } catch (Throwable ex) {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

public class ConvolveOpTest extends JFrame{
    JScrollPane scrollPane;
    BufferedImage image;
    
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable(){
            @Override
            public void run(){
                new ConvolveOpTest();
            }
        });
    }
    
    public ConvolveOpTest(){
        try{
            long timePrev = System.currentTimeMillis();
            image = ImageIO.read(new File(""a.jpg""));
            int arrSize = 50;
            float matrix[][] = new float[arrSize][arrSize];
            for(int x = 0 ; x < matrix.length ; x++){
                for(int y = 0 ; y < matrix[0].length ; y++){
                    matrix[x][y] = 1f / matrix.length / matrix[0].length;
                }
            }
            
            ArrayList<Float> list = new ArrayList<>();
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[i].length; j++) { 
                    list.add(matrix[i][j]); 
                }
            }

            float[] vector = new float[list.size()];
            for (int i = 0 ; i < vector.length; i++) {
                vector[i] = list.get(i);
            }
            
            ConvolveOp op = new ConvolveOp(new Kernel(matrix.length, matrix[0].length, vector));
            BufferedImage output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
            image = op.filter(image, output);
            System.out.println(System.currentTimeMillis() - timePrev);
        }catch(IOException e){
            e.printStackTrace();
        }
        
        JPanel panel = new JPanel(){
            @Override
            public void paintComponent(Graphics g){
                super.paintComponent(g);
                Graphics2D g2 = (Graphics2D)g;
                g2.scale(0.5, 0.5);
                g2.drawImage(image, 0, 0, null);
            }
            
            @Override
            public Dimension getPreferredSize(){
                return new Dimension((int)(image.getWidth() * 0.5), (int)(image.getHeight() * 0.5));
            }
            
        };
        
        scrollPane = new JScrollPane(panel);
        
        setSize(new Dimension(1200,700));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(scrollPane);
        setVisible(true);
    }
    
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(1200, 700);
    }
    
}",public class ConvolveOpTest extends JFrame{,StackOverflow
TestClassWithoutTestCases,"The class 'ConvolveOpTest' might be a test class, but it contains no test cases.","import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

public class ConvolveOpTest extends JFrame{
    JScrollPane scrollPane;
    BufferedImage image;
    
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable(){
            @Override
            public void run(){
                new ConvolveOpTest();
            }
        });
    }
    
    public ConvolveOpTest(){
        try{
            long timePrev = System.currentTimeMillis();
            image = ImageIO.read(new File(""a.jpg""));
            int arrSize = 50;
            float matrix[][] = new float[arrSize][arrSize];
            for(int x = 0 ; x < matrix.length ; x++){
                for(int y = 0 ; y < matrix[0].length ; y++){
                    matrix[x][y] = 1f / matrix.length / matrix[0].length;
                }
            }
            
            ArrayList<Float> list = new ArrayList<>();
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[i].length; j++) { 
                    list.add(matrix[i][j]); 
                }
            }

            float[] vector = new float[list.size()];
            for (int i = 0 ; i < vector.length; i++) {
                vector[i] = list.get(i);
            }
            
            ConvolveOp op = new ConvolveOp(new Kernel(matrix.length, matrix[0].length, vector));
            BufferedImage output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
            image = op.filter(image, output);
            System.out.println(System.currentTimeMillis() - timePrev);
        }catch(IOException e){
            e.printStackTrace();
        }
        
        JPanel panel = new JPanel(){
            @Override
            public void paintComponent(Graphics g){
                super.paintComponent(g);
                Graphics2D g2 = (Graphics2D)g;
                g2.scale(0.5, 0.5);
                g2.drawImage(image, 0, 0, null);
            }
            
            @Override
            public Dimension getPreferredSize(){
                return new Dimension((int)(image.getWidth() * 0.5), (int)(image.getHeight() * 0.5));
            }
            
        };
        
        scrollPane = new JScrollPane(panel);
        
        setSize(new Dimension(1200,700));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(scrollPane);
        setVisible(true);
    }
    
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(1200, 700);
    }
    
}",public class ConvolveOpTest extends JFrame{,StackOverflow
NonSerializableClass,The field 'image' of serializable class 'ConvolveOpTest' is of non-serializable type 'java.awt.image.BufferedImage'.,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

public class ConvolveOpTest extends JFrame{
    JScrollPane scrollPane;
    BufferedImage image;
    
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable(){
            @Override
            public void run(){
                new ConvolveOpTest();
            }
        });
    }
    
    public ConvolveOpTest(){
        try{
            long timePrev = System.currentTimeMillis();
            image = ImageIO.read(new File(""a.jpg""));
            int arrSize = 50;
            float matrix[][] = new float[arrSize][arrSize];
            for(int x = 0 ; x < matrix.length ; x++){
                for(int y = 0 ; y < matrix[0].length ; y++){
                    matrix[x][y] = 1f / matrix.length / matrix[0].length;
                }
            }
            
            ArrayList<Float> list = new ArrayList<>();
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[i].length; j++) { 
                    list.add(matrix[i][j]); 
                }
            }

            float[] vector = new float[list.size()];
            for (int i = 0 ; i < vector.length; i++) {
                vector[i] = list.get(i);
            }
            
            ConvolveOp op = new ConvolveOp(new Kernel(matrix.length, matrix[0].length, vector));
            BufferedImage output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
            image = op.filter(image, output);
            System.out.println(System.currentTimeMillis() - timePrev);
        }catch(IOException e){
            e.printStackTrace();
        }
        
        JPanel panel = new JPanel(){
            @Override
            public void paintComponent(Graphics g){
                super.paintComponent(g);
                Graphics2D g2 = (Graphics2D)g;
                g2.scale(0.5, 0.5);
                g2.drawImage(image, 0, 0, null);
            }
            
            @Override
            public Dimension getPreferredSize(){
                return new Dimension((int)(image.getWidth() * 0.5), (int)(image.getHeight() * 0.5));
            }
            
        };
        
        scrollPane = new JScrollPane(panel);
        
        setSize(new Dimension(1200,700));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(scrollPane);
        setVisible(true);
    }
    
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(1200, 700);
    }
    
}",    BufferedImage image;,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setSize(Dimension) ,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

public class ConvolveOpTest extends JFrame{
    JScrollPane scrollPane;
    BufferedImage image;
    
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable(){
            @Override
            public void run(){
                new ConvolveOpTest();
            }
        });
    }
    
    public ConvolveOpTest(){
        try{
            long timePrev = System.currentTimeMillis();
            image = ImageIO.read(new File(""a.jpg""));
            int arrSize = 50;
            float matrix[][] = new float[arrSize][arrSize];
            for(int x = 0 ; x < matrix.length ; x++){
                for(int y = 0 ; y < matrix[0].length ; y++){
                    matrix[x][y] = 1f / matrix.length / matrix[0].length;
                }
            }
            
            ArrayList<Float> list = new ArrayList<>();
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[i].length; j++) { 
                    list.add(matrix[i][j]); 
                }
            }

            float[] vector = new float[list.size()];
            for (int i = 0 ; i < vector.length; i++) {
                vector[i] = list.get(i);
            }
            
            ConvolveOp op = new ConvolveOp(new Kernel(matrix.length, matrix[0].length, vector));
            BufferedImage output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
            image = op.filter(image, output);
            System.out.println(System.currentTimeMillis() - timePrev);
        }catch(IOException e){
            e.printStackTrace();
        }
        
        JPanel panel = new JPanel(){
            @Override
            public void paintComponent(Graphics g){
                super.paintComponent(g);
                Graphics2D g2 = (Graphics2D)g;
                g2.scale(0.5, 0.5);
                g2.drawImage(image, 0, 0, null);
            }
            
            @Override
            public Dimension getPreferredSize(){
                return new Dimension((int)(image.getWidth() * 0.5), (int)(image.getHeight() * 0.5));
            }
            
        };
        
        scrollPane = new JScrollPane(panel);
        
        setSize(new Dimension(1200,700));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(scrollPane);
        setVisible(true);
    }
    
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(1200, 700);
    }
    
}","        setSize(new Dimension(1200,700));",StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.setDefaultCloseOperation(int) ,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

public class ConvolveOpTest extends JFrame{
    JScrollPane scrollPane;
    BufferedImage image;
    
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable(){
            @Override
            public void run(){
                new ConvolveOpTest();
            }
        });
    }
    
    public ConvolveOpTest(){
        try{
            long timePrev = System.currentTimeMillis();
            image = ImageIO.read(new File(""a.jpg""));
            int arrSize = 50;
            float matrix[][] = new float[arrSize][arrSize];
            for(int x = 0 ; x < matrix.length ; x++){
                for(int y = 0 ; y < matrix[0].length ; y++){
                    matrix[x][y] = 1f / matrix.length / matrix[0].length;
                }
            }
            
            ArrayList<Float> list = new ArrayList<>();
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[i].length; j++) { 
                    list.add(matrix[i][j]); 
                }
            }

            float[] vector = new float[list.size()];
            for (int i = 0 ; i < vector.length; i++) {
                vector[i] = list.get(i);
            }
            
            ConvolveOp op = new ConvolveOp(new Kernel(matrix.length, matrix[0].length, vector));
            BufferedImage output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
            image = op.filter(image, output);
            System.out.println(System.currentTimeMillis() - timePrev);
        }catch(IOException e){
            e.printStackTrace();
        }
        
        JPanel panel = new JPanel(){
            @Override
            public void paintComponent(Graphics g){
                super.paintComponent(g);
                Graphics2D g2 = (Graphics2D)g;
                g2.scale(0.5, 0.5);
                g2.drawImage(image, 0, 0, null);
            }
            
            @Override
            public Dimension getPreferredSize(){
                return new Dimension((int)(image.getWidth() * 0.5), (int)(image.getHeight() * 0.5));
            }
            
        };
        
        scrollPane = new JScrollPane(panel);
        
        setSize(new Dimension(1200,700));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(scrollPane);
        setVisible(true);
    }
    
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(1200, 700);
    }
    
}",        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Container.add(Component) ,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

public class ConvolveOpTest extends JFrame{
    JScrollPane scrollPane;
    BufferedImage image;
    
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable(){
            @Override
            public void run(){
                new ConvolveOpTest();
            }
        });
    }
    
    public ConvolveOpTest(){
        try{
            long timePrev = System.currentTimeMillis();
            image = ImageIO.read(new File(""a.jpg""));
            int arrSize = 50;
            float matrix[][] = new float[arrSize][arrSize];
            for(int x = 0 ; x < matrix.length ; x++){
                for(int y = 0 ; y < matrix[0].length ; y++){
                    matrix[x][y] = 1f / matrix.length / matrix[0].length;
                }
            }
            
            ArrayList<Float> list = new ArrayList<>();
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[i].length; j++) { 
                    list.add(matrix[i][j]); 
                }
            }

            float[] vector = new float[list.size()];
            for (int i = 0 ; i < vector.length; i++) {
                vector[i] = list.get(i);
            }
            
            ConvolveOp op = new ConvolveOp(new Kernel(matrix.length, matrix[0].length, vector));
            BufferedImage output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
            image = op.filter(image, output);
            System.out.println(System.currentTimeMillis() - timePrev);
        }catch(IOException e){
            e.printStackTrace();
        }
        
        JPanel panel = new JPanel(){
            @Override
            public void paintComponent(Graphics g){
                super.paintComponent(g);
                Graphics2D g2 = (Graphics2D)g;
                g2.scale(0.5, 0.5);
                g2.drawImage(image, 0, 0, null);
            }
            
            @Override
            public Dimension getPreferredSize(){
                return new Dimension((int)(image.getWidth() * 0.5), (int)(image.getHeight() * 0.5));
            }
            
        };
        
        scrollPane = new JScrollPane(panel);
        
        setSize(new Dimension(1200,700));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(scrollPane);
        setVisible(true);
    }
    
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(1200, 700);
    }
    
}",        add(scrollPane);,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setVisible(boolean) ,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

public class ConvolveOpTest extends JFrame{
    JScrollPane scrollPane;
    BufferedImage image;
    
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable(){
            @Override
            public void run(){
                new ConvolveOpTest();
            }
        });
    }
    
    public ConvolveOpTest(){
        try{
            long timePrev = System.currentTimeMillis();
            image = ImageIO.read(new File(""a.jpg""));
            int arrSize = 50;
            float matrix[][] = new float[arrSize][arrSize];
            for(int x = 0 ; x < matrix.length ; x++){
                for(int y = 0 ; y < matrix[0].length ; y++){
                    matrix[x][y] = 1f / matrix.length / matrix[0].length;
                }
            }
            
            ArrayList<Float> list = new ArrayList<>();
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[i].length; j++) { 
                    list.add(matrix[i][j]); 
                }
            }

            float[] vector = new float[list.size()];
            for (int i = 0 ; i < vector.length; i++) {
                vector[i] = list.get(i);
            }
            
            ConvolveOp op = new ConvolveOp(new Kernel(matrix.length, matrix[0].length, vector));
            BufferedImage output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
            image = op.filter(image, output);
            System.out.println(System.currentTimeMillis() - timePrev);
        }catch(IOException e){
            e.printStackTrace();
        }
        
        JPanel panel = new JPanel(){
            @Override
            public void paintComponent(Graphics g){
                super.paintComponent(g);
                Graphics2D g2 = (Graphics2D)g;
                g2.scale(0.5, 0.5);
                g2.drawImage(image, 0, 0, null);
            }
            
            @Override
            public Dimension getPreferredSize(){
                return new Dimension((int)(image.getWidth() * 0.5), (int)(image.getHeight() * 0.5));
            }
            
        };
        
        scrollPane = new JScrollPane(panel);
        
        setSize(new Dimension(1200,700));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(scrollPane);
        setVisible(true);
    }
    
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(1200, 700);
    }
    
}",        setVisible(true);,StackOverflow
CloseResource,Ensure that resources like this BufferedReader object are closed after use,"package com.example.myapplication;

import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.opencv.opencv_core.Point;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import android.os.Build;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {
    static final int cols = 192;
    static final int rows = 108;
    static final String ffmpeg = Loader.load(org.bytedeco.ffmpeg.ffmpeg.class);
    static final String rtmp_url = ""test.flv"";
    static final String[] command = {ffmpeg,
            ""-y"",
            ""-f"", ""rawvideo"",
            ""-vcodec"", ""rawvideo"",
            ""-pix_fmt"", ""bgr24"",
            ""-s"", (Integer.toString(cols) + ""x"" + Integer.toString(rows)),
            ""-r"", ""10"",
            ""-i"", ""pipe:"",
            ""-c:v"", ""libx264"",
            ""-pix_fmt"", ""yuv420p"",
            ""-preset"", ""ultrafast"",
            ""-f"", ""flv"",
            rtmp_url};
    @RequiresApi(api = Build.VERSION_CODES.O)
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //new Thread(t1).start();
        ProcessBuilder pb = new ProcessBuilder(""echo"", ""Hello World!"");
        pb.redirectErrorStream(true);
        System.out.println(""Run echo command"");
        Process process = null;
        try {
            process = pb.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
        int errCode = 0;
        try {
            errCode = process.waitFor();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(""Echo command executed, any errors? "" + (errCode == 0 ? ""No"" : ""Yes""));
        try {
            System.out.println(""Echo Output:\n"" + output(process.getInputStream()));
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            OutputStream writer = process.getOutputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
        Log.e(""TAG"", ""void OnCreate called successfully!"");

    }

    private static String output(InputStream inputStream) throws IOException {
        StringBuilder sb = new StringBuilder();
        BufferedReader br = null;
        try {
            br = new BufferedReader(new InputStreamReader(inputStream));
            String line = null;
            while ((line = br.readLine()) != null) {
                sb.append(line + System.getProperty(""line.separator""));
            }
        } finally {
            br.close();
        }
        return sb.toString();
    }
    
}",            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));,StackOverflow
CloseResource,Ensure that resources like this OutputStream object are closed after use,"package com.example.myapplication;

import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.opencv.opencv_core.Point;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import android.os.Build;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {
    static final int cols = 192;
    static final int rows = 108;
    static final String ffmpeg = Loader.load(org.bytedeco.ffmpeg.ffmpeg.class);
    static final String rtmp_url = ""test.flv"";
    static final String[] command = {ffmpeg,
            ""-y"",
            ""-f"", ""rawvideo"",
            ""-vcodec"", ""rawvideo"",
            ""-pix_fmt"", ""bgr24"",
            ""-s"", (Integer.toString(cols) + ""x"" + Integer.toString(rows)),
            ""-r"", ""10"",
            ""-i"", ""pipe:"",
            ""-c:v"", ""libx264"",
            ""-pix_fmt"", ""yuv420p"",
            ""-preset"", ""ultrafast"",
            ""-f"", ""flv"",
            rtmp_url};
    @RequiresApi(api = Build.VERSION_CODES.O)
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //new Thread(t1).start();
        ProcessBuilder pb = new ProcessBuilder(""echo"", ""Hello World!"");
        pb.redirectErrorStream(true);
        System.out.println(""Run echo command"");
        Process process = null;
        try {
            process = pb.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
        int errCode = 0;
        try {
            errCode = process.waitFor();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(""Echo command executed, any errors? "" + (errCode == 0 ? ""No"" : ""Yes""));
        try {
            System.out.println(""Echo Output:\n"" + output(process.getInputStream()));
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            OutputStream writer = process.getOutputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
        Log.e(""TAG"", ""void OnCreate called successfully!"");

    }

    private static String output(InputStream inputStream) throws IOException {
        StringBuilder sb = new StringBuilder();
        BufferedReader br = null;
        try {
            br = new BufferedReader(new InputStreamReader(inputStream));
            String line = null;
            while ((line = br.readLine()) != null) {
                sb.append(line + System.getProperty(""line.separator""));
            }
        } finally {
            br.close();
        }
        return sb.toString();
    }
    
}",            OutputStream writer = process.getOutputStream();,StackOverflow
AssignmentInOperand,Avoid assignments in operands,"package com.example.myapplication;

import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.opencv.opencv_core.Point;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import android.os.Build;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {
    static final int cols = 192;
    static final int rows = 108;
    static final String ffmpeg = Loader.load(org.bytedeco.ffmpeg.ffmpeg.class);
    static final String rtmp_url = ""test.flv"";
    static final String[] command = {ffmpeg,
            ""-y"",
            ""-f"", ""rawvideo"",
            ""-vcodec"", ""rawvideo"",
            ""-pix_fmt"", ""bgr24"",
            ""-s"", (Integer.toString(cols) + ""x"" + Integer.toString(rows)),
            ""-r"", ""10"",
            ""-i"", ""pipe:"",
            ""-c:v"", ""libx264"",
            ""-pix_fmt"", ""yuv420p"",
            ""-preset"", ""ultrafast"",
            ""-f"", ""flv"",
            rtmp_url};
    @RequiresApi(api = Build.VERSION_CODES.O)
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //new Thread(t1).start();
        ProcessBuilder pb = new ProcessBuilder(""echo"", ""Hello World!"");
        pb.redirectErrorStream(true);
        System.out.println(""Run echo command"");
        Process process = null;
        try {
            process = pb.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
        int errCode = 0;
        try {
            errCode = process.waitFor();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(""Echo command executed, any errors? "" + (errCode == 0 ? ""No"" : ""Yes""));
        try {
            System.out.println(""Echo Output:\n"" + output(process.getInputStream()));
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            OutputStream writer = process.getOutputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
        Log.e(""TAG"", ""void OnCreate called successfully!"");

    }

    private static String output(InputStream inputStream) throws IOException {
        StringBuilder sb = new StringBuilder();
        BufferedReader br = null;
        try {
            br = new BufferedReader(new InputStreamReader(inputStream));
            String line = null;
            while ((line = br.readLine()) != null) {
                sb.append(line + System.getProperty(""line.separator""));
            }
        } finally {
            br.close();
        }
        return sb.toString();
    }
    
}",            while ((line = br.readLine()) != null) {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import java.awt.*;

public class DynamicCellRow {
    public static void main(String[] args) {

        var contentPane = new JPanel(new BorderLayout());
        contentPane.add(new JScrollPane(makeTable()));

        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""DynamicCellRow"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(contentPane);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

    @NotNull
    private static JTable makeTable() {
        var jTable = new JTable(
                new Object[][]{
                        {""a"", ""charly""},
                        {""b"", ""tango""}
                },
                new Object[]{""id"", ""control""}
        ) {
            @Override
            public void doLayout() {
                super.doLayout();
                adjustRowHeights();
            }

            private void adjustRowHeights() {
                for (int row = 0; row < getRowCount(); row++) {
                    int rowHeight = getRowHeight();

                    for (int column = 0; column < getColumnCount(); column++) {
                        var editorComponent = getEditorComponent();
                        if (getEditingRow() == row && getEditingColumn() == column && editorComponent != null) {
                            editorComponent.setSize(getColumnModel().getColumn(column).getWidth(), 0);
                            rowHeight = Math.max(rowHeight, editorComponent.getPreferredSize().height);
                        } else {
                            var comp = prepareRenderer(getCellRenderer(row, column), row, column);
                            rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
                        }
                    }

                    setRowHeight(row, rowHeight);
                }
            }
        };
        {
            var richColumn = jTable.getColumnModel().getColumn(1);
            richColumn.setCellRenderer(new ExpandablePanelCellRenderer());
            richColumn.setCellEditor(new DynamicExpndablePanelCellEditor());
        }
        return jTable;
    }


    static class ExpandablePanel extends JPanel {

        private final JLabel comp;
        private final JPanel advanced;

        ExpandablePanel() {
            setBorder(BorderFactory.createLineBorder(Color.black));
            setLayout(new GridBagLayout());

            GridBagConstraints gbc = new GridBagConstraints();
            // horizontal left-to-right layout
            gbc.gridx = 0;
            gbc.gridy = 0;

            // resizing behavior
            gbc.weightx = 1;
            gbc.weighty = 1;

            gbc.insets = new Insets(2, 2, 2, 2);
            gbc.fill = GridBagConstraints.BOTH;

            advanced = new JPanel();
            {
                advanced.setLayout(new BoxLayout(advanced, BoxLayout.Y_AXIS));
                advanced.setBorder(new TitledBorder(""Advance Settings""));
                advanced.add(new JCheckBox(""Live""));
                advanced.add(new JCheckBox(""Condition""));
                advanced.add(new JCheckBox(""Disable""));
            }
            advanced.setVisible(false);

            var standard = new JPanel();
            {
                standard.setLayout(new BoxLayout(standard, BoxLayout.X_AXIS));
                comp = new JLabel(""Label 1"");
                standard.add(comp);
                standard.add(new JButton(""Button 1""));
                var expandButton = new JButton(""+"");
                expandButton.addActionListener(e -> {
                    if (advanced.isVisible()) {
                        advanced.setVisible(false);
                        expandButton.setText(""+"");
                    } else {
                        advanced.setVisible(true);
                        expandButton.setText(""-"");
                    }
                });
                standard.add(expandButton);
            }
            add(standard, gbc);


            gbc.gridy++;
            gbc.weighty = 0;
            add(advanced, gbc);
        }

        public void setValue(Object value) {
            comp.setText(value.toString());
        }

        public void setAdvancedVisibility(boolean visible) {
            advanced.setVisible(visible);
        }
    }

    private static class DynamicExpndablePanelCellEditor extends AbstractCellEditor implements TableCellEditor {
        Object value;
        @Override
        public Object getCellEditorValue() {
            return value; // not changing
        }

        private final ExpandablePanel expandablePanel = new ExpandablePanel();
        {
            addCellEditorListener(new CellEditorListener() {
                @Override
                public void editingStopped(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }

                @Override
                public void editingCanceled(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }
            });
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            this.value = value;
            expandablePanel.setValue(value);

            return expandablePanel;
        }
    }

    private static class ExpandablePanelCellRenderer implements TableCellRenderer {
        private final ExpandablePanel expandablePanelRenderComponent = new ExpandablePanel();

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            expandablePanelRenderComponent.setValue(value);
            return expandablePanelRenderComponent;
        }
    }
}",    static class ExpandablePanel extends JPanel {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: JComponent.setBorder(Border) ,"import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import java.awt.*;

public class DynamicCellRow {
    public static void main(String[] args) {

        var contentPane = new JPanel(new BorderLayout());
        contentPane.add(new JScrollPane(makeTable()));

        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""DynamicCellRow"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(contentPane);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

    @NotNull
    private static JTable makeTable() {
        var jTable = new JTable(
                new Object[][]{
                        {""a"", ""charly""},
                        {""b"", ""tango""}
                },
                new Object[]{""id"", ""control""}
        ) {
            @Override
            public void doLayout() {
                super.doLayout();
                adjustRowHeights();
            }

            private void adjustRowHeights() {
                for (int row = 0; row < getRowCount(); row++) {
                    int rowHeight = getRowHeight();

                    for (int column = 0; column < getColumnCount(); column++) {
                        var editorComponent = getEditorComponent();
                        if (getEditingRow() == row && getEditingColumn() == column && editorComponent != null) {
                            editorComponent.setSize(getColumnModel().getColumn(column).getWidth(), 0);
                            rowHeight = Math.max(rowHeight, editorComponent.getPreferredSize().height);
                        } else {
                            var comp = prepareRenderer(getCellRenderer(row, column), row, column);
                            rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
                        }
                    }

                    setRowHeight(row, rowHeight);
                }
            }
        };
        {
            var richColumn = jTable.getColumnModel().getColumn(1);
            richColumn.setCellRenderer(new ExpandablePanelCellRenderer());
            richColumn.setCellEditor(new DynamicExpndablePanelCellEditor());
        }
        return jTable;
    }


    static class ExpandablePanel extends JPanel {

        private final JLabel comp;
        private final JPanel advanced;

        ExpandablePanel() {
            setBorder(BorderFactory.createLineBorder(Color.black));
            setLayout(new GridBagLayout());

            GridBagConstraints gbc = new GridBagConstraints();
            // horizontal left-to-right layout
            gbc.gridx = 0;
            gbc.gridy = 0;

            // resizing behavior
            gbc.weightx = 1;
            gbc.weighty = 1;

            gbc.insets = new Insets(2, 2, 2, 2);
            gbc.fill = GridBagConstraints.BOTH;

            advanced = new JPanel();
            {
                advanced.setLayout(new BoxLayout(advanced, BoxLayout.Y_AXIS));
                advanced.setBorder(new TitledBorder(""Advance Settings""));
                advanced.add(new JCheckBox(""Live""));
                advanced.add(new JCheckBox(""Condition""));
                advanced.add(new JCheckBox(""Disable""));
            }
            advanced.setVisible(false);

            var standard = new JPanel();
            {
                standard.setLayout(new BoxLayout(standard, BoxLayout.X_AXIS));
                comp = new JLabel(""Label 1"");
                standard.add(comp);
                standard.add(new JButton(""Button 1""));
                var expandButton = new JButton(""+"");
                expandButton.addActionListener(e -> {
                    if (advanced.isVisible()) {
                        advanced.setVisible(false);
                        expandButton.setText(""+"");
                    } else {
                        advanced.setVisible(true);
                        expandButton.setText(""-"");
                    }
                });
                standard.add(expandButton);
            }
            add(standard, gbc);


            gbc.gridy++;
            gbc.weighty = 0;
            add(advanced, gbc);
        }

        public void setValue(Object value) {
            comp.setText(value.toString());
        }

        public void setAdvancedVisibility(boolean visible) {
            advanced.setVisible(visible);
        }
    }

    private static class DynamicExpndablePanelCellEditor extends AbstractCellEditor implements TableCellEditor {
        Object value;
        @Override
        public Object getCellEditorValue() {
            return value; // not changing
        }

        private final ExpandablePanel expandablePanel = new ExpandablePanel();
        {
            addCellEditorListener(new CellEditorListener() {
                @Override
                public void editingStopped(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }

                @Override
                public void editingCanceled(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }
            });
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            this.value = value;
            expandablePanel.setValue(value);

            return expandablePanel;
        }
    }

    private static class ExpandablePanelCellRenderer implements TableCellRenderer {
        private final ExpandablePanel expandablePanelRenderComponent = new ExpandablePanel();

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            expandablePanelRenderComponent.setValue(value);
            return expandablePanelRenderComponent;
        }
    }
}",            setBorder(BorderFactory.createLineBorder(Color.black));,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Container.setLayout(LayoutManager) ,"import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import java.awt.*;

public class DynamicCellRow {
    public static void main(String[] args) {

        var contentPane = new JPanel(new BorderLayout());
        contentPane.add(new JScrollPane(makeTable()));

        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""DynamicCellRow"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(contentPane);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

    @NotNull
    private static JTable makeTable() {
        var jTable = new JTable(
                new Object[][]{
                        {""a"", ""charly""},
                        {""b"", ""tango""}
                },
                new Object[]{""id"", ""control""}
        ) {
            @Override
            public void doLayout() {
                super.doLayout();
                adjustRowHeights();
            }

            private void adjustRowHeights() {
                for (int row = 0; row < getRowCount(); row++) {
                    int rowHeight = getRowHeight();

                    for (int column = 0; column < getColumnCount(); column++) {
                        var editorComponent = getEditorComponent();
                        if (getEditingRow() == row && getEditingColumn() == column && editorComponent != null) {
                            editorComponent.setSize(getColumnModel().getColumn(column).getWidth(), 0);
                            rowHeight = Math.max(rowHeight, editorComponent.getPreferredSize().height);
                        } else {
                            var comp = prepareRenderer(getCellRenderer(row, column), row, column);
                            rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
                        }
                    }

                    setRowHeight(row, rowHeight);
                }
            }
        };
        {
            var richColumn = jTable.getColumnModel().getColumn(1);
            richColumn.setCellRenderer(new ExpandablePanelCellRenderer());
            richColumn.setCellEditor(new DynamicExpndablePanelCellEditor());
        }
        return jTable;
    }


    static class ExpandablePanel extends JPanel {

        private final JLabel comp;
        private final JPanel advanced;

        ExpandablePanel() {
            setBorder(BorderFactory.createLineBorder(Color.black));
            setLayout(new GridBagLayout());

            GridBagConstraints gbc = new GridBagConstraints();
            // horizontal left-to-right layout
            gbc.gridx = 0;
            gbc.gridy = 0;

            // resizing behavior
            gbc.weightx = 1;
            gbc.weighty = 1;

            gbc.insets = new Insets(2, 2, 2, 2);
            gbc.fill = GridBagConstraints.BOTH;

            advanced = new JPanel();
            {
                advanced.setLayout(new BoxLayout(advanced, BoxLayout.Y_AXIS));
                advanced.setBorder(new TitledBorder(""Advance Settings""));
                advanced.add(new JCheckBox(""Live""));
                advanced.add(new JCheckBox(""Condition""));
                advanced.add(new JCheckBox(""Disable""));
            }
            advanced.setVisible(false);

            var standard = new JPanel();
            {
                standard.setLayout(new BoxLayout(standard, BoxLayout.X_AXIS));
                comp = new JLabel(""Label 1"");
                standard.add(comp);
                standard.add(new JButton(""Button 1""));
                var expandButton = new JButton(""+"");
                expandButton.addActionListener(e -> {
                    if (advanced.isVisible()) {
                        advanced.setVisible(false);
                        expandButton.setText(""+"");
                    } else {
                        advanced.setVisible(true);
                        expandButton.setText(""-"");
                    }
                });
                standard.add(expandButton);
            }
            add(standard, gbc);


            gbc.gridy++;
            gbc.weighty = 0;
            add(advanced, gbc);
        }

        public void setValue(Object value) {
            comp.setText(value.toString());
        }

        public void setAdvancedVisibility(boolean visible) {
            advanced.setVisible(visible);
        }
    }

    private static class DynamicExpndablePanelCellEditor extends AbstractCellEditor implements TableCellEditor {
        Object value;
        @Override
        public Object getCellEditorValue() {
            return value; // not changing
        }

        private final ExpandablePanel expandablePanel = new ExpandablePanel();
        {
            addCellEditorListener(new CellEditorListener() {
                @Override
                public void editingStopped(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }

                @Override
                public void editingCanceled(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }
            });
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            this.value = value;
            expandablePanel.setValue(value);

            return expandablePanel;
        }
    }

    private static class ExpandablePanelCellRenderer implements TableCellRenderer {
        private final ExpandablePanel expandablePanelRenderComponent = new ExpandablePanel();

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            expandablePanelRenderComponent.setValue(value);
            return expandablePanelRenderComponent;
        }
    }
}",            setLayout(new GridBagLayout());,StackOverflow
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import java.awt.*;

public class DynamicCellRow {
    public static void main(String[] args) {

        var contentPane = new JPanel(new BorderLayout());
        contentPane.add(new JScrollPane(makeTable()));

        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""DynamicCellRow"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(contentPane);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

    @NotNull
    private static JTable makeTable() {
        var jTable = new JTable(
                new Object[][]{
                        {""a"", ""charly""},
                        {""b"", ""tango""}
                },
                new Object[]{""id"", ""control""}
        ) {
            @Override
            public void doLayout() {
                super.doLayout();
                adjustRowHeights();
            }

            private void adjustRowHeights() {
                for (int row = 0; row < getRowCount(); row++) {
                    int rowHeight = getRowHeight();

                    for (int column = 0; column < getColumnCount(); column++) {
                        var editorComponent = getEditorComponent();
                        if (getEditingRow() == row && getEditingColumn() == column && editorComponent != null) {
                            editorComponent.setSize(getColumnModel().getColumn(column).getWidth(), 0);
                            rowHeight = Math.max(rowHeight, editorComponent.getPreferredSize().height);
                        } else {
                            var comp = prepareRenderer(getCellRenderer(row, column), row, column);
                            rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
                        }
                    }

                    setRowHeight(row, rowHeight);
                }
            }
        };
        {
            var richColumn = jTable.getColumnModel().getColumn(1);
            richColumn.setCellRenderer(new ExpandablePanelCellRenderer());
            richColumn.setCellEditor(new DynamicExpndablePanelCellEditor());
        }
        return jTable;
    }


    static class ExpandablePanel extends JPanel {

        private final JLabel comp;
        private final JPanel advanced;

        ExpandablePanel() {
            setBorder(BorderFactory.createLineBorder(Color.black));
            setLayout(new GridBagLayout());

            GridBagConstraints gbc = new GridBagConstraints();
            // horizontal left-to-right layout
            gbc.gridx = 0;
            gbc.gridy = 0;

            // resizing behavior
            gbc.weightx = 1;
            gbc.weighty = 1;

            gbc.insets = new Insets(2, 2, 2, 2);
            gbc.fill = GridBagConstraints.BOTH;

            advanced = new JPanel();
            {
                advanced.setLayout(new BoxLayout(advanced, BoxLayout.Y_AXIS));
                advanced.setBorder(new TitledBorder(""Advance Settings""));
                advanced.add(new JCheckBox(""Live""));
                advanced.add(new JCheckBox(""Condition""));
                advanced.add(new JCheckBox(""Disable""));
            }
            advanced.setVisible(false);

            var standard = new JPanel();
            {
                standard.setLayout(new BoxLayout(standard, BoxLayout.X_AXIS));
                comp = new JLabel(""Label 1"");
                standard.add(comp);
                standard.add(new JButton(""Button 1""));
                var expandButton = new JButton(""+"");
                expandButton.addActionListener(e -> {
                    if (advanced.isVisible()) {
                        advanced.setVisible(false);
                        expandButton.setText(""+"");
                    } else {
                        advanced.setVisible(true);
                        expandButton.setText(""-"");
                    }
                });
                standard.add(expandButton);
            }
            add(standard, gbc);


            gbc.gridy++;
            gbc.weighty = 0;
            add(advanced, gbc);
        }

        public void setValue(Object value) {
            comp.setText(value.toString());
        }

        public void setAdvancedVisibility(boolean visible) {
            advanced.setVisible(visible);
        }
    }

    private static class DynamicExpndablePanelCellEditor extends AbstractCellEditor implements TableCellEditor {
        Object value;
        @Override
        public Object getCellEditorValue() {
            return value; // not changing
        }

        private final ExpandablePanel expandablePanel = new ExpandablePanel();
        {
            addCellEditorListener(new CellEditorListener() {
                @Override
                public void editingStopped(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }

                @Override
                public void editingCanceled(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }
            });
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            this.value = value;
            expandablePanel.setValue(value);

            return expandablePanel;
        }
    }

    private static class ExpandablePanelCellRenderer implements TableCellRenderer {
        private final ExpandablePanel expandablePanelRenderComponent = new ExpandablePanel();

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            expandablePanelRenderComponent.setValue(value);
            return expandablePanelRenderComponent;
        }
    }
}","            add(standard, gbc);",StackOverflow
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import java.awt.*;

public class DynamicCellRow {
    public static void main(String[] args) {

        var contentPane = new JPanel(new BorderLayout());
        contentPane.add(new JScrollPane(makeTable()));

        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""DynamicCellRow"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(contentPane);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

    @NotNull
    private static JTable makeTable() {
        var jTable = new JTable(
                new Object[][]{
                        {""a"", ""charly""},
                        {""b"", ""tango""}
                },
                new Object[]{""id"", ""control""}
        ) {
            @Override
            public void doLayout() {
                super.doLayout();
                adjustRowHeights();
            }

            private void adjustRowHeights() {
                for (int row = 0; row < getRowCount(); row++) {
                    int rowHeight = getRowHeight();

                    for (int column = 0; column < getColumnCount(); column++) {
                        var editorComponent = getEditorComponent();
                        if (getEditingRow() == row && getEditingColumn() == column && editorComponent != null) {
                            editorComponent.setSize(getColumnModel().getColumn(column).getWidth(), 0);
                            rowHeight = Math.max(rowHeight, editorComponent.getPreferredSize().height);
                        } else {
                            var comp = prepareRenderer(getCellRenderer(row, column), row, column);
                            rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
                        }
                    }

                    setRowHeight(row, rowHeight);
                }
            }
        };
        {
            var richColumn = jTable.getColumnModel().getColumn(1);
            richColumn.setCellRenderer(new ExpandablePanelCellRenderer());
            richColumn.setCellEditor(new DynamicExpndablePanelCellEditor());
        }
        return jTable;
    }


    static class ExpandablePanel extends JPanel {

        private final JLabel comp;
        private final JPanel advanced;

        ExpandablePanel() {
            setBorder(BorderFactory.createLineBorder(Color.black));
            setLayout(new GridBagLayout());

            GridBagConstraints gbc = new GridBagConstraints();
            // horizontal left-to-right layout
            gbc.gridx = 0;
            gbc.gridy = 0;

            // resizing behavior
            gbc.weightx = 1;
            gbc.weighty = 1;

            gbc.insets = new Insets(2, 2, 2, 2);
            gbc.fill = GridBagConstraints.BOTH;

            advanced = new JPanel();
            {
                advanced.setLayout(new BoxLayout(advanced, BoxLayout.Y_AXIS));
                advanced.setBorder(new TitledBorder(""Advance Settings""));
                advanced.add(new JCheckBox(""Live""));
                advanced.add(new JCheckBox(""Condition""));
                advanced.add(new JCheckBox(""Disable""));
            }
            advanced.setVisible(false);

            var standard = new JPanel();
            {
                standard.setLayout(new BoxLayout(standard, BoxLayout.X_AXIS));
                comp = new JLabel(""Label 1"");
                standard.add(comp);
                standard.add(new JButton(""Button 1""));
                var expandButton = new JButton(""+"");
                expandButton.addActionListener(e -> {
                    if (advanced.isVisible()) {
                        advanced.setVisible(false);
                        expandButton.setText(""+"");
                    } else {
                        advanced.setVisible(true);
                        expandButton.setText(""-"");
                    }
                });
                standard.add(expandButton);
            }
            add(standard, gbc);


            gbc.gridy++;
            gbc.weighty = 0;
            add(advanced, gbc);
        }

        public void setValue(Object value) {
            comp.setText(value.toString());
        }

        public void setAdvancedVisibility(boolean visible) {
            advanced.setVisible(visible);
        }
    }

    private static class DynamicExpndablePanelCellEditor extends AbstractCellEditor implements TableCellEditor {
        Object value;
        @Override
        public Object getCellEditorValue() {
            return value; // not changing
        }

        private final ExpandablePanel expandablePanel = new ExpandablePanel();
        {
            addCellEditorListener(new CellEditorListener() {
                @Override
                public void editingStopped(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }

                @Override
                public void editingCanceled(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }
            });
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            this.value = value;
            expandablePanel.setValue(value);

            return expandablePanel;
        }
    }

    private static class ExpandablePanelCellRenderer implements TableCellRenderer {
        private final ExpandablePanel expandablePanelRenderComponent = new ExpandablePanel();

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            expandablePanelRenderComponent.setValue(value);
            return expandablePanelRenderComponent;
        }
    }
}","            add(advanced, gbc);",StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import java.awt.*;

public class DynamicCellRow {
    public static void main(String[] args) {

        var contentPane = new JPanel(new BorderLayout());
        contentPane.add(new JScrollPane(makeTable()));

        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""DynamicCellRow"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(contentPane);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

    @NotNull
    private static JTable makeTable() {
        var jTable = new JTable(
                new Object[][]{
                        {""a"", ""charly""},
                        {""b"", ""tango""}
                },
                new Object[]{""id"", ""control""}
        ) {
            @Override
            public void doLayout() {
                super.doLayout();
                adjustRowHeights();
            }

            private void adjustRowHeights() {
                for (int row = 0; row < getRowCount(); row++) {
                    int rowHeight = getRowHeight();

                    for (int column = 0; column < getColumnCount(); column++) {
                        var editorComponent = getEditorComponent();
                        if (getEditingRow() == row && getEditingColumn() == column && editorComponent != null) {
                            editorComponent.setSize(getColumnModel().getColumn(column).getWidth(), 0);
                            rowHeight = Math.max(rowHeight, editorComponent.getPreferredSize().height);
                        } else {
                            var comp = prepareRenderer(getCellRenderer(row, column), row, column);
                            rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
                        }
                    }

                    setRowHeight(row, rowHeight);
                }
            }
        };
        {
            var richColumn = jTable.getColumnModel().getColumn(1);
            richColumn.setCellRenderer(new ExpandablePanelCellRenderer());
            richColumn.setCellEditor(new DynamicExpndablePanelCellEditor());
        }
        return jTable;
    }


    static class ExpandablePanel extends JPanel {

        private final JLabel comp;
        private final JPanel advanced;

        ExpandablePanel() {
            setBorder(BorderFactory.createLineBorder(Color.black));
            setLayout(new GridBagLayout());

            GridBagConstraints gbc = new GridBagConstraints();
            // horizontal left-to-right layout
            gbc.gridx = 0;
            gbc.gridy = 0;

            // resizing behavior
            gbc.weightx = 1;
            gbc.weighty = 1;

            gbc.insets = new Insets(2, 2, 2, 2);
            gbc.fill = GridBagConstraints.BOTH;

            advanced = new JPanel();
            {
                advanced.setLayout(new BoxLayout(advanced, BoxLayout.Y_AXIS));
                advanced.setBorder(new TitledBorder(""Advance Settings""));
                advanced.add(new JCheckBox(""Live""));
                advanced.add(new JCheckBox(""Condition""));
                advanced.add(new JCheckBox(""Disable""));
            }
            advanced.setVisible(false);

            var standard = new JPanel();
            {
                standard.setLayout(new BoxLayout(standard, BoxLayout.X_AXIS));
                comp = new JLabel(""Label 1"");
                standard.add(comp);
                standard.add(new JButton(""Button 1""));
                var expandButton = new JButton(""+"");
                expandButton.addActionListener(e -> {
                    if (advanced.isVisible()) {
                        advanced.setVisible(false);
                        expandButton.setText(""+"");
                    } else {
                        advanced.setVisible(true);
                        expandButton.setText(""-"");
                    }
                });
                standard.add(expandButton);
            }
            add(standard, gbc);


            gbc.gridy++;
            gbc.weighty = 0;
            add(advanced, gbc);
        }

        public void setValue(Object value) {
            comp.setText(value.toString());
        }

        public void setAdvancedVisibility(boolean visible) {
            advanced.setVisible(visible);
        }
    }

    private static class DynamicExpndablePanelCellEditor extends AbstractCellEditor implements TableCellEditor {
        Object value;
        @Override
        public Object getCellEditorValue() {
            return value; // not changing
        }

        private final ExpandablePanel expandablePanel = new ExpandablePanel();
        {
            addCellEditorListener(new CellEditorListener() {
                @Override
                public void editingStopped(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }

                @Override
                public void editingCanceled(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }
            });
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            this.value = value;
            expandablePanel.setValue(value);

            return expandablePanel;
        }
    }

    private static class ExpandablePanelCellRenderer implements TableCellRenderer {
        private final ExpandablePanel expandablePanelRenderComponent = new ExpandablePanel();

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            expandablePanelRenderComponent.setValue(value);
            return expandablePanelRenderComponent;
        }
    }
}",    private static class DynamicExpndablePanelCellEditor extends AbstractCellEditor implements TableCellEditor {,StackOverflow
NonStaticInitializer,Non-static initializers are confusing,"import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import java.awt.*;

public class DynamicCellRow {
    public static void main(String[] args) {

        var contentPane = new JPanel(new BorderLayout());
        contentPane.add(new JScrollPane(makeTable()));

        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""DynamicCellRow"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(contentPane);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

    @NotNull
    private static JTable makeTable() {
        var jTable = new JTable(
                new Object[][]{
                        {""a"", ""charly""},
                        {""b"", ""tango""}
                },
                new Object[]{""id"", ""control""}
        ) {
            @Override
            public void doLayout() {
                super.doLayout();
                adjustRowHeights();
            }

            private void adjustRowHeights() {
                for (int row = 0; row < getRowCount(); row++) {
                    int rowHeight = getRowHeight();

                    for (int column = 0; column < getColumnCount(); column++) {
                        var editorComponent = getEditorComponent();
                        if (getEditingRow() == row && getEditingColumn() == column && editorComponent != null) {
                            editorComponent.setSize(getColumnModel().getColumn(column).getWidth(), 0);
                            rowHeight = Math.max(rowHeight, editorComponent.getPreferredSize().height);
                        } else {
                            var comp = prepareRenderer(getCellRenderer(row, column), row, column);
                            rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
                        }
                    }

                    setRowHeight(row, rowHeight);
                }
            }
        };
        {
            var richColumn = jTable.getColumnModel().getColumn(1);
            richColumn.setCellRenderer(new ExpandablePanelCellRenderer());
            richColumn.setCellEditor(new DynamicExpndablePanelCellEditor());
        }
        return jTable;
    }


    static class ExpandablePanel extends JPanel {

        private final JLabel comp;
        private final JPanel advanced;

        ExpandablePanel() {
            setBorder(BorderFactory.createLineBorder(Color.black));
            setLayout(new GridBagLayout());

            GridBagConstraints gbc = new GridBagConstraints();
            // horizontal left-to-right layout
            gbc.gridx = 0;
            gbc.gridy = 0;

            // resizing behavior
            gbc.weightx = 1;
            gbc.weighty = 1;

            gbc.insets = new Insets(2, 2, 2, 2);
            gbc.fill = GridBagConstraints.BOTH;

            advanced = new JPanel();
            {
                advanced.setLayout(new BoxLayout(advanced, BoxLayout.Y_AXIS));
                advanced.setBorder(new TitledBorder(""Advance Settings""));
                advanced.add(new JCheckBox(""Live""));
                advanced.add(new JCheckBox(""Condition""));
                advanced.add(new JCheckBox(""Disable""));
            }
            advanced.setVisible(false);

            var standard = new JPanel();
            {
                standard.setLayout(new BoxLayout(standard, BoxLayout.X_AXIS));
                comp = new JLabel(""Label 1"");
                standard.add(comp);
                standard.add(new JButton(""Button 1""));
                var expandButton = new JButton(""+"");
                expandButton.addActionListener(e -> {
                    if (advanced.isVisible()) {
                        advanced.setVisible(false);
                        expandButton.setText(""+"");
                    } else {
                        advanced.setVisible(true);
                        expandButton.setText(""-"");
                    }
                });
                standard.add(expandButton);
            }
            add(standard, gbc);


            gbc.gridy++;
            gbc.weighty = 0;
            add(advanced, gbc);
        }

        public void setValue(Object value) {
            comp.setText(value.toString());
        }

        public void setAdvancedVisibility(boolean visible) {
            advanced.setVisible(visible);
        }
    }

    private static class DynamicExpndablePanelCellEditor extends AbstractCellEditor implements TableCellEditor {
        Object value;
        @Override
        public Object getCellEditorValue() {
            return value; // not changing
        }

        private final ExpandablePanel expandablePanel = new ExpandablePanel();
        {
            addCellEditorListener(new CellEditorListener() {
                @Override
                public void editingStopped(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }

                @Override
                public void editingCanceled(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }
            });
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            this.value = value;
            expandablePanel.setValue(value);

            return expandablePanel;
        }
    }

    private static class ExpandablePanelCellRenderer implements TableCellRenderer {
        private final ExpandablePanel expandablePanelRenderComponent = new ExpandablePanel();

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            expandablePanelRenderComponent.setValue(value);
            return expandablePanelRenderComponent;
        }
    }
}","        {
            addCellEditorListener(new CellEditorListener() {
                @Override
                public void editingStopped(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }

                @Override
                public void editingCanceled(ChangeEvent e) {
                    expandablePanel.setAdvancedVisibility(false);
                }
            });
        }",StackOverflow
AvoidDuplicateLiterals,"The String literal ""name"" appears 4 times in this file; the first occurrence is on line 10","import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;

abstract class Animal {
  private final String name;
  private final int age;

  @JsonCreator
  protected Animal(@JsonProperty(""name"") String name, @JsonProperty(""age"") int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }
}

final class Dog extends Animal {
  private final int barkLoudness;
  private final int treatsToday;

  @JsonCreator
  public Dog(
    @JsonProperty(""name"") String name, 
    @JsonProperty(""age"") int age, 
    @JsonProperty(""barkLoudness"") int barkLoudness, 
    @JsonProperty(""treatsToday"") int treatsToday
  ) {
    super(name, age);
    this.barkLoudness = barkLoudness;
    this.treatsToday = treatsToday;
  }

  public int getBarkLoudness() {
    return barkLoudness;
  }

  public int getTreatsToday() {
    return treatsToday;
  }
}

final class Cat extends Animal {
  private final String color;

  @JsonCreator
  public Cat(
    @JsonProperty(""name"") String name, 
    @JsonProperty(""age"") int age, 
    @JsonProperty(""color"") String color
  ) {
    super(name, age);
    this.color = color;
  }

  public String getColor() {
    return color;
  }
}

final class Fish extends Animal {
  private final String blub;

  @JsonCreator
  public Fish(
    @JsonProperty(""name"") String name, 
    @JsonProperty(""age"") int age, 
    @JsonProperty(""blub"") String blub
  ) {
    super(name, age);
    this.blub = blub;
  }

  public String getBlub() {
    return blub;
  }
}

public class Main {
  public static void main(String[] args) throws Exception {
    ObjectMapper mapper = new ObjectMapper();

    String dogJson = """"""
    {
      ""name"": ""Fido"",
      ""age"": 5,
      ""barkLoudness"": 8,
      ""treatsToday"": 2
    }
    """""";
    Dog dog = mapper.readValue(dogJson, Dog.class);
    System.out.println(""Dog: "" + dog.getName() + "", Age: "" + dog.getAge() + 
               "", Bark Loudness: "" + dog.getBarkLoudness() + 
               "", Treats Today: "" + dog.getTreatsToday());

    String catJson = """"""
    {
      ""name"": ""Fluffy"",
      ""age"": 2,
      ""color"": ""white""
    }
    """""";
    Cat cat = mapper.readValue(catJson, Cat.class);
    System.out.println(""Cat: "" + cat.getName() + "", Age: "" + cat.getAge() + 
               "", Color: "" + cat.getColor());

    String fishJson = """"""
    {
      ""name"": ""Professor"",
      ""age"": 1,
      ""blub"": ""blub""
    }
    """""";
    Fish fish = mapper.readValue(fishJson, Fish.class);
    System.out.println(""Fish: "" + fish.getName() + "", Age: "" + fish.getAge() + 
               "", Blub: "" + fish.getBlub());
  }
}","  protected Animal(@JsonProperty(""name"") String name, @JsonProperty(""age"") int age) {",StackOverflow
AvoidDuplicateLiterals,"The String literal ""age"" appears 4 times in this file; the first occurrence is on line 10","import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;

abstract class Animal {
  private final String name;
  private final int age;

  @JsonCreator
  protected Animal(@JsonProperty(""name"") String name, @JsonProperty(""age"") int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }
}

final class Dog extends Animal {
  private final int barkLoudness;
  private final int treatsToday;

  @JsonCreator
  public Dog(
    @JsonProperty(""name"") String name, 
    @JsonProperty(""age"") int age, 
    @JsonProperty(""barkLoudness"") int barkLoudness, 
    @JsonProperty(""treatsToday"") int treatsToday
  ) {
    super(name, age);
    this.barkLoudness = barkLoudness;
    this.treatsToday = treatsToday;
  }

  public int getBarkLoudness() {
    return barkLoudness;
  }

  public int getTreatsToday() {
    return treatsToday;
  }
}

final class Cat extends Animal {
  private final String color;

  @JsonCreator
  public Cat(
    @JsonProperty(""name"") String name, 
    @JsonProperty(""age"") int age, 
    @JsonProperty(""color"") String color
  ) {
    super(name, age);
    this.color = color;
  }

  public String getColor() {
    return color;
  }
}

final class Fish extends Animal {
  private final String blub;

  @JsonCreator
  public Fish(
    @JsonProperty(""name"") String name, 
    @JsonProperty(""age"") int age, 
    @JsonProperty(""blub"") String blub
  ) {
    super(name, age);
    this.blub = blub;
  }

  public String getBlub() {
    return blub;
  }
}

public class Main {
  public static void main(String[] args) throws Exception {
    ObjectMapper mapper = new ObjectMapper();

    String dogJson = """"""
    {
      ""name"": ""Fido"",
      ""age"": 5,
      ""barkLoudness"": 8,
      ""treatsToday"": 2
    }
    """""";
    Dog dog = mapper.readValue(dogJson, Dog.class);
    System.out.println(""Dog: "" + dog.getName() + "", Age: "" + dog.getAge() + 
               "", Bark Loudness: "" + dog.getBarkLoudness() + 
               "", Treats Today: "" + dog.getTreatsToday());

    String catJson = """"""
    {
      ""name"": ""Fluffy"",
      ""age"": 2,
      ""color"": ""white""
    }
    """""";
    Cat cat = mapper.readValue(catJson, Cat.class);
    System.out.println(""Cat: "" + cat.getName() + "", Age: "" + cat.getAge() + 
               "", Color: "" + cat.getColor());

    String fishJson = """"""
    {
      ""name"": ""Professor"",
      ""age"": 1,
      ""blub"": ""blub""
    }
    """""";
    Fish fish = mapper.readValue(fishJson, Fish.class);
    System.out.println(""Fish: "" + fish.getName() + "", Age: "" + fish.getAge() + 
               "", Blub: "" + fish.getBlub());
  }
}","  protected Animal(@JsonProperty(""name"") String name, @JsonProperty(""age"") int age) {",StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.FileOutputStream;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.hssf.usermodel.*;
import org.apache.poi.xssf.usermodel.*;
import org.apache.poi.hssf.util.HSSFColor;

public class CreateExcelCellFillCustomColor {

 public static void main(String[] args) throws Exception {

  byte[] rgb = new byte[]{(byte) 60, (byte) 120, (byte) 216};

  Workbook workbook = new HSSFWorkbook(); String filePath = ""./Excel.xls"";
  //Workbook workbook = new XSSFWorkbook(); String filePath = ""./Excel.xlsx"";

  CellStyle cellStyle = workbook.createCellStyle();
  cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);
  if (workbook instanceof XSSFWorkbook) {
   XSSFColor color = new XSSFColor(rgb, null);
   cellStyle.setFillForegroundColor(color);
  } else if (workbook instanceof HSSFWorkbook) {
   HSSFWorkbook hssfworkbook = (HSSFWorkbook)workbook;
   HSSFPalette palette = hssfworkbook.getCustomPalette();
   palette.setColorAtIndex(HSSFColor.HSSFColorPredefined.LIME.getIndex(), rgb[0], rgb[1], rgb[2]);
   HSSFColor color = palette.findSimilarColor(rgb[0], rgb[1], rgb[2]);
   //cellStyle.setFillForegroundColor(color); // does not work correctly for HSSF
   cellStyle.setFillForegroundColor(color.getIndex());   
  }
  
  Sheet sheet = workbook.createSheet();
  Cell cell = sheet.createRow(0).createCell(0);
  cell.setCellStyle(cellStyle);
  cell.setCellValue(""test"");

  FileOutputStream out = new FileOutputStream(filePath);
  workbook.write(out);
  out.close();
  workbook.close();

 }

}",  FileOutputStream out = new FileOutputStream(filePath);,StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.IOException;

import org.apache.poi.util.Units;

import org.apache.poi.xwpf.usermodel.*;

import org.apache.poi.xwpf.model.XWPFHeaderFooterPolicy;
import org.apache.poi.wp.usermodel.HeaderFooterType;

import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSectPr;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPageSz;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPageMar;

import java.math.BigInteger;

public class CreateWordHeaderFooter {

 public static void main(String[] args) throws Exception {

  XWPFDocument document = new XWPFDocument();

  // the body content - two pages
  XWPFParagraph paragraph = document.createParagraph();
  XWPFRun run=paragraph.createRun();  
  run.setText(""The Body:"");

  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.setText(""First Page...."");
  
  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.addBreak(BreakType.PAGE);

  paragraph = document.createParagraph();
  run=paragraph.createRun();  
  run.setText(""Second Page...."");
    
  
  // first page header
  XWPFHeader header = document.createHeader(HeaderFooterType.FIRST);

  paragraph = header.getParagraphArray(0);
  if (paragraph == null) paragraph = header.createParagraph();
  paragraph.setAlignment(ParagraphAlignment.CENTER);
  
  // set spacing after paragraph 0
  paragraph.setSpacingAfter(0);
  // set spacing between lines in paragraph to 1 (single)
  paragraph.setSpacingBetween(1d, LineSpacingRule.AUTO);

  // the image is inline with text so the paragraph settings matters
  run = paragraph.createRun();  
  String imgFile=""./laptop.jpg"";

  // calculate page inner width to set the picture's width the same
  long pageInnerWidthPt = Math.round(7.5 * 72d); //8.5"" page width - 0.5"" left margin - 0.5"" right margin = 7.5""
  run.addPicture(new FileInputStream(imgFile), XWPFDocument.PICTURE_TYPE_JPEG, imgFile, Units.toEMU(pageInnerWidthPt), Units.toEMU(200));
  
  // default page header
  header = document.createHeader(HeaderFooterType.DEFAULT);
  paragraph = header.getParagraphArray(0);
  if (paragraph == null) paragraph = header.createParagraph();
  // set spacing after to 24 pt to shift the body down in default pages
  paragraph.setSpacingAfter(24*20);

  // create footer start
  XWPFFooter footer = document.createFooter(HeaderFooterType.DEFAULT);

  paragraph = footer.createParagraph();
  paragraph.setAlignment(ParagraphAlignment.CENTER);

  run = paragraph.createRun();  
  run.setText(""The Footer:"");
  
  // create page margins
  CTSectPr sectPr = document.getDocument().getBody().getSectPr();
  if (sectPr == null) sectPr = document.getDocument().getBody().addNewSectPr();
  CTPageSz pageSz = sectPr.addNewPgSz(); // paper format letter
  pageSz.setW(BigInteger.valueOf(12240)); //12240 Twips = 12240/20 = 612 pt = 612/72 = 8.5""
  pageSz.setH(BigInteger.valueOf(15840)); //15840 Twips = 15840/20 = 792 pt = 792/72 = 11""
  CTPageMar pageMar = sectPr.getPgMar();
  if (pageMar == null) pageMar = sectPr.addNewPgMar();
  pageMar.setLeft(BigInteger.valueOf(720)); //720 TWentieths of an Inch Point (Twips) = 720/20 = 36 pt = 36/72 = 0.5""
  pageMar.setRight(BigInteger.valueOf(720));
  // set top page margin 0, so header can be at absolute top
  pageMar.setTop(BigInteger.valueOf(0));
  //pageMar.setBottom(BigInteger.valueOf(0));
  //pageMar.setFooter(BigInteger.valueOf(0));
  // set distance between header and page margin 0, so header starts at absolute top
  pageMar.setHeader(BigInteger.valueOf(0));
  //pageMar.setGutter(BigInteger.valueOf(0));

  FileOutputStream out = new FileOutputStream(""./test.docx"");
  document.write(out);
  out.close();
  document.close();

 }
}","  FileOutputStream out = new FileOutputStream(""./test.docx"");",StackOverflow
TestClassWithoutTestCases,"The class 'RecipeApiApplicationTests' might be a test class, but it contains no test cases.","@WebMvcTest(RecipeController.class)
@ActiveProfiles(profiles = ""test"")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Import(SecurityConfig.class)
public class RecipeApiApplicationTests {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private RecipeService recipeService;

    // Create some test users
    // user for recipes
    UserMeta userMeta = UserMeta.builder().email(""recipe@gmail.com"").name(""recipeUser1"").build();
    Role role = Role.builder().role(Role.Roles.ROLE_USER).build();
    Set<Role> roles = Set.of(role);
    CustomUserDetails userRecipe = CustomUserDetails.builder().userMeta(userMeta).username(""userRecipe"").password(""1234"").authorities(roles).build();
    // user for reviews
    UserMeta userMeta1 = UserMeta.builder().email(""review@gmail.com"").name(""reviewUser"").build();
    CustomUserDetails userReview = CustomUserDetails.builder().userMeta(userMeta1).username(""userReview"").password(""1234"").authorities(roles).build();

    // Create some test recipes
    Review review = Review.builder().description(""was just caramel"").rating(3).user(userReview).build();
    Review review2 = Review.builder().description(""was just egg"").rating(4).user(userReview).build();

    Recipe recipe = Recipe.builder().name(""test name"").difficultyRating(1).minutesToMake(5)
            .ingredients(Set.of(Ingredient.builder().name(""spam"").amount(""1 can"").build()))
            .steps(Set.of(Step.builder().stepNumber(1).description(""eat spam"").build()))
            .locationURI(new URI(""http://localhost:8080/recipes/1""))
            .reviews(Set.of(review))
            .id(1L)
            .user(userRecipe)
            .build();
    Recipe recipe2 = Recipe.builder().name(""test name2"").difficultyRating(2).minutesToMake(6)
            .ingredients(Set.of(Ingredient.builder().name(""egg"").amount(""1 egg"").build()))
            .steps(Set.of(Step.builder().stepNumber(1).description(""crack egg"").build()))
            .locationURI(new URI(""http://localhost:8080/recipes/2""))
            .reviews(Set.of(review2))
            .id(2L)
            .user(userRecipe)
            .build();
    ArrayList<Recipe> recipes = new ArrayList<>(Arrays.asList(recipe, recipe2));

@Test
    @Order(4)
    @WithMockUser(""userRecipe"")
    public void testCreateNewRecipeSuccessBehavior() throws Exception {
        when(recipeService.createNewRecipe(any(Recipe.class), any(Authentication.class))).thenReturn(recipe);

        mockMvc.perform(post(""/recipes"")//.with(user(userRecipe))
                        //set request Content-Type header
                        .contentType(""application/json"")
                        //set HTTP body equal to JSON based on recipe object
                        .content(TestUtil.convertObjectToJsonBytes(recipe))
                )
                //confirm HTTP response meta
                .andExpect(status().isCreated())
                .andExpect(content().contentType(""application/json""))
                //confirm Location header with new location of object matches the correct URL structure
                .andExpect(header().string(""Location"", containsString(""http://localhost:8080/recipes/1"")))

                //confirm some recipe data
                .andExpect(jsonPath(""id"").value(1))
                .andExpect(jsonPath(""name"").value(""test name""))

                //confirm ingredient data
                .andExpect(jsonPath(""ingredients"", hasSize(1)))
                .andExpect(jsonPath(""ingredients[0].name"").value(""spam""))
                .andExpect(jsonPath(""ingredients[0].amount"").value(""1 can""))

                //confirm step data
                .andExpect(jsonPath(""steps"", hasSize(1)))
                .andExpect(jsonPath(""steps[0]"").isNotEmpty())

                //confirm review data
                .andExpect(jsonPath(""reviews"", hasSize(1)))
                .andExpect(jsonPath(""reviews[0].author"").value(""userReview""));
    }
}",public class RecipeApiApplicationTests {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.Timer;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new TestPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class TestPane extends JPanel {

        enum Direction {
            LEFT, RIGHT;
        }

        protected enum InputAction {
            PRESSED_LEFT, PRESSED_RIGHT, RELEASED_LEFT, RELEASED_RIGHT
        }

        private BufferedImage car;
        private BufferedImage road;

        private Set<Direction> directions = new TreeSet<>();

        private double directionOfRotation = 0;

        public TestPane() throws IOException {
            car = ImageIO.read(getClass().getResource(""/images/Car.png""));
            road = ImageIO.read(getClass().getResource(""/images/Road.png""));

            InputMap im = getInputMap(WHEN_IN_FOCUSED_WINDOW);
            ActionMap am = getActionMap();

            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, false), InputAction.PRESSED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, true), InputAction.RELEASED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, false), InputAction.PRESSED_RIGHT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, true), InputAction.RELEASED_RIGHT);

            am.put(InputAction.PRESSED_LEFT, new DirectionAction(Direction.LEFT, true));
            am.put(InputAction.RELEASED_LEFT, new DirectionAction(Direction.LEFT, false));
            am.put(InputAction.PRESSED_RIGHT, new DirectionAction(Direction.RIGHT, true));
            am.put(InputAction.RELEASED_RIGHT, new DirectionAction(Direction.RIGHT, false));

            Timer timer = new Timer(5, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if (directions.contains(Direction.RIGHT)) {
                        directionOfRotation += 1;
                    } else if (directions.contains(Direction.LEFT)) {
                        directionOfRotation -= 1;
                    }

                    // No doughnuts for you :P
                    if (directionOfRotation > 180) {
                        directionOfRotation = 180;
                    } else if (directionOfRotation < -180) {
                        directionOfRotation = -180;
                    }

                    repaint();
                }
            });
            timer.start();
        }

        protected void setDirectionActive(Direction direction, boolean active) {
            if (active) {
                directions.add(direction);
            } else {
                directions.remove(direction);
            }
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(213, 216);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            drawRoadSurface(g2d);
            drawCar(g2d);
            g2d.dispose();
        }

        protected void drawCar(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            int x = (getWidth() - car.getWidth()) / 2;
            int y = (getHeight() - car.getHeight()) / 2;
            g2d.drawImage(car, x, y, this);
            g2d.dispose();
        }

        protected void drawRoadSurface(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            // This sets the point of rotation at the center of the window
            int midX = getWidth() / 2;
            int midY = getHeight() / 2;
            g2d.rotate(Math.toRadians(directionOfRotation), midX, midY);
            // We then need to offset the top/left corner so that what 
            // we want draw appears to be in the center of the window,
            // and thus will be rotated around it's center
            int x = midX - (road.getWidth() / 2);
            int y = midY - (road.getHeight() / 2);
            g2d.drawImage(road, x, y, this);
            g2d.dispose();
        }

        protected class DirectionAction extends AbstractAction {

            private Direction direction;
            private boolean active;

            public DirectionAction(Direction direction, boolean active) {
                this.direction = direction;
                this.active = active;
            }

            @Override
            public void actionPerformed(ActionEvent e) {
                setDirectionActive(direction, active);
            }

        }

    }
}",    public class TestPane extends JPanel {,StackOverflow
TestClassWithoutTestCases,"The class 'TestPane' might be a test class, but it contains no test cases.","import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.Timer;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new TestPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class TestPane extends JPanel {

        enum Direction {
            LEFT, RIGHT;
        }

        protected enum InputAction {
            PRESSED_LEFT, PRESSED_RIGHT, RELEASED_LEFT, RELEASED_RIGHT
        }

        private BufferedImage car;
        private BufferedImage road;

        private Set<Direction> directions = new TreeSet<>();

        private double directionOfRotation = 0;

        public TestPane() throws IOException {
            car = ImageIO.read(getClass().getResource(""/images/Car.png""));
            road = ImageIO.read(getClass().getResource(""/images/Road.png""));

            InputMap im = getInputMap(WHEN_IN_FOCUSED_WINDOW);
            ActionMap am = getActionMap();

            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, false), InputAction.PRESSED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, true), InputAction.RELEASED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, false), InputAction.PRESSED_RIGHT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, true), InputAction.RELEASED_RIGHT);

            am.put(InputAction.PRESSED_LEFT, new DirectionAction(Direction.LEFT, true));
            am.put(InputAction.RELEASED_LEFT, new DirectionAction(Direction.LEFT, false));
            am.put(InputAction.PRESSED_RIGHT, new DirectionAction(Direction.RIGHT, true));
            am.put(InputAction.RELEASED_RIGHT, new DirectionAction(Direction.RIGHT, false));

            Timer timer = new Timer(5, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if (directions.contains(Direction.RIGHT)) {
                        directionOfRotation += 1;
                    } else if (directions.contains(Direction.LEFT)) {
                        directionOfRotation -= 1;
                    }

                    // No doughnuts for you :P
                    if (directionOfRotation > 180) {
                        directionOfRotation = 180;
                    } else if (directionOfRotation < -180) {
                        directionOfRotation = -180;
                    }

                    repaint();
                }
            });
            timer.start();
        }

        protected void setDirectionActive(Direction direction, boolean active) {
            if (active) {
                directions.add(direction);
            } else {
                directions.remove(direction);
            }
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(213, 216);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            drawRoadSurface(g2d);
            drawCar(g2d);
            g2d.dispose();
        }

        protected void drawCar(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            int x = (getWidth() - car.getWidth()) / 2;
            int y = (getHeight() - car.getHeight()) / 2;
            g2d.drawImage(car, x, y, this);
            g2d.dispose();
        }

        protected void drawRoadSurface(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            // This sets the point of rotation at the center of the window
            int midX = getWidth() / 2;
            int midY = getHeight() / 2;
            g2d.rotate(Math.toRadians(directionOfRotation), midX, midY);
            // We then need to offset the top/left corner so that what 
            // we want draw appears to be in the center of the window,
            // and thus will be rotated around it's center
            int x = midX - (road.getWidth() / 2);
            int y = midY - (road.getHeight() / 2);
            g2d.drawImage(road, x, y, this);
            g2d.dispose();
        }

        protected class DirectionAction extends AbstractAction {

            private Direction direction;
            private boolean active;

            public DirectionAction(Direction direction, boolean active) {
                this.direction = direction;
                this.active = active;
            }

            @Override
            public void actionPerformed(ActionEvent e) {
                setDirectionActive(direction, active);
            }

        }

    }
}",    public class TestPane extends JPanel {,StackOverflow
NonSerializableClass,The field 'car' of serializable class 'Main$TestPane' is of non-serializable type 'java.awt.image.BufferedImage'.,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.Timer;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new TestPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class TestPane extends JPanel {

        enum Direction {
            LEFT, RIGHT;
        }

        protected enum InputAction {
            PRESSED_LEFT, PRESSED_RIGHT, RELEASED_LEFT, RELEASED_RIGHT
        }

        private BufferedImage car;
        private BufferedImage road;

        private Set<Direction> directions = new TreeSet<>();

        private double directionOfRotation = 0;

        public TestPane() throws IOException {
            car = ImageIO.read(getClass().getResource(""/images/Car.png""));
            road = ImageIO.read(getClass().getResource(""/images/Road.png""));

            InputMap im = getInputMap(WHEN_IN_FOCUSED_WINDOW);
            ActionMap am = getActionMap();

            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, false), InputAction.PRESSED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, true), InputAction.RELEASED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, false), InputAction.PRESSED_RIGHT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, true), InputAction.RELEASED_RIGHT);

            am.put(InputAction.PRESSED_LEFT, new DirectionAction(Direction.LEFT, true));
            am.put(InputAction.RELEASED_LEFT, new DirectionAction(Direction.LEFT, false));
            am.put(InputAction.PRESSED_RIGHT, new DirectionAction(Direction.RIGHT, true));
            am.put(InputAction.RELEASED_RIGHT, new DirectionAction(Direction.RIGHT, false));

            Timer timer = new Timer(5, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if (directions.contains(Direction.RIGHT)) {
                        directionOfRotation += 1;
                    } else if (directions.contains(Direction.LEFT)) {
                        directionOfRotation -= 1;
                    }

                    // No doughnuts for you :P
                    if (directionOfRotation > 180) {
                        directionOfRotation = 180;
                    } else if (directionOfRotation < -180) {
                        directionOfRotation = -180;
                    }

                    repaint();
                }
            });
            timer.start();
        }

        protected void setDirectionActive(Direction direction, boolean active) {
            if (active) {
                directions.add(direction);
            } else {
                directions.remove(direction);
            }
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(213, 216);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            drawRoadSurface(g2d);
            drawCar(g2d);
            g2d.dispose();
        }

        protected void drawCar(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            int x = (getWidth() - car.getWidth()) / 2;
            int y = (getHeight() - car.getHeight()) / 2;
            g2d.drawImage(car, x, y, this);
            g2d.dispose();
        }

        protected void drawRoadSurface(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            // This sets the point of rotation at the center of the window
            int midX = getWidth() / 2;
            int midY = getHeight() / 2;
            g2d.rotate(Math.toRadians(directionOfRotation), midX, midY);
            // We then need to offset the top/left corner so that what 
            // we want draw appears to be in the center of the window,
            // and thus will be rotated around it's center
            int x = midX - (road.getWidth() / 2);
            int y = midY - (road.getHeight() / 2);
            g2d.drawImage(road, x, y, this);
            g2d.dispose();
        }

        protected class DirectionAction extends AbstractAction {

            private Direction direction;
            private boolean active;

            public DirectionAction(Direction direction, boolean active) {
                this.direction = direction;
                this.active = active;
            }

            @Override
            public void actionPerformed(ActionEvent e) {
                setDirectionActive(direction, active);
            }

        }

    }
}",        private BufferedImage car;,StackOverflow
NonSerializableClass,The field 'road' of serializable class 'Main$TestPane' is of non-serializable type 'java.awt.image.BufferedImage'.,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.Timer;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new TestPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class TestPane extends JPanel {

        enum Direction {
            LEFT, RIGHT;
        }

        protected enum InputAction {
            PRESSED_LEFT, PRESSED_RIGHT, RELEASED_LEFT, RELEASED_RIGHT
        }

        private BufferedImage car;
        private BufferedImage road;

        private Set<Direction> directions = new TreeSet<>();

        private double directionOfRotation = 0;

        public TestPane() throws IOException {
            car = ImageIO.read(getClass().getResource(""/images/Car.png""));
            road = ImageIO.read(getClass().getResource(""/images/Road.png""));

            InputMap im = getInputMap(WHEN_IN_FOCUSED_WINDOW);
            ActionMap am = getActionMap();

            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, false), InputAction.PRESSED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, true), InputAction.RELEASED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, false), InputAction.PRESSED_RIGHT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, true), InputAction.RELEASED_RIGHT);

            am.put(InputAction.PRESSED_LEFT, new DirectionAction(Direction.LEFT, true));
            am.put(InputAction.RELEASED_LEFT, new DirectionAction(Direction.LEFT, false));
            am.put(InputAction.PRESSED_RIGHT, new DirectionAction(Direction.RIGHT, true));
            am.put(InputAction.RELEASED_RIGHT, new DirectionAction(Direction.RIGHT, false));

            Timer timer = new Timer(5, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if (directions.contains(Direction.RIGHT)) {
                        directionOfRotation += 1;
                    } else if (directions.contains(Direction.LEFT)) {
                        directionOfRotation -= 1;
                    }

                    // No doughnuts for you :P
                    if (directionOfRotation > 180) {
                        directionOfRotation = 180;
                    } else if (directionOfRotation < -180) {
                        directionOfRotation = -180;
                    }

                    repaint();
                }
            });
            timer.start();
        }

        protected void setDirectionActive(Direction direction, boolean active) {
            if (active) {
                directions.add(direction);
            } else {
                directions.remove(direction);
            }
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(213, 216);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            drawRoadSurface(g2d);
            drawCar(g2d);
            g2d.dispose();
        }

        protected void drawCar(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            int x = (getWidth() - car.getWidth()) / 2;
            int y = (getHeight() - car.getHeight()) / 2;
            g2d.drawImage(car, x, y, this);
            g2d.dispose();
        }

        protected void drawRoadSurface(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            // This sets the point of rotation at the center of the window
            int midX = getWidth() / 2;
            int midY = getHeight() / 2;
            g2d.rotate(Math.toRadians(directionOfRotation), midX, midY);
            // We then need to offset the top/left corner so that what 
            // we want draw appears to be in the center of the window,
            // and thus will be rotated around it's center
            int x = midX - (road.getWidth() / 2);
            int y = midY - (road.getHeight() / 2);
            g2d.drawImage(road, x, y, this);
            g2d.dispose();
        }

        protected class DirectionAction extends AbstractAction {

            private Direction direction;
            private boolean active;

            public DirectionAction(Direction direction, boolean active) {
                this.direction = direction;
                this.active = active;
            }

            @Override
            public void actionPerformed(ActionEvent e) {
                setDirectionActive(direction, active);
            }

        }

    }
}",        private BufferedImage road;,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.Timer;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new TestPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class TestPane extends JPanel {

        enum Direction {
            LEFT, RIGHT;
        }

        protected enum InputAction {
            PRESSED_LEFT, PRESSED_RIGHT, RELEASED_LEFT, RELEASED_RIGHT
        }

        private BufferedImage car;
        private BufferedImage road;

        private Set<Direction> directions = new TreeSet<>();

        private double directionOfRotation = 0;

        public TestPane() throws IOException {
            car = ImageIO.read(getClass().getResource(""/images/Car.png""));
            road = ImageIO.read(getClass().getResource(""/images/Road.png""));

            InputMap im = getInputMap(WHEN_IN_FOCUSED_WINDOW);
            ActionMap am = getActionMap();

            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, false), InputAction.PRESSED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, true), InputAction.RELEASED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, false), InputAction.PRESSED_RIGHT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, true), InputAction.RELEASED_RIGHT);

            am.put(InputAction.PRESSED_LEFT, new DirectionAction(Direction.LEFT, true));
            am.put(InputAction.RELEASED_LEFT, new DirectionAction(Direction.LEFT, false));
            am.put(InputAction.PRESSED_RIGHT, new DirectionAction(Direction.RIGHT, true));
            am.put(InputAction.RELEASED_RIGHT, new DirectionAction(Direction.RIGHT, false));

            Timer timer = new Timer(5, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if (directions.contains(Direction.RIGHT)) {
                        directionOfRotation += 1;
                    } else if (directions.contains(Direction.LEFT)) {
                        directionOfRotation -= 1;
                    }

                    // No doughnuts for you :P
                    if (directionOfRotation > 180) {
                        directionOfRotation = 180;
                    } else if (directionOfRotation < -180) {
                        directionOfRotation = -180;
                    }

                    repaint();
                }
            });
            timer.start();
        }

        protected void setDirectionActive(Direction direction, boolean active) {
            if (active) {
                directions.add(direction);
            } else {
                directions.remove(direction);
            }
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(213, 216);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            drawRoadSurface(g2d);
            drawCar(g2d);
            g2d.dispose();
        }

        protected void drawCar(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            int x = (getWidth() - car.getWidth()) / 2;
            int y = (getHeight() - car.getHeight()) / 2;
            g2d.drawImage(car, x, y, this);
            g2d.dispose();
        }

        protected void drawRoadSurface(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            // This sets the point of rotation at the center of the window
            int midX = getWidth() / 2;
            int midY = getHeight() / 2;
            g2d.rotate(Math.toRadians(directionOfRotation), midX, midY);
            // We then need to offset the top/left corner so that what 
            // we want draw appears to be in the center of the window,
            // and thus will be rotated around it's center
            int x = midX - (road.getWidth() / 2);
            int y = midY - (road.getHeight() / 2);
            g2d.drawImage(road, x, y, this);
            g2d.dispose();
        }

        protected class DirectionAction extends AbstractAction {

            private Direction direction;
            private boolean active;

            public DirectionAction(Direction direction, boolean active) {
                this.direction = direction;
                this.active = active;
            }

            @Override
            public void actionPerformed(ActionEvent e) {
                setDirectionActive(direction, active);
            }

        }

    }
}",                    if (directionOfRotation > 180) {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.Timer;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new TestPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class TestPane extends JPanel {

        enum Direction {
            LEFT, RIGHT;
        }

        protected enum InputAction {
            PRESSED_LEFT, PRESSED_RIGHT, RELEASED_LEFT, RELEASED_RIGHT
        }

        private BufferedImage car;
        private BufferedImage road;

        private Set<Direction> directions = new TreeSet<>();

        private double directionOfRotation = 0;

        public TestPane() throws IOException {
            car = ImageIO.read(getClass().getResource(""/images/Car.png""));
            road = ImageIO.read(getClass().getResource(""/images/Road.png""));

            InputMap im = getInputMap(WHEN_IN_FOCUSED_WINDOW);
            ActionMap am = getActionMap();

            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, false), InputAction.PRESSED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, true), InputAction.RELEASED_LEFT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, false), InputAction.PRESSED_RIGHT);
            im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, true), InputAction.RELEASED_RIGHT);

            am.put(InputAction.PRESSED_LEFT, new DirectionAction(Direction.LEFT, true));
            am.put(InputAction.RELEASED_LEFT, new DirectionAction(Direction.LEFT, false));
            am.put(InputAction.PRESSED_RIGHT, new DirectionAction(Direction.RIGHT, true));
            am.put(InputAction.RELEASED_RIGHT, new DirectionAction(Direction.RIGHT, false));

            Timer timer = new Timer(5, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if (directions.contains(Direction.RIGHT)) {
                        directionOfRotation += 1;
                    } else if (directions.contains(Direction.LEFT)) {
                        directionOfRotation -= 1;
                    }

                    // No doughnuts for you :P
                    if (directionOfRotation > 180) {
                        directionOfRotation = 180;
                    } else if (directionOfRotation < -180) {
                        directionOfRotation = -180;
                    }

                    repaint();
                }
            });
            timer.start();
        }

        protected void setDirectionActive(Direction direction, boolean active) {
            if (active) {
                directions.add(direction);
            } else {
                directions.remove(direction);
            }
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(213, 216);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            drawRoadSurface(g2d);
            drawCar(g2d);
            g2d.dispose();
        }

        protected void drawCar(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            int x = (getWidth() - car.getWidth()) / 2;
            int y = (getHeight() - car.getHeight()) / 2;
            g2d.drawImage(car, x, y, this);
            g2d.dispose();
        }

        protected void drawRoadSurface(Graphics2D g2d) {
            g2d = (Graphics2D) g2d.create();
            // This sets the point of rotation at the center of the window
            int midX = getWidth() / 2;
            int midY = getHeight() / 2;
            g2d.rotate(Math.toRadians(directionOfRotation), midX, midY);
            // We then need to offset the top/left corner so that what 
            // we want draw appears to be in the center of the window,
            // and thus will be rotated around it's center
            int x = midX - (road.getWidth() / 2);
            int y = midY - (road.getHeight() / 2);
            g2d.drawImage(road, x, y, this);
            g2d.dispose();
        }

        protected class DirectionAction extends AbstractAction {

            private Direction direction;
            private boolean active;

            public DirectionAction(Direction direction, boolean active) {
                this.direction = direction;
                this.active = active;
            }

            @Override
            public void actionPerformed(ActionEvent e) {
                setDirectionActive(direction, active);
            }

        }

    }
}",        protected class DirectionAction extends AbstractAction {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new MainPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class MainPane extends JPanel {

        private BufferedImage ufo;
        private BufferedImage background;

        private int horizontalPosition = 106;

        public MainPane() throws IOException {
            ufo = ImageIO.read(getClass().getResource(""/images/ufo.png""));
            background = ImageIO.read(getClass().getResource(""/images/starfield.png""));
            System.out.println(""background = "" + background);
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(400, 400);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            paintBackground(g2d);
            paintUFO(g2d);
            g2d.dispose();
        }

        protected void paintBackground(Graphics2D g2d) {
            int x = (getWidth() - background.getWidth()) / 2;
            int y = (getHeight() - background.getHeight()) / 2;
            g2d.drawImage(background, x, y, this);
        }

        protected void paintUFO(Graphics2D g2d) {
            int x = (getWidth() - ufo.getWidth()) / 2;
            int y = (getHeight() - ufo.getHeight()) / 2;
            g2d.drawImage(ufo, x, y, this);
        }

    }
}",    public class MainPane extends JPanel {,StackOverflow
NonSerializableClass,The field 'ufo' of serializable class 'Main$MainPane' is of non-serializable type 'java.awt.image.BufferedImage'.,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new MainPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class MainPane extends JPanel {

        private BufferedImage ufo;
        private BufferedImage background;

        private int horizontalPosition = 106;

        public MainPane() throws IOException {
            ufo = ImageIO.read(getClass().getResource(""/images/ufo.png""));
            background = ImageIO.read(getClass().getResource(""/images/starfield.png""));
            System.out.println(""background = "" + background);
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(400, 400);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            paintBackground(g2d);
            paintUFO(g2d);
            g2d.dispose();
        }

        protected void paintBackground(Graphics2D g2d) {
            int x = (getWidth() - background.getWidth()) / 2;
            int y = (getHeight() - background.getHeight()) / 2;
            g2d.drawImage(background, x, y, this);
        }

        protected void paintUFO(Graphics2D g2d) {
            int x = (getWidth() - ufo.getWidth()) / 2;
            int y = (getHeight() - ufo.getHeight()) / 2;
            g2d.drawImage(ufo, x, y, this);
        }

    }
}",        private BufferedImage ufo;,StackOverflow
NonSerializableClass,The field 'background' of serializable class 'Main$MainPane' is of non-serializable type 'java.awt.image.BufferedImage'.,"import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    JFrame frame = new JFrame();
                    frame.add(new MainPane());
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    public class MainPane extends JPanel {

        private BufferedImage ufo;
        private BufferedImage background;

        private int horizontalPosition = 106;

        public MainPane() throws IOException {
            ufo = ImageIO.read(getClass().getResource(""/images/ufo.png""));
            background = ImageIO.read(getClass().getResource(""/images/starfield.png""));
            System.out.println(""background = "" + background);
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(400, 400);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g.create();
            paintBackground(g2d);
            paintUFO(g2d);
            g2d.dispose();
        }

        protected void paintBackground(Graphics2D g2d) {
            int x = (getWidth() - background.getWidth()) / 2;
            int y = (getHeight() - background.getHeight()) / 2;
            g2d.drawImage(background, x, y, this);
        }

        protected void paintUFO(Graphics2D g2d) {
            int x = (getWidth() - ufo.getWidth()) / 2;
            int y = (getHeight() - ufo.getHeight()) / 2;
            g2d.drawImage(ufo, x, y, this);
        }

    }
}",        private BufferedImage background;,StackOverflow
MissingStaticMethodInNonInstantiatableClass,Class cannot be instantiated and does not provide any static methods or fields,"class StringSubscriber implements Flow.Subscriber<ByteBuffer> {

    private final HttpResponse.BodySubscriber<String> wrapped;

    private StringSubscriber(HttpResponse.BodySubscriber<String> wrapped) {
        this.wrapped = wrapped;
    }

    @Override
    public void onSubscribe(Flow.Subscription subscription) {
        wrapped.onSubscribe(subscription);
    }

    @Override
    public void onNext(ByteBuffer item) {
        wrapped.onNext(List.of(item));
    }

    @Override
    public void onError(Throwable throwable) {
        wrapped.onError(throwable);
    }

    @Override
    public void onComplete() {
        wrapped.onComplete();
    }
}",class StringSubscriber implements Flow.Subscriber<ByteBuffer> {,StackOverflow
TestClassWithoutTestCases,"The class 'DataImporterControllerUnitTest' might be a test class, but it contains no test cases.","@WebMvcTest(controllers = DataImporterController.class)
public class DataImporterControllerUnitTest {
    @MockBean
    DataImporterService dataImporterService;

    @Autowired
    private MockMvc mockMvc;

    @BeforeEach
    public void setUp() {
        when(dataImporterService.doImport(body)).thenReturn(something);
    }

    @Test
    void doImportExpect200() throws Exception {
        mockMvc.perform(put(URI).with(jwt().authorities(new SimpleGrantedAuthority(
                ""SCOPE_data:write""))).contentType(APPLICATION_JSON_VALUE).accept(APPLICATION_JSON)
                        .content(BODY)).andExpect(status().isOk());
    }
}",public class DataImporterControllerUnitTest {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.beans.PropertyChangeListener;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Caret;
import javax.swing.text.DefaultCaret;
import javax.swing.text.JTextComponent;
import javax.swing.text.Position;
import javax.swing.text.Utilities;

/**
 * <p>Implements Standard rules for extending the selection, consistent with the standard
 * behavior for extending the selection in all word processors, browsers, and other text
 * editing tools, on all platforms. Without this, Swing's behavior on extending the
 * selection is inconsistent with all other text editing tools.
 * </p><p>
 * Swing components don't handle selectByWord the way most UI text components do. If you
 * double-click on a word, they will all select the entire word. But if you do a 
 * click-and-drag, most components will (a) select the entire clicked word, and
 * (b) extend the selection a word at a time as the user drags across the text. And if
 * you double- click on a word and follow that with a shift-click, most components will
 * also extend the selection a word at a time.  Swing components handle a double-clicked
 * word the standard way, but do not handle click-and-drag or shift-click correctly. This
 * caret, which replaces the standard DefaultCaret, fixes this.</p>
 * <p>Created by IntelliJ IDEA.</p>
 * <p>Date: 2/23/20</p>
 * <p>Time: 10:58 PM</p>
 *
 * @author Miguel Mu\u00f1oz
 */
public class StandardCaret extends DefaultCaret {
  // In the event of a double-click, these are the positions of the low end and high end
  // of the word that was clicked.
  private int highMark;
  private int lowMark;
  private boolean selectingByWord = false; // true when the last selection was done by word.
  private boolean selectingByRow = false; // true when the last selection was done by paragraph. 

  /**
   * Instantiate an EnhancedCaret.
   */
  public StandardCaret() {
    super();
  }

  /**
   * <p>Install this Caret into a JTextComponent. Carets may not be shared among multiple
   * components.</p>
   * @param component The component to use the EnhancedCaret.
   */
  public void installInto(JTextComponent component) {
    replaceCaret(component, this);
  }

  /**
   * Install a new StandardCaret into a JTextComponent, such as a JTextField or
   * JTextArea, and starts the Caret blinking using the same blink-rate as the
   * previous Caret.
   *
   * @param component The JTextComponent subclass
   */
  public static void installStandardCaret(JTextComponent component) {
    replaceCaret(component, new StandardCaret());
  }

  /**
   * Installs the specified Caret into the JTextComponent, and starts the Caret blinking
   * using the same blink-rate as the previous Caret. This works with any Caret
   *
   * @param component The text component to get the new Caret
   * @param caret     The new Caret to install
   */
  public static void replaceCaret(final JTextComponent component, final Caret caret) {
    final Caret priorCaret = component.getCaret();
    int blinkRate = priorCaret.getBlinkRate();
    if (priorCaret instanceof PropertyChangeListener) {
      // For example, com.apple.laf.AquaCaret, the troublemaker, installs this listener
      // which doesn't get removed when the Caret gets uninstalled.
      component.removePropertyChangeListener((PropertyChangeListener) priorCaret);
    }
    component.setCaret(caret);
    caret.setBlinkRate(blinkRate); // Starts the new caret blinking.
  }

  @Override
  public void mousePressed(final MouseEvent e) {
    // if user is doing a shift-click. Construct a new MouseEvent that happened at one
    // end of the word, and send that to super.mousePressed().
    boolean isExtended = isExtendSelection(e);
    if (selectingByWord && isExtended) {
      MouseEvent alternateEvent = getRevisedMouseEvent(e, Utilities::getWordStart, Utilities::getWordEnd);
      super.mousePressed(alternateEvent);
    } else if (selectingByRow && isExtended) {
      MouseEvent alternateEvent = getRevisedMouseEvent(e, Utilities::getRowStart, Utilities::getRowEnd);
      super.mousePressed(alternateEvent);
    } else  {
      if (!isExtended) {
        int clickCount = e.getClickCount();
        selectingByWord = clickCount == 2;
        selectingByRow = clickCount == 3;
      }
      super.mousePressed(e); // let the system select the clicked word
      // save the low end of the selected word.
      lowMark = getMark();
      if (selectingByWord || selectingByRow) {
        // User did a double- or triple-click...
        // They've selected the whole word. Record the high end.
        highMark = getDot();
      } else {
        // Not a double-click.
        highMark = lowMark;
      }
    }
  }

  @Override
  public void mouseClicked(final MouseEvent e) {
    super.mouseClicked(e);
    if (selectingByRow) {
      int mark = getMark();
      int dot = getDot();
      lowMark = Math.min(mark, dot);
      highMark = Math.max(mark, dot);
    }
  }

  private MouseEvent getRevisedMouseEvent(final MouseEvent e, final BiTextFunction getStart, final BiTextFunction getEnd) {
    int newPos;
    int pos = getPos(e);
    final JTextComponent textComponent = getComponent();
    try {
      if (pos > highMark) {
        newPos = getEnd.loc(textComponent, pos);
        setDot(lowMark);
      } else if (pos < lowMark) {
        newPos = getStart.loc(textComponent, pos);
        setDot(highMark);
      } else {
        if (getMark() == lowMark) {
          newPos = getEnd.loc(textComponent, pos);
        } else {
          newPos = getStart.loc(textComponent, pos);
        }
        pos = -1; // ensure we make a new event
      }
    } catch (BadLocationException ex) {
      throw new IllegalStateException(ex);
    }
    MouseEvent alternateEvent;
    if (newPos == pos) {
      alternateEvent = e;
    } else {
      alternateEvent = makeNewEvent(e, newPos);
    }
    return alternateEvent;
  }

  private boolean isExtendSelection(MouseEvent e) {
    // We extend the selection when the shift is down but control is not. Other modifiers don't matter.
    int modifiers = e.getModifiersEx();
    int shiftAndControlDownMask = MouseEvent.SHIFT_DOWN_MASK | MouseEvent.CTRL_DOWN_MASK;
    return (modifiers & shiftAndControlDownMask) == MouseEvent.SHIFT_DOWN_MASK;
  }

  @Override
  public void setDot(final int dot, final Position.Bias dotBias) {
    super.setDot(dot, dotBias);
  }

  @Override
  public void mouseDragged(final MouseEvent e) {
    if (!selectingByWord && !selectingByRow) {
      super.mouseDragged(e);
    } else {
      BiTextFunction getStart;
      BiTextFunction getEnd;
      if (selectingByWord) {
        getStart = Utilities::getWordStart;
        getEnd = Utilities::getWordEnd;
      } else {
        // selecting by paragraph
        getStart = Utilities::getRowStart;
        getEnd = Utilities::getRowEnd;
      }
      // super.mouseDragged just calls moveDot() after getting the position. We can do
      // the same thing...
      // There's no ""setMark()"" method. You can set the mark by calling setDot(). It sets
      // both the mark and the dot to the same place. Then you can call moveDot() to put
      // the dot somewhere else.
      if ((!e.isConsumed()) && SwingUtilities.isLeftMouseButton(e)) {
        int pos = getPos(e);
        JTextComponent component = getComponent();
        try {
          if (pos > highMark) {
            int wordEnd = getEnd.loc(component, pos);
            setDot(lowMark);
            moveDot(wordEnd);
          } else if (pos < lowMark) {
            int wordStart = getStart.loc(component, pos);
            setDot(wordStart); // Sets the mark, too
            moveDot(highMark);
          } else {
            setDot(lowMark);
            moveDot(highMark);
          }
        } catch (BadLocationException ex) {
          ex.printStackTrace();
        }
      }
    }
  }

  private int getPos(final MouseEvent e) {
    JTextComponent component = getComponent();
    Point pt = new Point(e.getX(), e.getY());
    Position.Bias[] biasRet = new Position.Bias[1];
    return component.getUI().viewToModel(component, pt, biasRet);
  }
  
  private MouseEvent makeNewEvent(MouseEvent e, int pos) {
    JTextComponent component = getComponent();
    try {
      Rectangle rect = component.getUI().modelToView(component, pos);
      return new MouseEvent(
          component,
          e.getID(),
          e.getWhen(),
          e.getModifiers(),
          rect.x,
          rect.y,
          e.getClickCount(),
          e.isPopupTrigger(),
          e.getButton()
      );
    } catch (BadLocationException ev) {
      ev.printStackTrace();
      throw new IllegalStateException(ev);
    }
  }

// For eventual use by a ""select paragraph"" feature:
//  private static final char NEW_LINE = '\n';
//  private static int getParagraphStart(JTextComponent component, int position) {
//    return component.getText().substring(0, position).lastIndexOf(NEW_LINE);
//  }
//  
//  private static int getParagraphEnd(JTextComponent component, int position) {
//    return component.getText().indexOf(NEW_LINE, position);
//  }

  /**
   * Don't use this. I should throw CloneNotSupportedException, but it won't compile if I
   * do. Changing the access to protected doesn't help. If you don't believe me, try it
   * yourself.
   * @return A bad clone of this.
   */      
  @SuppressWarnings({""CloneReturnsClassType"", ""UseOfClone""})
  @Override
  public Object clone() {
    return super.clone();
  }
  
  @FunctionalInterface
  private interface BiTextFunction {
    int loc(JTextComponent component, int position) throws BadLocationException;
  }
}",public class StandardCaret extends DefaultCaret {,StackOverflow
CloneMethodReturnTypeMustMatchClassName,The return type of the clone() method must be the class name when implements Cloneable,"import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.beans.PropertyChangeListener;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Caret;
import javax.swing.text.DefaultCaret;
import javax.swing.text.JTextComponent;
import javax.swing.text.Position;
import javax.swing.text.Utilities;

/**
 * <p>Implements Standard rules for extending the selection, consistent with the standard
 * behavior for extending the selection in all word processors, browsers, and other text
 * editing tools, on all platforms. Without this, Swing's behavior on extending the
 * selection is inconsistent with all other text editing tools.
 * </p><p>
 * Swing components don't handle selectByWord the way most UI text components do. If you
 * double-click on a word, they will all select the entire word. But if you do a 
 * click-and-drag, most components will (a) select the entire clicked word, and
 * (b) extend the selection a word at a time as the user drags across the text. And if
 * you double- click on a word and follow that with a shift-click, most components will
 * also extend the selection a word at a time.  Swing components handle a double-clicked
 * word the standard way, but do not handle click-and-drag or shift-click correctly. This
 * caret, which replaces the standard DefaultCaret, fixes this.</p>
 * <p>Created by IntelliJ IDEA.</p>
 * <p>Date: 2/23/20</p>
 * <p>Time: 10:58 PM</p>
 *
 * @author Miguel Mu\u00f1oz
 */
public class StandardCaret extends DefaultCaret {
  // In the event of a double-click, these are the positions of the low end and high end
  // of the word that was clicked.
  private int highMark;
  private int lowMark;
  private boolean selectingByWord = false; // true when the last selection was done by word.
  private boolean selectingByRow = false; // true when the last selection was done by paragraph. 

  /**
   * Instantiate an EnhancedCaret.
   */
  public StandardCaret() {
    super();
  }

  /**
   * <p>Install this Caret into a JTextComponent. Carets may not be shared among multiple
   * components.</p>
   * @param component The component to use the EnhancedCaret.
   */
  public void installInto(JTextComponent component) {
    replaceCaret(component, this);
  }

  /**
   * Install a new StandardCaret into a JTextComponent, such as a JTextField or
   * JTextArea, and starts the Caret blinking using the same blink-rate as the
   * previous Caret.
   *
   * @param component The JTextComponent subclass
   */
  public static void installStandardCaret(JTextComponent component) {
    replaceCaret(component, new StandardCaret());
  }

  /**
   * Installs the specified Caret into the JTextComponent, and starts the Caret blinking
   * using the same blink-rate as the previous Caret. This works with any Caret
   *
   * @param component The text component to get the new Caret
   * @param caret     The new Caret to install
   */
  public static void replaceCaret(final JTextComponent component, final Caret caret) {
    final Caret priorCaret = component.getCaret();
    int blinkRate = priorCaret.getBlinkRate();
    if (priorCaret instanceof PropertyChangeListener) {
      // For example, com.apple.laf.AquaCaret, the troublemaker, installs this listener
      // which doesn't get removed when the Caret gets uninstalled.
      component.removePropertyChangeListener((PropertyChangeListener) priorCaret);
    }
    component.setCaret(caret);
    caret.setBlinkRate(blinkRate); // Starts the new caret blinking.
  }

  @Override
  public void mousePressed(final MouseEvent e) {
    // if user is doing a shift-click. Construct a new MouseEvent that happened at one
    // end of the word, and send that to super.mousePressed().
    boolean isExtended = isExtendSelection(e);
    if (selectingByWord && isExtended) {
      MouseEvent alternateEvent = getRevisedMouseEvent(e, Utilities::getWordStart, Utilities::getWordEnd);
      super.mousePressed(alternateEvent);
    } else if (selectingByRow && isExtended) {
      MouseEvent alternateEvent = getRevisedMouseEvent(e, Utilities::getRowStart, Utilities::getRowEnd);
      super.mousePressed(alternateEvent);
    } else  {
      if (!isExtended) {
        int clickCount = e.getClickCount();
        selectingByWord = clickCount == 2;
        selectingByRow = clickCount == 3;
      }
      super.mousePressed(e); // let the system select the clicked word
      // save the low end of the selected word.
      lowMark = getMark();
      if (selectingByWord || selectingByRow) {
        // User did a double- or triple-click...
        // They've selected the whole word. Record the high end.
        highMark = getDot();
      } else {
        // Not a double-click.
        highMark = lowMark;
      }
    }
  }

  @Override
  public void mouseClicked(final MouseEvent e) {
    super.mouseClicked(e);
    if (selectingByRow) {
      int mark = getMark();
      int dot = getDot();
      lowMark = Math.min(mark, dot);
      highMark = Math.max(mark, dot);
    }
  }

  private MouseEvent getRevisedMouseEvent(final MouseEvent e, final BiTextFunction getStart, final BiTextFunction getEnd) {
    int newPos;
    int pos = getPos(e);
    final JTextComponent textComponent = getComponent();
    try {
      if (pos > highMark) {
        newPos = getEnd.loc(textComponent, pos);
        setDot(lowMark);
      } else if (pos < lowMark) {
        newPos = getStart.loc(textComponent, pos);
        setDot(highMark);
      } else {
        if (getMark() == lowMark) {
          newPos = getEnd.loc(textComponent, pos);
        } else {
          newPos = getStart.loc(textComponent, pos);
        }
        pos = -1; // ensure we make a new event
      }
    } catch (BadLocationException ex) {
      throw new IllegalStateException(ex);
    }
    MouseEvent alternateEvent;
    if (newPos == pos) {
      alternateEvent = e;
    } else {
      alternateEvent = makeNewEvent(e, newPos);
    }
    return alternateEvent;
  }

  private boolean isExtendSelection(MouseEvent e) {
    // We extend the selection when the shift is down but control is not. Other modifiers don't matter.
    int modifiers = e.getModifiersEx();
    int shiftAndControlDownMask = MouseEvent.SHIFT_DOWN_MASK | MouseEvent.CTRL_DOWN_MASK;
    return (modifiers & shiftAndControlDownMask) == MouseEvent.SHIFT_DOWN_MASK;
  }

  @Override
  public void setDot(final int dot, final Position.Bias dotBias) {
    super.setDot(dot, dotBias);
  }

  @Override
  public void mouseDragged(final MouseEvent e) {
    if (!selectingByWord && !selectingByRow) {
      super.mouseDragged(e);
    } else {
      BiTextFunction getStart;
      BiTextFunction getEnd;
      if (selectingByWord) {
        getStart = Utilities::getWordStart;
        getEnd = Utilities::getWordEnd;
      } else {
        // selecting by paragraph
        getStart = Utilities::getRowStart;
        getEnd = Utilities::getRowEnd;
      }
      // super.mouseDragged just calls moveDot() after getting the position. We can do
      // the same thing...
      // There's no ""setMark()"" method. You can set the mark by calling setDot(). It sets
      // both the mark and the dot to the same place. Then you can call moveDot() to put
      // the dot somewhere else.
      if ((!e.isConsumed()) && SwingUtilities.isLeftMouseButton(e)) {
        int pos = getPos(e);
        JTextComponent component = getComponent();
        try {
          if (pos > highMark) {
            int wordEnd = getEnd.loc(component, pos);
            setDot(lowMark);
            moveDot(wordEnd);
          } else if (pos < lowMark) {
            int wordStart = getStart.loc(component, pos);
            setDot(wordStart); // Sets the mark, too
            moveDot(highMark);
          } else {
            setDot(lowMark);
            moveDot(highMark);
          }
        } catch (BadLocationException ex) {
          ex.printStackTrace();
        }
      }
    }
  }

  private int getPos(final MouseEvent e) {
    JTextComponent component = getComponent();
    Point pt = new Point(e.getX(), e.getY());
    Position.Bias[] biasRet = new Position.Bias[1];
    return component.getUI().viewToModel(component, pt, biasRet);
  }
  
  private MouseEvent makeNewEvent(MouseEvent e, int pos) {
    JTextComponent component = getComponent();
    try {
      Rectangle rect = component.getUI().modelToView(component, pos);
      return new MouseEvent(
          component,
          e.getID(),
          e.getWhen(),
          e.getModifiers(),
          rect.x,
          rect.y,
          e.getClickCount(),
          e.isPopupTrigger(),
          e.getButton()
      );
    } catch (BadLocationException ev) {
      ev.printStackTrace();
      throw new IllegalStateException(ev);
    }
  }

// For eventual use by a ""select paragraph"" feature:
//  private static final char NEW_LINE = '\n';
//  private static int getParagraphStart(JTextComponent component, int position) {
//    return component.getText().substring(0, position).lastIndexOf(NEW_LINE);
//  }
//  
//  private static int getParagraphEnd(JTextComponent component, int position) {
//    return component.getText().indexOf(NEW_LINE, position);
//  }

  /**
   * Don't use this. I should throw CloneNotSupportedException, but it won't compile if I
   * do. Changing the access to protected doesn't help. If you don't believe me, try it
   * yourself.
   * @return A bad clone of this.
   */      
  @SuppressWarnings({""CloneReturnsClassType"", ""UseOfClone""})
  @Override
  public Object clone() {
    return super.clone();
  }
  
  @FunctionalInterface
  private interface BiTextFunction {
    int loc(JTextComponent component, int position) throws BadLocationException;
  }
}",  public Object clone() {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",    public class TestPane extends JPanel {,StackOverflow
TestClassWithoutTestCases,"The class 'TestPane' might be a test class, but it contains no test cases.","import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",    public class TestPane extends JPanel {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Container.setLayout(LayoutManager) ,"import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",            setLayout(new BorderLayout());,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Container.add(Component) ,"import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",            add(scrollPane);,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",    public class FixedColumnWidthList<T> extends JList<T> {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Main#FixedColumnWidthList<T>.configureDefaults() ,"import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",            configureDefaults();,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Main#FixedColumnWidthList<T>.configureDefaults() ,"import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",            configureDefaults();,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Main#FixedColumnWidthList<T>.configureDefaults() ,"import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",            configureDefaults();,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Main#FixedColumnWidthList<T>.configureDefaults() ,"import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListModel;

public class Main {
    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {
        public TestPane() {
            setLayout(new BorderLayout());
            String[] items = {""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5"", ""Item 6"", ""Item 7"", ""Item 8"", ""Item 9"", ""Item 10""};
            FixedColumnWidthList<String> list = new FixedColumnWidthList<>(items);
            list.setVisibleColumnCount(3);

            JScrollPane scrollPane = new JScrollPane(list);
            add(scrollPane);
        }
    }

    public class FixedColumnWidthList<T> extends JList<T> {

        private int visibleColumnCount = -1;

        public FixedColumnWidthList() {
            configureDefaults();
        }

        public FixedColumnWidthList(ListModel<T> dataModel) {
            super(dataModel);
            configureDefaults();
        }

        public FixedColumnWidthList(T[] listData) {
            super(listData);
            configureDefaults();
        }

        public FixedColumnWidthList(Vector<T> listData) {
            super(listData);
            configureDefaults();
        }

        protected void configureDefaults() {
            setLayoutOrientation(JList.HORIZONTAL_WRAP);
            setVisibleRowCount(1);
        }

        public int getVisibleColumnCount() {
            return visibleColumnCount;
        }

        public void setVisibleColumnCount(int visibleColumnCount) {
            if (this.visibleColumnCount == visibleColumnCount) {
                return;
            }
            this.visibleColumnCount = visibleColumnCount;
            revalidate();
            repaint();
        }

        @Override
        public Dimension getPreferredScrollableViewportSize() {
            int visibleColumnCount = getVisibleColumnCount();
            Dimension original = super.getPreferredScrollableViewportSize();
            if (visibleColumnCount <= 0) {
                return original;
            }
            ListModel<T> model = getModel();
            int desirableWidth = getFixedCellWidth();
            if (desirableWidth <= 0) {
                T testValue = getPrototypeCellValue();
                if (testValue != null) {
                    desirableWidth = getCellRenderer().getListCellRendererComponent(this, testValue, 0, false, false).getPreferredSize().width;
                    desirableWidth *= visibleColumnCount;
                } else if (getModel().getSize() == 0) {
                    desirableWidth = 256; // Just pick a number :/
                } else {
                    desirableWidth = 0;
                    // You could, instead, just take the first value and mutiply
                    // it's rendered width by the number of visible columns,
                    // but this could mean you're not actually getting the
                    // first three columns ... but this whole thing is a bag
                    // of ambiguity
                    for (int column = 0; column < visibleColumnCount && column < model.getSize(); column++) {
                        int width = getCellRenderer().getListCellRendererComponent(this, model.getElementAt(column), column, false, false).getPreferredSize().width;
                        System.out.println(column + "" = "" + width);
                        desirableWidth += width;
                    }
                    // I can't find the ""horizontal insets"", so I'm guessing...
                    desirableWidth += (8 * (visibleColumnCount - 1));
                    // If we have less data then visible columns, just
                    // average the available information and multiply it by
                    // the remaining number of columns as a guess
                    if (visibleColumnCount > model.getSize()) {
                        int averageWidth = desirableWidth / model.getSize();
                        desirableWidth += (visibleColumnCount - model.getSize());
                    }
                }
            } else {
                desirableWidth *= visibleColumnCount;
            }

            return new Dimension(desirableWidth, original.height);
        }
    }
}",            configureDefaults();,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","public interface MyInterface {

    public static class MyClass implements MyInterface {
        @Override 
        public void doSomething() {
            System.out.println( ""i'm an implementing class!"" );
        }
    }

    public static MyInterface createMagicInstance() {
        return new MyClass();
    }

    public void doSomething();

}

public class Test {
    public static void main( String[] args ) {
        MyInterface mi = MyInterface.createMagicInstance();
        mi.doSomething();
    }
}",public class Test {,StackOverflow
TestClassWithoutTestCases,"The class 'TestPanel' might be a test class, but it contains no test cases.","import javafx.application.Application;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.IntStream;

public class ScrollPaneContentDemo extends Application {
    @Override
    public void start(Stage stage) throws Exception {
        List<Item> items = new ArrayList<>();
        IntStream.range(1, 1000).forEach(i -> items.add(new Item()));
        TestPanel root = new TestPanel(items);
        Scene scene = new Scene(root, 500, 500);
        stage.setScene(scene);
        stage.setTitle(""ScrollPaneContent Demo"");
        stage.show();
    }

    class TestPanel extends ScrollPane {
        private final int SPACING = 5;
        private final int ROW_MAX = 6;
        private DoubleProperty size = new SimpleDoubleProperty();

        public TestPanel(List<Item> items) {
            final VBox root = new VBox();
            root.setSpacing(SPACING);
            HBox row = null;
            int count = 0;
            for (Item item : items) {
                if (count == ROW_MAX || row == null) {
                    row = new HBox();
                    row.setSpacing(SPACING);
                    root.getChildren().add(row);
                    count = 0;
                }

                CustomBox box = new CustomBox(item);
                box.minWidthProperty().bind(size);
                row.getChildren().add(box);
                HBox.setHgrow(box, Priority.ALWAYS);
                count++;
            }
            setFitToWidth(true);
            setContent(root);

            double padding = 4;
            viewportBoundsProperty().addListener((obs, old, bounds) -> {
                size.setValue((bounds.getWidth() - padding - ((ROW_MAX - 1) * SPACING)) / ROW_MAX);
            });
        }
    }

    class CustomBox extends StackPane {
        private Item item;
        private Rectangle square;
        private int size = 20;

        public CustomBox(Item item) {
            setStyle(""-fx-background-color:#99999950;"");
            this.item = item;
            setPadding(new Insets(5, 5, 5, 5));
            square = new Rectangle(size, size, Color.RED);
            square.widthProperty().bind(widthProperty());
            square.heightProperty().bind(heightProperty());

            maxHeightProperty().bind(minWidthProperty());
            maxWidthProperty().bind(minWidthProperty());
            minHeightProperty().bind(minWidthProperty());
            getChildren().add(square);
        }
    }

    class Item {
    }
}",    class TestPanel extends ScrollPane {,StackOverflow
AvoidDuplicateLiterals,"The String literal ""_Temp"" appears 5 times in this file; the first occurrence is on line 53","import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}","        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");",StackOverflow
UseLocaleWithCaseConversions,"When doing a String.toLowerCase()/toUpperCase() call, use a Locale","import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}",                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files,StackOverflow
CloseResource,Ensure that resources like this FileWriter object are closed after use,"import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}","         FileWriter fstream = new FileWriter(extractionLogFile, true);",StackOverflow
CloseResource,Ensure that resources like this BufferedWriter object are closed after use,"import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}",         BufferedWriter out = new BufferedWriter(fstream);,StackOverflow
CloseResource,Ensure that resources like this PrintWriter object are closed after use,"import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}","         PrintWriter pWriter = new PrintWriter(out, true);",StackOverflow
CloseResource,Ensure that resources like this FileInputStream object are closed after use,"import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}",        FileInputStream fis = new FileInputStream(zipFilePath);,StackOverflow
UseLocaleWithCaseConversions,"When doing a String.toLowerCase()/toUpperCase() call, use a Locale","import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}","            if (fileName.toUpperCase().endsWith(""PDF""))",StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}",                FileOutputStream fos = new FileOutputStream(newFile);,StackOverflow
AssignmentInOperand,Avoid assignments in operands,"import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}",                while ((len = zis.read(buffer)) > 0),StackOverflow
UseLocaleWithCaseConversions,"When doing a String.toLowerCase()/toUpperCase() call, use a Locale","import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}",            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION)),StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}",                FileOutputStream fos = new FileOutputStream(newFile);,StackOverflow
AssignmentInOperand,Avoid assignments in operands,"import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Unzipper
{   
    private static  String baseDir = """";
    private static  String PDF_DESTINATION_DIRECTORY = """";
    private static  String extractionLogFile = """";

private static final int BUFFER_SIZE = 4096;
private static int count = 0;
private static int loggedCount = 0;
private static String ZIP_EXTENSION = ""ZIP"";

public static void main(String[] args)
{

    baseDir = File.separator + ""Users"" + File.separator + ""user"" + File.separator + ""Desktop"" + File.separator + ""ZipFolder"" + File.separator;
    PDF_DESTINATION_DIRECTORY = File.separator +""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""PDFs"" + File.separator;
    extractionLogFile = File.separator + ""Users"" + File.separator + ""user"" + File.separator +""Desktop"" + File.separator + ""ZipFolder"" + File.separator + ""ExtractionLogFile.txt"";       
    

    try
    {
        //Paths
        File lookupDir = new File(baseDir);
        String doneFolder = PDF_DESTINATION_DIRECTORY;

        //Logger properties
        Logger logger = Logger.getLogger(""ExtractionLog"");
        FileHandler fh;
        fh = new FileHandler(extractionLogFile);
        logger.addHandler(fh);
        logger.setUseParentHandlers(false);
        SimpleFormatter formatter = new SimpleFormatter();
        fh.setFormatter(formatter);

        //make some folders if they are not there
        makeDirIfNotExist(baseDir + ""PDFs"");
        makeDirIfNotExist(baseDir + File.separator + ""_Temp"");

        File[] directoryListing = lookupDir.listFiles();

        for (int i = 0; i < directoryListing.length; i++)
        {
            if (directoryListing[i].isFile()) //there's definately a file
            {
                //Save the current file's path
                String pathOrigFile = directoryListing[i].getAbsolutePath();
                Path origFileDone = Paths.get(pathOrigFile);
                Path newFileDone = Paths.get(doneFolder + directoryListing[i].getName());

                //make sure directory exist
                String dirPDFdestName = directoryListing[i].getName();
                makeDirIfNotExist(PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));

                //unzip it
                if (directoryListing[i].getName().toUpperCase().endsWith(ZIP_EXTENSION)) //ZIP files
                {
                    checkTheZip(directoryListing[i].getAbsolutePath(), PDF_DESTINATION_DIRECTORY.concat(dirPDFdestName.substring(0, dirPDFdestName.length() - 4)));
                    //move to the 'PDFs' folder
                    moveFile(origFileDone, newFileDone);
                }
            }
        }

        logger.info(""Cycle completed, Processed files: "" + loggedCount); // (just checking)
        loggedCount = 0;
    } catch (Exception e)
    {
        appendToFile(e);
    }
}

//dig into the zip file
private static void checkTheZip(String zipFilePath, String destDirName)
{
    unzip(zipFilePath, destDirName);
    loggedCount++;
}

//move the file
private static void moveFile(Path fromDest, Path toDest)
{
    File lookupDir = new File(toDest.toString());
    try
    {
        if(!lookupDir.exists())
        {
            Files.move(fromDest, toDest); //, OPTIONAL: StandardCopyOption.REPLACE_EXISTING
        }
    } catch (Exception e)
    {        
        appendToFile(e);
    }
}

private static File makeDirIfNotExist(String directory)
{
    File dir = new File(directory);
    if (!dir.exists())
    {
        dir.mkdir();
    }
    return new File(directory + File.separator);
}


   public static void appendToFile(Exception e) 
   {
      try 
      {
         FileWriter fstream = new FileWriter(extractionLogFile, true);
         BufferedWriter out = new BufferedWriter(fstream);
         PrintWriter pWriter = new PrintWriter(out, true);
         e.printStackTrace(pWriter);
      }
      catch (Exception ie) 
      {
         throw new RuntimeException(""Could not write Exception to file"", ie);
      }
   }

private static void unzip(String zipFilePath, String destDirName)
{
    //buffer for read and write data to file
    byte[] buffer = new byte[BUFFER_SIZE];

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFilePath)))
    {
        FileInputStream fis = new FileInputStream(zipFilePath);
        ZipEntry ze = zis.getNextEntry();

        while (ze != null)
        {
            String fileName = ze.getName();
            int index = fileName.lastIndexOf(File.separator);
            String newFileName = fileName.substring(index + 1);
            File newFile = new File(destDirName + File.separator + newFileName);

            //PDFs
            if (fileName.toUpperCase().endsWith(""PDF""))
            {
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

            }

            //Zips inside zips  
            if (fileName.toUpperCase().endsWith(ZIP_EXTENSION))
            {
                Path newFileDone = Paths.get(baseDir + ""_Temp"");
                Path origFileDone = Paths.get(destDirName + File.separator);
                newFile = new File(baseDir + ""_Temp"" + File.separator + newFileName);
                
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0)
                {
                    fos.write(buffer, 0, len);
                }
                fos.close();

                //move the zip out of the folder to a temp folder then
                moveFile(origFileDone, newFileDone);
                
                //search the temp folder for entries and handle the .zip file from there
                checkTheZip(baseDir + ""_Temp"" + File.separator + fileName, destDirName);
                
                //remove the Temp_ folders contents
                Files.walk(Paths.get(baseDir + ""_Temp"" + File.separator))
                        .filter(Files::isRegularFile)
                        .map(Path::toFile)
                        .forEach(File::delete);

            }

            //close this ZipEntry
            zis.closeEntry();
            ze = zis.getNextEntry();
        }

        //close last ZipEntry
        zis.close();
        fis.close();
    } catch (IOException e)
    {
        appendToFile(e);
    }

   }
}",                while ((len = zis.read(buffer)) > 0),StackOverflow
TestClassWithoutTestCases,"The class 'AnimationTest' might be a test class, but it contains no test cases.","public class AnimationTest extends Application {

    private final Label messageLabel = new Label();

    @Override
    public void start(Stage stage) {

        VBox vBox = new VBox();
        vBox.setAlignment(Pos.CENTER);
        Scene scene = new Scene(vBox, 320, 240);
        vBox.getChildren().add(messageLabel);
        Button button = new Button();
        button.setOnAction(event -> {
            Animation animation = sendMessage(""Some animated text."");
            button.disableProperty().bind(Bindings.equal(animation.statusProperty(), Animation.Status.RUNNING));
        });
        vBox.getChildren().add(button);
        stage.setScene(scene);
        stage.show();
    }

    private Animation sendMessage(String message) {
        final IntegerProperty i = new SimpleIntegerProperty(0);
        Timeline timeline = new Timeline();
        KeyFrame keyFrame = new KeyFrame(
                Duration.millis(40),
                event -> {
                    if (i.get() > message.length()) {
                        timeline.stop();
                    } else {
                        messageLabel.setText(message.substring(0, i.get()));
                        i.set(i.get() + 1);
                    }
                });
        timeline.getKeyFrames().add(keyFrame);
        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
        return timeline ;
    }

    public static void main(String[] args) {
        launch();
    }
}

public class AnimationTest extends Application {

    private final Label messageLabel = new Label();
    
    private final Queue<String> messages = new LinkedList<>();
    private Animation currentAnimation = null ;

    @Override
    public void start(Stage stage) {

        VBox vBox = new VBox();
        vBox.setAlignment(Pos.CENTER);
        Scene scene = new Scene(vBox, 320, 240);
        vBox.getChildren().add(messageLabel);
        Button button = new Button();
        button.setOnAction(event -> messages.add(""Some animated text.""));

        AnimationTimer timer = new AnimationTimer() {
            @Override
            public void handle(long l) {
                if (currentAnimation == null || currentAnimation.getStatus() == Animation.Status.STOPPED) {
                    String message = messages.poll();
                    if (message != null) {
                        currentAnimation = sendMessage(message);
                        currentAnimation.play();
                    }
                }
            }
        };
        timer.start();
        vBox.getChildren().add(button);
        stage.setScene(scene);
        stage.show();
    }

    private Animation sendMessage(String message) {
        final IntegerProperty i = new SimpleIntegerProperty(0);
        Timeline timeline = new Timeline();
        KeyFrame keyFrame = new KeyFrame(
                Duration.millis(40),
                event -> {
                    if (i.get() > message.length()) {
                        timeline.stop();
                    } else {
                        messageLabel.setText(message.substring(0, i.get()));
                        i.set(i.get() + 1);
                    }
                });
        timeline.getKeyFrames().add(keyFrame);
        timeline.setCycleCount(Animation.INDEFINITE);
        return timeline ;
    }

    public static void main(String[] args) {
        launch();
    }
}",public class AnimationTest extends Application {,StackOverflow
TestClassWithoutTestCases,"The class 'AnimationTest' might be a test class, but it contains no test cases.","public class AnimationTest extends Application {

    private final Label messageLabel = new Label();

    @Override
    public void start(Stage stage) {

        VBox vBox = new VBox();
        vBox.setAlignment(Pos.CENTER);
        Scene scene = new Scene(vBox, 320, 240);
        vBox.getChildren().add(messageLabel);
        Button button = new Button();
        button.setOnAction(event -> {
            Animation animation = sendMessage(""Some animated text."");
            button.disableProperty().bind(Bindings.equal(animation.statusProperty(), Animation.Status.RUNNING));
        });
        vBox.getChildren().add(button);
        stage.setScene(scene);
        stage.show();
    }

    private Animation sendMessage(String message) {
        final IntegerProperty i = new SimpleIntegerProperty(0);
        Timeline timeline = new Timeline();
        KeyFrame keyFrame = new KeyFrame(
                Duration.millis(40),
                event -> {
                    if (i.get() > message.length()) {
                        timeline.stop();
                    } else {
                        messageLabel.setText(message.substring(0, i.get()));
                        i.set(i.get() + 1);
                    }
                });
        timeline.getKeyFrames().add(keyFrame);
        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
        return timeline ;
    }

    public static void main(String[] args) {
        launch();
    }
}

public class AnimationTest extends Application {

    private final Label messageLabel = new Label();
    
    private final Queue<String> messages = new LinkedList<>();
    private Animation currentAnimation = null ;

    @Override
    public void start(Stage stage) {

        VBox vBox = new VBox();
        vBox.setAlignment(Pos.CENTER);
        Scene scene = new Scene(vBox, 320, 240);
        vBox.getChildren().add(messageLabel);
        Button button = new Button();
        button.setOnAction(event -> messages.add(""Some animated text.""));

        AnimationTimer timer = new AnimationTimer() {
            @Override
            public void handle(long l) {
                if (currentAnimation == null || currentAnimation.getStatus() == Animation.Status.STOPPED) {
                    String message = messages.poll();
                    if (message != null) {
                        currentAnimation = sendMessage(message);
                        currentAnimation.play();
                    }
                }
            }
        };
        timer.start();
        vBox.getChildren().add(button);
        stage.setScene(scene);
        stage.show();
    }

    private Animation sendMessage(String message) {
        final IntegerProperty i = new SimpleIntegerProperty(0);
        Timeline timeline = new Timeline();
        KeyFrame keyFrame = new KeyFrame(
                Duration.millis(40),
                event -> {
                    if (i.get() > message.length()) {
                        timeline.stop();
                    } else {
                        messageLabel.setText(message.substring(0, i.get()));
                        i.set(i.get() + 1);
                    }
                });
        timeline.getKeyFrames().add(keyFrame);
        timeline.setCycleCount(Animation.INDEFINITE);
        return timeline ;
    }

    public static void main(String[] args) {
        launch();
    }
}",public class AnimationTest extends Application {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import com.google.gson.Gson;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.EventQueue;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try (InputStreamReader reader = new InputStreamReader(getClass().getResourceAsStream(""/resources/ImportantStuff.json""))) {
                    Gson gson = new Gson();
                    Item[] items = gson.fromJson(reader, Item[].class);

                    DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(""My stuff"");
                    DefaultTreeModel model = new DefaultTreeModel(rootNode);

                    for (Item item : items) {
                        populate(rootNode, item);
                    }

                    JFrame frame = new JFrame();
                    frame.add(new MainPane(model));
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);

                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class MainPane extends JPanel {

        public MainPane(TreeModel model) {
            setLayout(new BorderLayout());
            JTree tree = new JTree(model);
            tree.setCellRenderer(new ItemTreeCellRenderer());
            tree.setShowsRootHandles(true);
            add(new JScrollPane(tree));
        }

    }

    public class ItemTreeCellRenderer extends DefaultTreeCellRenderer {
        @Override
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {
            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
            if (value instanceof DefaultMutableTreeNode) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
                Object userObject = node.getUserObject();
                if (userObject instanceof Item) {
                    Item item = (Item) userObject;
                    setText(item.getName());
                }
            }
            return this;
        }

    }

    protected void populate(DefaultMutableTreeNode parent, Item item) {
        DefaultMutableTreeNode node = new DefaultMutableTreeNode(item);
        parent.add(node);

        for (Item child : item.getContents()) {
            populate(node, child);
        }
    }

    public class Item {
        private String name;
        private List<Item> contents;

        public Item(String name) {
            this.name = name;
            this.contents = new ArrayList<>(8);
        }

        public String getName() {
            return name;
        }

        public List<Item> getContents() {
            return contents;
        }
    }
}",    public class MainPane extends JPanel {,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Container.setLayout(LayoutManager) ,"import com.google.gson.Gson;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.EventQueue;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try (InputStreamReader reader = new InputStreamReader(getClass().getResourceAsStream(""/resources/ImportantStuff.json""))) {
                    Gson gson = new Gson();
                    Item[] items = gson.fromJson(reader, Item[].class);

                    DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(""My stuff"");
                    DefaultTreeModel model = new DefaultTreeModel(rootNode);

                    for (Item item : items) {
                        populate(rootNode, item);
                    }

                    JFrame frame = new JFrame();
                    frame.add(new MainPane(model));
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);

                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class MainPane extends JPanel {

        public MainPane(TreeModel model) {
            setLayout(new BorderLayout());
            JTree tree = new JTree(model);
            tree.setCellRenderer(new ItemTreeCellRenderer());
            tree.setShowsRootHandles(true);
            add(new JScrollPane(tree));
        }

    }

    public class ItemTreeCellRenderer extends DefaultTreeCellRenderer {
        @Override
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {
            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
            if (value instanceof DefaultMutableTreeNode) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
                Object userObject = node.getUserObject();
                if (userObject instanceof Item) {
                    Item item = (Item) userObject;
                    setText(item.getName());
                }
            }
            return this;
        }

    }

    protected void populate(DefaultMutableTreeNode parent, Item item) {
        DefaultMutableTreeNode node = new DefaultMutableTreeNode(item);
        parent.add(node);

        for (Item child : item.getContents()) {
            populate(node, child);
        }
    }

    public class Item {
        private String name;
        private List<Item> contents;

        public Item(String name) {
            this.name = name;
            this.contents = new ArrayList<>(8);
        }

        public String getName() {
            return name;
        }

        public List<Item> getContents() {
            return contents;
        }
    }
}",            setLayout(new BorderLayout());,StackOverflow
ConstructorCallsOverridableMethod,Overridable method called during object construction: Container.add(Component) ,"import com.google.gson.Gson;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.EventQueue;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try (InputStreamReader reader = new InputStreamReader(getClass().getResourceAsStream(""/resources/ImportantStuff.json""))) {
                    Gson gson = new Gson();
                    Item[] items = gson.fromJson(reader, Item[].class);

                    DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(""My stuff"");
                    DefaultTreeModel model = new DefaultTreeModel(rootNode);

                    for (Item item : items) {
                        populate(rootNode, item);
                    }

                    JFrame frame = new JFrame();
                    frame.add(new MainPane(model));
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);

                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class MainPane extends JPanel {

        public MainPane(TreeModel model) {
            setLayout(new BorderLayout());
            JTree tree = new JTree(model);
            tree.setCellRenderer(new ItemTreeCellRenderer());
            tree.setShowsRootHandles(true);
            add(new JScrollPane(tree));
        }

    }

    public class ItemTreeCellRenderer extends DefaultTreeCellRenderer {
        @Override
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {
            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
            if (value instanceof DefaultMutableTreeNode) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
                Object userObject = node.getUserObject();
                if (userObject instanceof Item) {
                    Item item = (Item) userObject;
                    setText(item.getName());
                }
            }
            return this;
        }

    }

    protected void populate(DefaultMutableTreeNode parent, Item item) {
        DefaultMutableTreeNode node = new DefaultMutableTreeNode(item);
        parent.add(node);

        for (Item child : item.getContents()) {
            populate(node, child);
        }
    }

    public class Item {
        private String name;
        private List<Item> contents;

        public Item(String name) {
            this.name = name;
            this.contents = new ArrayList<>(8);
        }

        public String getName() {
            return name;
        }

        public List<Item> getContents() {
            return contents;
        }
    }
}",            add(new JScrollPane(tree));,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import com.google.gson.Gson;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.EventQueue;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    public Main() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try (InputStreamReader reader = new InputStreamReader(getClass().getResourceAsStream(""/resources/ImportantStuff.json""))) {
                    Gson gson = new Gson();
                    Item[] items = gson.fromJson(reader, Item[].class);

                    DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(""My stuff"");
                    DefaultTreeModel model = new DefaultTreeModel(rootNode);

                    for (Item item : items) {
                        populate(rootNode, item);
                    }

                    JFrame frame = new JFrame();
                    frame.add(new MainPane(model));
                    frame.pack();
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);

                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });
    }

    public class MainPane extends JPanel {

        public MainPane(TreeModel model) {
            setLayout(new BorderLayout());
            JTree tree = new JTree(model);
            tree.setCellRenderer(new ItemTreeCellRenderer());
            tree.setShowsRootHandles(true);
            add(new JScrollPane(tree));
        }

    }

    public class ItemTreeCellRenderer extends DefaultTreeCellRenderer {
        @Override
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {
            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
            if (value instanceof DefaultMutableTreeNode) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
                Object userObject = node.getUserObject();
                if (userObject instanceof Item) {
                    Item item = (Item) userObject;
                    setText(item.getName());
                }
            }
            return this;
        }

    }

    protected void populate(DefaultMutableTreeNode parent, Item item) {
        DefaultMutableTreeNode node = new DefaultMutableTreeNode(item);
        parent.add(node);

        for (Item child : item.getContents()) {
            populate(node, child);
        }
    }

    public class Item {
        private String name;
        private List<Item> contents;

        public Item(String name) {
            this.name = name;
            this.contents = new ArrayList<>(8);
        }

        public String getName() {
            return name;
        }

        public List<Item> getContents() {
            return contents;
        }
    }
}",    public class ItemTreeCellRenderer extends DefaultTreeCellRenderer {,StackOverflow
TestClassWithoutTestCases,"The class 'SOTest' might be a test class, but it contains no test cases.","@SessionFactory
@DomainModel(annotatedClasses = {SOTest.BaseballGame.class, SOTest.BaseballWeather.class})
public class SOTest {

    @Test void test(SessionFactoryScope scope) {
        BaseballGame game = new BaseballGame();
        BaseballWeather weather = new BaseballWeather();

        game.setGameId(12345L);
        game.setWeather(weather);

        // Note that the id field was never set!
        //weather.id = 12345L;

        weather.setTemperature(70.0);
        weather.setGame(game);

        scope.inSession(session-> {
            Transaction transaction = session.beginTransaction();
            session.merge(game);
            transaction.commit();
        });
        scope.inSession(session-> {
            Transaction transaction = session.beginTransaction();
            session.merge(game);
            transaction.commit();
        });
    }

    @Entity
    @Table(name = ""baseball_game"")
    static public class BaseballGame {

        @Id
        private Long gameId;

        @OneToOne(mappedBy = ""game"", cascade = CascadeType.MERGE)
        private BaseballWeather weather;

        public void setGameId(Long gameId) {
            this.gameId = gameId;
        }

        public void setWeather(BaseballWeather weather) {
            this.weather = weather;
        }
    }

    @Entity
    @Table(name = ""baseball_weather"")
    static public class BaseballWeather {

        @Id
        private Long id;

        private Double temperature;

        @OneToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = ""game_id"")
        @MapsId
        private BaseballGame game;

        public void setTemperature(Double temperature) {
            this.temperature = temperature;
        }

        public void setGame(BaseballGame game) {
            this.game = game;
        }
    }

}",public class SOTest {,StackOverflow
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import java.io.FileOutputStream;
import org.apache.poi.util.Units;
import org.apache.poi.xddf.usermodel.*;
import org.apache.poi.xddf.usermodel.chart.*;
import org.apache.poi.xwpf.usermodel.*;

public class BarChartWordMinimal {
    
 public static void main(String[] args) throws Exception {
  XWPFDocument doc = new XWPFDocument();

  // Create some normal XWPF content 
  XWPFParagraph paragraph = doc.createParagraph();
  XWPFRun run = paragraph.createRun();
  run.setText(""Bar Chart Example:"");
 
  // Create the chart
  XWPFChart categoryChart = doc.createChart(10 * Units.EMU_PER_CENTIMETER, 5 * Units.EMU_PER_CENTIMETER);

  // Create chart data sources
  String[] categories = new String[]{""Critical"", ""High"", ""Medium"",""Low"",""Best Practice""};
  Double[] values = new Double[]{(double) 1,(double) 2,(double) 3,(double) 4,(double) 5};
  XDDFDataSource<String> categoryDataSource = XDDFDataSourcesFactory.fromArray(categories);
  XDDFNumericalDataSource<Double> valueDataSource = XDDFDataSourcesFactory.fromArray(values);
         
  // Create the category axis
  XDDFCategoryAxis categoryAxis = categoryChart.createCategoryAxis(AxisPosition.BOTTOM);
  
  // Create the value axis  - axis position top is illogical for value axis but will not lead to error
  //XDDFValueAxis valueAxis = categoryChart.createValueAxis(AxisPosition.TOP);
  XDDFValueAxis valueAxis = categoryChart.createValueAxis(AxisPosition.LEFT);
  
  // Set how the axis cross - for example at zero point of value axis
  valueAxis.setCrosses(AxisCrosses.AUTO_ZERO);
  
  // Set AxisCrossBetween, so the value axis crosses the category axis between the categories.
  // Else first and last category is exactly on cross points and the bars are only half visible.
  valueAxis.setCrossBetween(AxisCrossBetween.BETWEEN);

  XDDFChartData data = categoryChart.createData(ChartTypes.BAR,  categoryAxis, valueAxis);
  // Set bar direction
  //((XDDFBarChartData)data).setBarDirection(BarDirection.BAR);   
  ((XDDFBarChartData)data).setBarDirection(BarDirection.COL);   
  
  // Set chart title - optinal
  categoryChart.setTitleText(""Evoke"");
  
  // Add series
  XDDFChartData.Series series = data.addSeries(categoryDataSource, valueDataSource);
  
  // Set series title - not optional 
  series.setTitle(""Fruit Sales"", null);

  // Set series fill color - necessary for LibreOffice as this will not use default colors
  solidFillSeries(series, PresetColor.BLUE);

  // Plot the chart
  categoryChart.plot(data);
    
  // Save the document
  FileOutputStream out = new FileOutputStream(""bar_chart_document.docx"");
  doc.write(out);
  out.close();
  doc.close();

  System.out.println(""chart created successfully!"");
 }
 
 private static void solidFillSeries(XDDFChartData.Series series, PresetColor color) {
  XDDFSolidFillProperties fill = new XDDFSolidFillProperties(XDDFColor.from(color));
  XDDFShapeProperties properties = series.getShapeProperties();
  if (properties == null) {
   properties = new XDDFShapeProperties();
  }
  properties.setFillProperties(fill);
  series.setShapeProperties(properties);
 }
}","  FileOutputStream out = new FileOutputStream(""bar_chart_document.docx"");",StackOverflow
TestClassWithoutTestCases,"The class 'FileChooserPopupMenuTest' might be a test class, but it contains no test cases.","import java.awt.*;
import java.util.Objects;
import java.util.stream.Stream;
import javax.swing.*;

public class FileChooserPopupMenuTest {
  public static void main(String[] args) {
    EventQueue.invokeLater(() -> {
      JFileChooser chooser = new JFileChooser();
      descendants(chooser)
          .filter(JPanel.class::isInstance)
          .map(c -> ((JPanel) c).getComponentPopupMenu())
          .filter(Objects::nonNull)
          .findFirst()
          .ifPresent(popup -> {
            popup.addSeparator();
            popup.add(new JCheckBoxMenuItem(""JCheckBoxMenuItem""));
          });
      chooser.showOpenDialog(null);
    });
  }

  public static Stream<Component> descendants(Container parent) {
    return Stream.of(parent.getComponents())
        .filter(Container.class::isInstance)
        .map(Container.class::cast)
        .flatMap(c -> Stream.concat(Stream.of(c), descendants(c)));
  }
}",public class FileChooserPopupMenuTest {,StackOverflow
AssignmentInOperand,Avoid assignments in operands,"import org.lwjgl.BufferUtils;
import org.lwjgl.glfw.GLFW;
import org.lwjgl.glfw.GLFWErrorCallback;
import org.lwjgl.opengl.GL;
import org.lwjgl.opengl.GL30;
import org.lwjgl.opengl.GLUtil;

import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;

public class MinimalExample {

    private static void debugPrintErrors() {
        System.out.println(""-> DEBUG PRINT ERRORS"");
        int error;
        while ((error = GL30.glGetError()) != GL30.GL_NO_ERROR) {
            StringBuilder b = new StringBuilder("" "");
            switch (error) {
                case GL30.GL_INVALID_ENUM                  -> b.append(""INVALID_ENUM"");
                case GL30.GL_INVALID_VALUE                 -> b.append(""INVALID_VALUE"");
                case GL30.GL_INVALID_OPERATION             -> b.append(""INVALID_OP"");
                case GL30.GL_INVALID_FRAMEBUFFER_OPERATION -> b.append(""INVALID_FB_OP"");
            }

            System.out.println(b);
        }
    }

    private static String readResource(String res) {
        try {
            InputStream is = MinimalExample.class.getResourceAsStream(res);
            String s = new String(is.readAllBytes(), StandardCharsets.UTF_8);
            is.close();
            return s;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    // vertex data buffer
    private static final ByteBuffer buf = BufferUtils.createByteBuffer(4096);

    // shader program
    static int program;

    // render objects
    static int vao;
    static int vbo;

    public static void main(String[] args) {
        // set buffer limit
        buf.limit(4096).position(0);

        // init glfw and create window
        GLFW.glfwInit();
        long window = GLFW.glfwCreateWindow(500, 500, ""Hello"", 0, 0);

        // create GL
        GLFW.glfwMakeContextCurrent(window);
        GL.createCapabilities();
        GLUtil.setupDebugMessageCallback(System.out);
        GLFW.glfwSetErrorCallback(GLFWErrorCallback.createPrint(System.out));

        // create vertex objects
        vao = GL30.glGenVertexArrays();
        vbo = GL30.glGenBuffers();
        GL30.glBindVertexArray(vao);
        GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vbo);
        GL30.glVertexAttribPointer(0, 3, GL30.GL_FLOAT, false, 7 * 4, 0);
        GL30.glVertexAttribPointer(1, 4, GL30.GL_FLOAT, false, 7 * 4, 4 * 3);
        GL30.glEnableVertexAttribArray(0);
        GL30.glEnableVertexAttribArray(1);

        // compile and link shaders
        int vertexShader   = GL30.glCreateShader(GL30.GL_VERTEX_SHADER);
        int fragmentShader = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER);
        GL30.glShaderSource(vertexShader,   readResource(""/test.vsh""));
        GL30.glShaderSource(fragmentShader, readResource(""/test.fsh""));
        GL30.glCompileShader(vertexShader);
        GL30.glCompileShader(fragmentShader);
        program = GL30.glCreateProgram();
        GL30.glAttachShader(program, vertexShader);
        GL30.glAttachShader(program, fragmentShader);
        GL30.glLinkProgram(program);

        // render loop
        while (!GLFW.glfwWindowShouldClose(window)) {
            // poll events
            GLFW.glfwPollEvents();

            // clear screen
            GL30.glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
            GL30.glClear(GL30.GL_COLOR_BUFFER_BIT);

            // render
            render();

            // swap buffers
            GLFW.glfwSwapBuffers(window);
        }
    }

    static void render() {
        // put vertex data
        // manual to simulate graphics library
        putVec3(0.25f, 0.25f, 1f); putVec4(1.0f, 0.0f, 0.0f, 1.0f);
        putVec3(0.75f, 0.25f, 1f); putVec4(0.0f, 1.0f, 0.0f, 1.0f);
        putVec3(0.50f, 0.75f, 1f); putVec4(0.0f, 0.0f, 1.0f, 1.0f);

        buf.flip();

        // bind program
        GL30.glUseProgram(program);

        // bind vertex array
        GL30.glBindVertexArray(vao);
        GL30.glEnableVertexAttribArray(0);
        GL30.glEnableVertexAttribArray(1);

        // upload graphics data and draw
        GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vbo);
        GL30.glBufferData(GL30.GL_ARRAY_BUFFER, buf, GL30.GL_STATIC_DRAW);
        GL30.glDrawArrays(GL30.GL_TRIANGLES, 0, 3);

        // reset vertex data buffer
        buf.clear();
    }

    //////////////////////////////////////////

    static void putVec3(float x, float y, float z) {
        buf.putFloat(x);
        buf.putFloat(y);
        buf.putFloat(z);
    }

    static void putVec4(float x, float y, float z, float w) {
        buf.putFloat(x);
        buf.putFloat(y);
        buf.putFloat(z);
        buf.putFloat(w);
    }

}",        while ((error = GL30.glGetError()) != GL30.GL_NO_ERROR) {,StackOverflow
CloseResource,Ensure that resources like this InputStream object are closed after use,"import org.lwjgl.BufferUtils;
import org.lwjgl.glfw.GLFW;
import org.lwjgl.glfw.GLFWErrorCallback;
import org.lwjgl.opengl.GL;
import org.lwjgl.opengl.GL30;
import org.lwjgl.opengl.GLUtil;

import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;

public class MinimalExample {

    private static void debugPrintErrors() {
        System.out.println(""-> DEBUG PRINT ERRORS"");
        int error;
        while ((error = GL30.glGetError()) != GL30.GL_NO_ERROR) {
            StringBuilder b = new StringBuilder("" "");
            switch (error) {
                case GL30.GL_INVALID_ENUM                  -> b.append(""INVALID_ENUM"");
                case GL30.GL_INVALID_VALUE                 -> b.append(""INVALID_VALUE"");
                case GL30.GL_INVALID_OPERATION             -> b.append(""INVALID_OP"");
                case GL30.GL_INVALID_FRAMEBUFFER_OPERATION -> b.append(""INVALID_FB_OP"");
            }

            System.out.println(b);
        }
    }

    private static String readResource(String res) {
        try {
            InputStream is = MinimalExample.class.getResourceAsStream(res);
            String s = new String(is.readAllBytes(), StandardCharsets.UTF_8);
            is.close();
            return s;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    // vertex data buffer
    private static final ByteBuffer buf = BufferUtils.createByteBuffer(4096);

    // shader program
    static int program;

    // render objects
    static int vao;
    static int vbo;

    public static void main(String[] args) {
        // set buffer limit
        buf.limit(4096).position(0);

        // init glfw and create window
        GLFW.glfwInit();
        long window = GLFW.glfwCreateWindow(500, 500, ""Hello"", 0, 0);

        // create GL
        GLFW.glfwMakeContextCurrent(window);
        GL.createCapabilities();
        GLUtil.setupDebugMessageCallback(System.out);
        GLFW.glfwSetErrorCallback(GLFWErrorCallback.createPrint(System.out));

        // create vertex objects
        vao = GL30.glGenVertexArrays();
        vbo = GL30.glGenBuffers();
        GL30.glBindVertexArray(vao);
        GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vbo);
        GL30.glVertexAttribPointer(0, 3, GL30.GL_FLOAT, false, 7 * 4, 0);
        GL30.glVertexAttribPointer(1, 4, GL30.GL_FLOAT, false, 7 * 4, 4 * 3);
        GL30.glEnableVertexAttribArray(0);
        GL30.glEnableVertexAttribArray(1);

        // compile and link shaders
        int vertexShader   = GL30.glCreateShader(GL30.GL_VERTEX_SHADER);
        int fragmentShader = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER);
        GL30.glShaderSource(vertexShader,   readResource(""/test.vsh""));
        GL30.glShaderSource(fragmentShader, readResource(""/test.fsh""));
        GL30.glCompileShader(vertexShader);
        GL30.glCompileShader(fragmentShader);
        program = GL30.glCreateProgram();
        GL30.glAttachShader(program, vertexShader);
        GL30.glAttachShader(program, fragmentShader);
        GL30.glLinkProgram(program);

        // render loop
        while (!GLFW.glfwWindowShouldClose(window)) {
            // poll events
            GLFW.glfwPollEvents();

            // clear screen
            GL30.glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
            GL30.glClear(GL30.GL_COLOR_BUFFER_BIT);

            // render
            render();

            // swap buffers
            GLFW.glfwSwapBuffers(window);
        }
    }

    static void render() {
        // put vertex data
        // manual to simulate graphics library
        putVec3(0.25f, 0.25f, 1f); putVec4(1.0f, 0.0f, 0.0f, 1.0f);
        putVec3(0.75f, 0.25f, 1f); putVec4(0.0f, 1.0f, 0.0f, 1.0f);
        putVec3(0.50f, 0.75f, 1f); putVec4(0.0f, 0.0f, 1.0f, 1.0f);

        buf.flip();

        // bind program
        GL30.glUseProgram(program);

        // bind vertex array
        GL30.glBindVertexArray(vao);
        GL30.glEnableVertexAttribArray(0);
        GL30.glEnableVertexAttribArray(1);

        // upload graphics data and draw
        GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vbo);
        GL30.glBufferData(GL30.GL_ARRAY_BUFFER, buf, GL30.GL_STATIC_DRAW);
        GL30.glDrawArrays(GL30.GL_TRIANGLES, 0, 3);

        // reset vertex data buffer
        buf.clear();
    }

    //////////////////////////////////////////

    static void putVec3(float x, float y, float z) {
        buf.putFloat(x);
        buf.putFloat(y);
        buf.putFloat(z);
    }

    static void putVec4(float x, float y, float z, float w) {
        buf.putFloat(x);
        buf.putFloat(y);
        buf.putFloat(z);
        buf.putFloat(w);
    }

}",            InputStream is = MinimalExample.class.getResourceAsStream(res);,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"public class heliocentric {
    public static void main(String[] args) {
        var scanner = new java.util.Scanner(System.in);

        for (int i = 1; scanner.hasNextInt(); i++) {
            int days = 0;
            int e = scanner.nextInt();
            int m = scanner.nextInt();

            while (e != 0 || m != 0) {
                e = (e + 1) % 365;
                m = (m + 1) % 687;
                days++;
            }

            System.out.println(""Case "" + i + "": "" + days);
        }

        scanner.close();
    }
}",        var scanner = new java.util.Scanner(System.in);,StackOverflow
CloseResource,Ensure that resources like this InputStream object are closed after use,"import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp;
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.client.util.DateTime;
import com.google.api.client.util.store.FileDataStoreFactory;
import com.google.api.services.calendar.Calendar;
import com.google.api.services.calendar.CalendarScopes;
import com.google.api.services.calendar.model.Event;
import com.google.api.services.calendar.model.Events;
import com.google.api.services.calendar.model.EventDateTime;
import com.google.api.services.calendar.model.EventReminder;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.GeneralSecurityException;
import java.util.Collections;
import java.util.List;
import java.util.Arrays;

/* class to demonstarte use of Calendar events list API */
public class CalendarQuickstart {
  /**
   * Application name.
   */
  private static final String APPLICATION_NAME = ""Google Calendar API Java Quickstart"";
  /**
   * Global instance of the JSON factory.
   */
  private static final JsonFactory JSON_FACTORY = GsonFactory.getDefaultInstance();
  /**
   * Directory to store authorization tokens for this application.
   */
  private static final String TOKENS_DIRECTORY_PATH = ""tokens"";

  /**
   * Global instance of the scopes required by this quickstart.
   * If modifying these scopes, delete your previously saved tokens/ folder.
   */
  private static final List<String> SCOPES =
      Collections.singletonList(CalendarScopes.CALENDAR);
  private static final String CREDENTIALS_FILE_PATH = ""/credentials.json"";

  /**
   * Creates an authorized Credential object.
   *
   * @param HTTP_TRANSPORT The network HTTP Transport.
   * @return An authorized Credential object.
   * @throws IOException If the credentials.json file cannot be found.
   */
  private static Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT)
      throws IOException {
    // Load client secrets.
    InputStream in = CalendarQuickstart.class.getResourceAsStream(CREDENTIALS_FILE_PATH);
    if (in == null) {
      throw new FileNotFoundException(""Resource not found: "" + CREDENTIALS_FILE_PATH);
    }
    GoogleClientSecrets clientSecrets =
        GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));

    // Build flow and trigger user authorization request.
    GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(
        HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)
        .setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))
        .setAccessType(""offline"")
        .build();
    LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8888).build();
    Credential credential = new AuthorizationCodeInstalledApp(flow, receiver).authorize(""user"");
    //returns an authorized Credential object.
    return credential;
  }

  public static void main(String... args) throws IOException, GeneralSecurityException {
    // Build a new authorized API client service.
    final NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
    Calendar service =
        new Calendar.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT))
            .setApplicationName(APPLICATION_NAME)
            .build();

    Event event = new Event()
        .setSummary(""Google I/O 2015"")
        .setLocation(""800 Howard St., San Francisco, CA 94103"")
        .setDescription(""A chance to hear more about Google's developer products."");

    DateTime startDateTime = new DateTime(""2022-11-25"");
    EventDateTime start = new EventDateTime().setDate(startDateTime);
    event.setStart(start);
 
    DateTime endDateTime = new DateTime(""2022-11-25"");
    EventDateTime end = new EventDateTime().setDate(endDateTime);
    event.setEnd(end);

    EventReminder[] reminderOverrides = new EventReminder[] {
        new EventReminder().setMethod(""email"").setMinutes(0),
    };
    Event.Reminders reminders = new Event.Reminders()
        .setUseDefault(false)
        .setOverrides(Arrays.asList(reminderOverrides));
    event.setReminders(reminders);

    String calendarId = ""primary"";
    event = service.events().insert(calendarId, event).execute();
    System.out.printf(""Event created: %s\n"", event.getHtmlLink());
  }
}",    InputStream in = CalendarQuickstart.class.getResourceAsStream(CREDENTIALS_FILE_PATH);,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.Objects;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        boolean MO=true;

        while(MO==true) {
            MO=false;
        System.out.println(""Please enter your operation"");
        System.out.println(""1 - Addition"");
        System.out.println(""2 - Subtraction"");
        System.out.println(""3 - Multiplication"");
        System.out.println(""4 - Division"");
        Scanner scanner = new Scanner(System.in);
        int op = scanner.nextInt();
        System.out.println(op);
        scanner.reset();
        // Addition
        if(op == 1) {
            System.out.println(""Enter a starting value!"");
            int as =   scanner.nextInt();
            scanner.reset();

            boolean ab = true;
            while(ab) {
                ab=false;
                System.out.println(""Please enter a number to add or type 'End' to end or 'Clear' to reset or 'Restart' to exit the mode"");
                String an = scanner.next();
                if(Objects.equals(an, ""End"")) {
                    System.out.println(""Quitting""); }
                else if(Objects.equals(an,""Clear"")) {
                    int  ae = 0;
                    System.out.println(""Cache clear!"");
                    ab = true;} else if(Objects.equals(an,""Restart"")) {
                        System.out.println(""Restarting!"");
                        MO=true;
                        break;
                    }else {
                        int ra = Integer.parseInt(an);


                        int ae = as+ra;
                        System.out.println(ae);
                        as = ae;
                    }}
        }}
    }
}",        Scanner scanner = new Scanner(System.in);,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.Objects;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        boolean MO=true;

        while(MO==true) {
            MO=false;
        System.out.println(""Please enter your operation"");
        System.out.println(""1 - Addition"");
        System.out.println(""2 - Subtraction"");
        System.out.println(""3 - Multiplication"");
        System.out.println(""4 - Division"");
        Scanner scanner = new Scanner(System.in);
        int op = scanner.nextInt();
        System.out.println(op);
        scanner.reset();
        // Addition
        if(op == 1) {
            System.out.println(""Enter a starting value!"");
            int as =   scanner.nextInt();
            scanner.reset();

            boolean ab = true;
            while(ab) {
                ab=false;
                System.out.println(""Please enter a number to add or type 'End' to end or 'Clear' to reset or 'Restart' to exit the mode"");
                String an = scanner.next();
                if(Objects.equals(an, ""End"")) {
                    System.out.println(""Quitting""); }
                else if(Objects.equals(an,""Clear"")) {
                    int  ae = 0;
                    System.out.println(""Cache clear!"");
                    ab = true;} else if(Objects.equals(an,""Restart"")) {
                        System.out.println(""Restarting!"");
                        MO=true;
                        break;
                    }else {
                        int ra = Integer.parseInt(an);


                        int ae = as+ra;
                        System.out.println(ae);
                        as = ae;
                    }}
        }}
    }
}",        if(op == 1) {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"class Cronometro {
    private int secondi;
    private int minuti;
    private int ore;
    private boolean state=true;
    private Timer timer;

    private final JLabel s, m,  h;

    public Cronometro(JLabel s, JLabel m, JLabel h) {
        this.s = s;
        this.m = m;
        this.h = h;
    }

    public void crono(JLabel s, JLabel m, JLabel h){
        state=true;
        if(timer != null) {
            timer.stop();
        }

        timer = new Timer(1000, e->update());
        timer.start();
    }

    public void update(){

        if(! state) return;
        secondi++;
        if(secondi>60){
            secondi=0;
            minuti++;
        }

        if(minuti>60){
            secondi=0;
            minuti=0;
            ore++;
        }
        s.setText("" :""+secondi);
        m.setText("" : ""+minuti);
        h.setText(""""+ore);
    }

    public void setState(boolean state){
        this.state=state;
    }
}",        if(secondi>60){,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"class Cronometro {
    private int secondi;
    private int minuti;
    private int ore;
    private boolean state=true;
    private Timer timer;

    private final JLabel s, m,  h;

    public Cronometro(JLabel s, JLabel m, JLabel h) {
        this.s = s;
        this.m = m;
        this.h = h;
    }

    public void crono(JLabel s, JLabel m, JLabel h){
        state=true;
        if(timer != null) {
            timer.stop();
        }

        timer = new Timer(1000, e->update());
        timer.start();
    }

    public void update(){

        if(! state) return;
        secondi++;
        if(secondi>60){
            secondi=0;
            minuti++;
        }

        if(minuti>60){
            secondi=0;
            minuti=0;
            ore++;
        }
        s.setText("" :""+secondi);
        m.setText("" : ""+minuti);
        h.setText(""""+ore);
    }

    public void setState(boolean state){
        this.state=state;
    }
}",        if(minuti>60){,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"public class Account {

    private final Email email;
    private final Password password;

    public Account(Email email, Password password) {
        Objects.requireNonNull(email, ""An account cannot have null email"");
        Objects.requireNonNull(email, ""An account cannot have null password"");
        this.email = email;
        this.password = password;
    }

    public Email getEmail() {
        return email;
    }

    public Password getPassword() {
        return password;
    }

    public static class InvalidAccountInformationException extends RuntimeException {

        public InvalidAccountInformationException(String message) {
            super(message);
        }
    }
}

public class Email {
    private final String value;

    private Email(String value) {
        this.value = value;
    }

    public String value() {
        return value;
    }

    // Eclipse generated
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    // Eclipse generated
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Email other = (Email) obj;
        return Objects.equals(value, other.value);
    }

    public static Email of(final String email) {
        if (email == null)
            throw new InvalidAccountInformationException(""Email cannot be empty."");

        String trimmedEmail = email.trim();

        if (trimmedEmail.isEmpty())
            throw new InvalidAccountInformationException(""Email cannot be empty."");

        if (!isValidEmailAddress(trimmedEmail))
            throw new InvalidAccountInformationException(""Email is not a valid email address."");

        return new Email(trimmedEmail);
    }

    /*
     * Shamelessly copy-pasta from https://stackoverflow.com/a/16058059/6579265
     */
    private static boolean isValidEmailAddress(String email) {
        String ePattern = ""^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@((\\[[0-9]{1,3}\\.[0-9]{1,3}""
                + ""\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$"";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(ePattern);
        java.util.regex.Matcher m = p.matcher(email);
        return m.matches();
    }
}

public class Password {
    private static final String[] MANDATORY_CHARACTERS = { ""!"", ""#"", ""$"", ""%"", ""^"", ""&"", ""*"" };
    private final String value;

    private Password(String value) {
        this.value = value;
    }

    public String value() {
        return value;
    }

    public static Password of(final String pass) {
        if (pass == null || pass.trim().isEmpty())
            throw new InvalidAccountInformationException(""Password cannot be empty."");

        if (!containsAtLeastOneMandatoryCharacter(pass))
            throw new InvalidAccountInformationException(""Password is too weak."");

        return new Password(pass);
    }

    private static boolean containsAtLeastOneMandatoryCharacter(String pass) {
        return Stream.of(MANDATORY_CHARACTERS).anyMatch(pass::contains);
    }

    // Eclipse generated
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    // Eclipse generated
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Password other = (Password) obj;
        return Objects.equals(value, other.value);
    }

}

public class AccountDatabase {

    private final List<Account> accounts = new ArrayList<>();

    public void save(Account account) {
        Objects.requireNonNull(account, ""Account should not be null"");

        if (emailIsAlreadyTaken(account))
            throw new InvalidAccountInformationException(""Email is already taken by another user."");

        accounts.add(account);
    }

    private boolean emailIsAlreadyTaken(Account account) {
        return accounts.stream().map(Account::getEmail).anyMatch(account::equals);
    }
}",    public static class InvalidAccountInformationException extends RuntimeException {,StackOverflow
AvoidFieldNameMatchingMethodName,Field value has the same name as a method,"public class Account {

    private final Email email;
    private final Password password;

    public Account(Email email, Password password) {
        Objects.requireNonNull(email, ""An account cannot have null email"");
        Objects.requireNonNull(email, ""An account cannot have null password"");
        this.email = email;
        this.password = password;
    }

    public Email getEmail() {
        return email;
    }

    public Password getPassword() {
        return password;
    }

    public static class InvalidAccountInformationException extends RuntimeException {

        public InvalidAccountInformationException(String message) {
            super(message);
        }
    }
}

public class Email {
    private final String value;

    private Email(String value) {
        this.value = value;
    }

    public String value() {
        return value;
    }

    // Eclipse generated
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    // Eclipse generated
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Email other = (Email) obj;
        return Objects.equals(value, other.value);
    }

    public static Email of(final String email) {
        if (email == null)
            throw new InvalidAccountInformationException(""Email cannot be empty."");

        String trimmedEmail = email.trim();

        if (trimmedEmail.isEmpty())
            throw new InvalidAccountInformationException(""Email cannot be empty."");

        if (!isValidEmailAddress(trimmedEmail))
            throw new InvalidAccountInformationException(""Email is not a valid email address."");

        return new Email(trimmedEmail);
    }

    /*
     * Shamelessly copy-pasta from https://stackoverflow.com/a/16058059/6579265
     */
    private static boolean isValidEmailAddress(String email) {
        String ePattern = ""^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@((\\[[0-9]{1,3}\\.[0-9]{1,3}""
                + ""\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$"";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(ePattern);
        java.util.regex.Matcher m = p.matcher(email);
        return m.matches();
    }
}

public class Password {
    private static final String[] MANDATORY_CHARACTERS = { ""!"", ""#"", ""$"", ""%"", ""^"", ""&"", ""*"" };
    private final String value;

    private Password(String value) {
        this.value = value;
    }

    public String value() {
        return value;
    }

    public static Password of(final String pass) {
        if (pass == null || pass.trim().isEmpty())
            throw new InvalidAccountInformationException(""Password cannot be empty."");

        if (!containsAtLeastOneMandatoryCharacter(pass))
            throw new InvalidAccountInformationException(""Password is too weak."");

        return new Password(pass);
    }

    private static boolean containsAtLeastOneMandatoryCharacter(String pass) {
        return Stream.of(MANDATORY_CHARACTERS).anyMatch(pass::contains);
    }

    // Eclipse generated
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    // Eclipse generated
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Password other = (Password) obj;
        return Objects.equals(value, other.value);
    }

}

public class AccountDatabase {

    private final List<Account> accounts = new ArrayList<>();

    public void save(Account account) {
        Objects.requireNonNull(account, ""Account should not be null"");

        if (emailIsAlreadyTaken(account))
            throw new InvalidAccountInformationException(""Email is already taken by another user."");

        accounts.add(account);
    }

    private boolean emailIsAlreadyTaken(Account account) {
        return accounts.stream().map(Account::getEmail).anyMatch(account::equals);
    }
}",    private final String value;,StackOverflow
AvoidFieldNameMatchingMethodName,Field value has the same name as a method,"public class Account {

    private final Email email;
    private final Password password;

    public Account(Email email, Password password) {
        Objects.requireNonNull(email, ""An account cannot have null email"");
        Objects.requireNonNull(email, ""An account cannot have null password"");
        this.email = email;
        this.password = password;
    }

    public Email getEmail() {
        return email;
    }

    public Password getPassword() {
        return password;
    }

    public static class InvalidAccountInformationException extends RuntimeException {

        public InvalidAccountInformationException(String message) {
            super(message);
        }
    }
}

public class Email {
    private final String value;

    private Email(String value) {
        this.value = value;
    }

    public String value() {
        return value;
    }

    // Eclipse generated
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    // Eclipse generated
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Email other = (Email) obj;
        return Objects.equals(value, other.value);
    }

    public static Email of(final String email) {
        if (email == null)
            throw new InvalidAccountInformationException(""Email cannot be empty."");

        String trimmedEmail = email.trim();

        if (trimmedEmail.isEmpty())
            throw new InvalidAccountInformationException(""Email cannot be empty."");

        if (!isValidEmailAddress(trimmedEmail))
            throw new InvalidAccountInformationException(""Email is not a valid email address."");

        return new Email(trimmedEmail);
    }

    /*
     * Shamelessly copy-pasta from https://stackoverflow.com/a/16058059/6579265
     */
    private static boolean isValidEmailAddress(String email) {
        String ePattern = ""^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@((\\[[0-9]{1,3}\\.[0-9]{1,3}""
                + ""\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$"";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(ePattern);
        java.util.regex.Matcher m = p.matcher(email);
        return m.matches();
    }
}

public class Password {
    private static final String[] MANDATORY_CHARACTERS = { ""!"", ""#"", ""$"", ""%"", ""^"", ""&"", ""*"" };
    private final String value;

    private Password(String value) {
        this.value = value;
    }

    public String value() {
        return value;
    }

    public static Password of(final String pass) {
        if (pass == null || pass.trim().isEmpty())
            throw new InvalidAccountInformationException(""Password cannot be empty."");

        if (!containsAtLeastOneMandatoryCharacter(pass))
            throw new InvalidAccountInformationException(""Password is too weak."");

        return new Password(pass);
    }

    private static boolean containsAtLeastOneMandatoryCharacter(String pass) {
        return Stream.of(MANDATORY_CHARACTERS).anyMatch(pass::contains);
    }

    // Eclipse generated
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    // Eclipse generated
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Password other = (Password) obj;
        return Objects.equals(value, other.value);
    }

}

public class AccountDatabase {

    private final List<Account> accounts = new ArrayList<>();

    public void save(Account account) {
        Objects.requireNonNull(account, ""Account should not be null"");

        if (emailIsAlreadyTaken(account))
            throw new InvalidAccountInformationException(""Email is already taken by another user."");

        accounts.add(account);
    }

    private boolean emailIsAlreadyTaken(Account account) {
        return accounts.stream().map(Account::getEmail).anyMatch(account::equals);
    }
}",    private final String value;,StackOverflow
DontImportSun,Avoid importing anything from the sun.* packages,"package com.projects;

// [START bigquery_query]
import com.google.cloud.bigquery.BigQuery;
import com.google.cloud.bigquery.BigQueryException;
import com.google.cloud.bigquery.BigQueryOptions;
import com.google.cloud.bigquery.QueryJobConfiguration; 
import com.google.cloud.bigquery.TableResult;
import com.google.cloud.bigquery.Job;
import com.google.cloud.bigquery.JobId;
import com.google.cloud.bigquery.FieldValueList;
import com.google.cloud.bigquery.JobInfo;
import com.google.cloud.bigquery.BigQuery.QueryResultsOption;
import java.util.UUID;

import sun.jvm.hotspot.debugger.Page;

public class QueryRun {

  public static void main(String[] args) {

    String projectId = ""bigquery-public-data"";
    String datasetName = ""covid19_ecdc_eu"";
    String tableName = ""covid_19_geographic_distribution_worldwide"";
    String query =
        ""SELECT * ""
            + "" FROM `""
            + projectId
            + "".""
            + datasetName
            + "".""
            + tableName
            + ""`""
            + "" LIMIT 100"";
    System.out.println(query);
    query(query);
  }

  public static void query(String query) {
    try {
      BigQuery bigquery = BigQueryOptions.getDefaultInstance().getService();
      QueryJobConfiguration queryConfig = QueryJobConfiguration.newBuilder(query).build();

      // Create a job ID so that we can safely retry.
      JobId jobId = JobId.of(UUID.randomUUID().toString());
      Job queryJob = bigquery.create(JobInfo.newBuilder(queryConfig).setJobId(jobId).build());

      TableResult results = queryJob.getQueryResults(QueryResultsOption.pageSize(10));

      int i = 0;
      int j =0; 

      // get all paged data except last line
      while(results.hasNextPage()) {
        j++;   
        for (FieldValueList row : results.getValues()) { 
            i++;
        }
        results = results.getNextPage();
        print_msg(i,j);
      }

      // last line run
      j++;
      for (FieldValueList row : results.getValues()) {  
        i++;
      }
      print_msg(i,j);

      System.out.println(""Query performed successfully."");
    } catch (BigQueryException | InterruptedException e) {
      System.out.println(""Query not performed \n"" + e.toString());
    }
  }

  public static void print_msg(int i,int j)
  {
    System.out.println(""page "" + j);
    System.out.println(""Data Extracted::"" + i + "" records""); 
  }

} 
// [END bigquery_query]",import sun.jvm.hotspot.debugger.Page;,StackOverflow
AvoidDuplicateLiterals,"The String literal ""soapenv"" appears 5 times in this file; the first occurrence is on line 39","import jakarta.xml.soap.*;
import lombok.SneakyThrows;
import org.springframework.ws.client.WebServiceClientException;
import org.springframework.ws.client.support.interceptor.ClientInterceptor;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.soap.saaj.SaajSoapMessage;

public class Interceptor implements ClientInterceptor {

    @SneakyThrows
    public boolean handleRequest(MessageContext messageContext) throws WebServiceClientException {
        changePrefix(messageContext);
        return true;
    }

    public boolean handleResponse(MessageContext messageContext) throws WebServiceClientException {
        // if you need to change in the response call the method 'changePrefix' here
        return true;
    }

    public boolean handleFault(MessageContext messageContext) throws WebServiceClientException {
        // if you need to change in the fault response call the method 'changePrefix' here
        return true;
    }

    public void afterCompletion(MessageContext messageContext, Exception e) throws WebServiceClientException {

    }

    private void changePrefix(MessageContext messageContext) throws SOAPException {
        SaajSoapMessage soapMessage = (SaajSoapMessage) messageContext.getRequest();

        SOAPEnvelope soapEnvelope = soapMessage.getSaajMessage().getSOAPPart().getEnvelope();
        SOAPHeader soapHeader = soapEnvelope.getHeader();
        SOAPBody soapBody = soapEnvelope.getBody();
        SOAPFault soapFault = soapBody.getFault();

        soapEnvelope.removeNamespaceDeclaration(soapEnvelope.getPrefix());
        soapEnvelope.addNamespaceDeclaration(""soapenv"", soapEnvelope.getNamespaceURI());
        soapEnvelope.setPrefix(""soapenv"");

        if (soapHeader != null) soapHeader.setPrefix(""soapenv"");
        if (soapBody != null) soapBody.setPrefix(""soapenv"");
        if (soapFault != null) soapFault.setPrefix(""soapenv"");
    }
}","        soapEnvelope.addNamespaceDeclaration(""soapenv"", soapEnvelope.getNamespaceURI());",StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class MainFrame extends JPanel {
    JFrame f = new JFrame();

    record Square(int x, int y) {
    }

    List<Square> squares = new ArrayList<>();

    public static void main(String[] args) throws Exception {
        System.out.println(""Hello World"");
        MainFrame myFrame = new MainFrame();
        myFrame.init();
    }

    public void init() {

        // JFrameconfiguration
        f.setTitle(""Sandsim"");
        f.add(this);
        addMouseListener(new MyMouseListener());
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f.pack();
        f.setVisible(true);

    }
    public Dimension getPreferredSize() {
        return new Dimension(600,600);
    }
    // draws the Bakground as grid of 10 by 10 squares

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        int positionX = 0;
        int positionY = 0;

        Graphics2D g2d = (Graphics2D) g;
        g2d.setColor(Color.BLACK);

        for (int i = 0; i < getBounds().width / 10; i++) {
            g2d.drawLine(positionX, 0, positionX, getBounds().height);
            positionX += 10;
        }
        for (int i = 0; i < getBounds().height / 10; i++) {
            g2d.drawLine(0, positionY, getBounds().width, positionY);
            positionY += 10;
        }

        g2d.setColor(Color.YELLOW);
        for (Square sq : squares) {
            g2d.fillRect(sq.x, sq.y, 9, 9);
        }
    }

    class MyMouseListener extends MouseAdapter {
        @Override
        public void mouseClicked(MouseEvent me) {
            squares.add(new Square(me.getX()/10*10 + 1, me.getY()/10*10+1));
            f.repaint();
        }

    }

}",public class MainFrame extends JPanel {,StackOverflow
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.Scanner;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.*;

/**
 * Test class for asynchronous input
 */
public class MainThreaded
{
    public static final int SLEEP_MILLIS = 200;
    public static final Object LOCK = new Object();
    public static boolean breakIfTrueAsynchronous = false;

    public static void main (String[] args) {
        BlockingQueue<String> inputQueue = new LinkedBlockingDeque<>();
        Scanner scanner = new Scanner(System.in);
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Runnable inputReader = () -> {
            while(true) {
                String str = scanner.nextLine();
                inputQueue.add(str);
            }
        };
        executor.execute(inputReader);

        //run a timer to get the asynchronous error every 3 sec
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                synchronized (LOCK) {
                    breakIfTrueAsynchronous = true;
                }
            }
        }, 3000, 3000);

        System.out.println(""Test asynchronous input started, write anything below:"");
        String input = """";
        while(true) { // use ctrl+C to exit
            try {
                input = inputQueue.poll(SLEEP_MILLIS, TimeUnit.MILLISECONDS);
                if(input == null) input = """"; // if timeout elapses, avoid null value
                synchronized (LOCK){
                    if(breakIfTrueAsynchronous){
                        System.err.println(""BREAK RECEIVED"");
                        //here our code would throw Exception and do something else
                        breakIfTrueAsynchronous = false;
                    }
                }
            } catch (InterruptedException ignored) {
                System.err.println(""ERROR OF READER!"");
            }
            if(!input.isEmpty()) {
                //use input here
                System.out.println(""INPUT RECEIVED: "" + input);
                input = """";
            }
        }
    }
}",        Scanner scanner = new Scanner(System.in);,StackOverflow
CloseResource,Ensure that resources like this ExecutorService object are closed after use,"import java.util.Scanner;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.*;

/**
 * Test class for asynchronous input
 */
public class MainThreaded
{
    public static final int SLEEP_MILLIS = 200;
    public static final Object LOCK = new Object();
    public static boolean breakIfTrueAsynchronous = false;

    public static void main (String[] args) {
        BlockingQueue<String> inputQueue = new LinkedBlockingDeque<>();
        Scanner scanner = new Scanner(System.in);
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Runnable inputReader = () -> {
            while(true) {
                String str = scanner.nextLine();
                inputQueue.add(str);
            }
        };
        executor.execute(inputReader);

        //run a timer to get the asynchronous error every 3 sec
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                synchronized (LOCK) {
                    breakIfTrueAsynchronous = true;
                }
            }
        }, 3000, 3000);

        System.out.println(""Test asynchronous input started, write anything below:"");
        String input = """";
        while(true) { // use ctrl+C to exit
            try {
                input = inputQueue.poll(SLEEP_MILLIS, TimeUnit.MILLISECONDS);
                if(input == null) input = """"; // if timeout elapses, avoid null value
                synchronized (LOCK){
                    if(breakIfTrueAsynchronous){
                        System.err.println(""BREAK RECEIVED"");
                        //here our code would throw Exception and do something else
                        breakIfTrueAsynchronous = false;
                    }
                }
            } catch (InterruptedException ignored) {
                System.err.println(""ERROR OF READER!"");
            }
            if(!input.isEmpty()) {
                //use input here
                System.out.println(""INPUT RECEIVED: "" + input);
                input = """";
            }
        }
    }
}",        ExecutorService executor = Executors.newSingleThreadExecutor();,StackOverflow
AvoidFieldNameMatchingMethodName,Field name has the same name as a method,"public record Person(String name, LocalDate birth) {
    
    public static class Builder {
        private String name;
        private LocalDate birth;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder birth(LocalDate birth) {
            this.birth = birth;
            return this;
        }

        public Person build() {
            return new Person(name, birth);
        }
    }
}",        private String name;,StackOverflow
AvoidFieldNameMatchingMethodName,Field birth has the same name as a method,"public record Person(String name, LocalDate birth) {
    
    public static class Builder {
        private String name;
        private LocalDate birth;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder birth(LocalDate birth) {
            this.birth = birth;
            return this;
        }

        public Person build() {
            return new Person(name, birth);
        }
    }
}",        private LocalDate birth;,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","//Test class
public class Test {
    public static void main(String[] args) {
        Node root = new Node(1, ""test1"", new Node[]{
                new Node(2, ""test2"", new Node[]{
                        new Node(5, ""test6"", new Node[]{})
                }),
                new Node(3, ""test3"", new Node[]{
                        new Node(6, ""test6"", new Node[]{}),
                        new Node(7, ""test7"", new Node[]{
                                new Node(8, ""test8"", new Node[]{})
                        })
                }),
                new Node(4, ""test4"", new Node[]{})
        });

        root.print();
    }
}

class Node {

    int value;
    String name;
    Node parent;
    int childrenCount;
    Node[] children = new Node[100];

    public Node(int value, String name) {
        this.value = value;
        this.name = name;
        this.childrenCount = 0;
    }

    //Added second constructor only to ease the test
    public Node(int value, String name, Node[] children) {
        this.value = value;
        this.name = name;
        this.children = children;
        this.childrenCount = getNumChildren(children);
    }

    public Node(String name) {
        this.name = name;
    }

    //Fixed possible exception when added more than 100 elements
    public boolean addChildren(Node node) {
        if (childrenCount == this.children.length) {
            return false;
        }
        this.children[childrenCount++] = node;
        return true;
    }

    public void setParent(Node parent) {
        this.parent = parent;
    }

    public boolean hasParent() {
        return this.parent != null;
    }

    public int sumValue() {
        int sum = 0;
        sum += this.value;
        for (int i = 0; i < childrenCount; i++) {
            sum += children[i].value;
        }
        return sum;
    }

    // small utility method to compute the effective number of children
    // when an array is passed to the new constructor
    public static int getNumChildren(Node[] children) {
        int num = 0;
        while (num < children.length && children[num] != null) {
            num++;
        }
        return num;
    }

    //print method invoked by the client of the class
    public void print() {
        printRec(this, 0);
    }

    //recursive print
    private void printRec(Node n, int numCall) {
        //identifying the base case
        if (n == null) {
            return;
        }

        //Printing as many dahses as the depth of the current child node
        for (int i = 1; i <= numCall; i++) {
            System.out.print(""--"");
        }

        //printing the node info
        System.out.println(n.name + "" ("" + n.value + "")"");

        //recursively invoking the print method for each child
        for (int i = 0; i < n.childrenCount; i++) {
            printRec(n.children[i], numCall + 1);
        }
    }
}",public class Test {,StackOverflow
AvoidDuplicateLiterals,"The String literal ""ADMIN"" appears 4 times in this file; the first occurrence is on line 34","@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authenticationProvider());

    }

    @Autowired
    private UserDetailsService userDetailsService;

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(NoOpPasswordEncoder.getInstance());
        return provider;
    }

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                .authorizeRequests().antMatchers(""/login"", ""/post/blog/**"", ""/post/viewpost"", ""/authentication/create"").permitAll()
                .antMatchers(""/post/filter/page/**"", ""/post/sorted/page/**"", ""/post/search/page/**"").permitAll()
                .antMatchers(""/authentication/register"", ""/review/comment/**"").permitAll()
                .antMatchers(""/post/newPost"", ""/post/publish"", ""/post/update"", ""/post/delete"").hasAnyAuthority(""ADMIN"", ""AUTHOR"")
                .antMatchers( ""/review/updateComment"", ""/review/deleteComment"").hasAnyAuthority(""ADMIN"", ""AUTHOR"", ""USER"")
                .antMatchers(""/rest/authenticate"", ""/rest/blog/**"", ""/rest/viewpost/**"", ""/rest/create"").permitAll()
                .antMatchers(""/rest/filter/page/**"", ""/rest/sorted/page/**"", ""/rest/search/page/**"", ""/rest/comment"").permitAll()
                .antMatchers(""/post/register"").permitAll()
                .antMatchers(""/rest/newPost"", ""/rest/publish"", ""/rest/update"", ""/rest/delete"").hasAnyAuthority(""ADMIN"", ""AUTHOR"")
                .antMatchers(""/rest/comment/**"", ""/rest/updateComment/**"", ""/post/deleteComment/**"").hasAnyAuthority(""ADMIN"", ""AUTHOR"", ""USER"")
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginPage(""/authentication/login"").permitAll()
                .defaultSuccessUrl(""/post/blog"")
                .and()
                .logout().invalidateHttpSession(true)
                .clearAuthentication(true)
                .logoutRequestMatcher(new AntPathRequestMatcher(""/logout""))
                .logoutSuccessUrl(""/authentication/logout-success"").permitAll();
    }
}","                .antMatchers(""/post/newPost"", ""/post/publish"", ""/post/update"", ""/post/delete"").hasAnyAuthority(""ADMIN"", ""AUTHOR"")",StackOverflow
AvoidDuplicateLiterals,"The String literal ""AUTHOR"" appears 4 times in this file; the first occurrence is on line 34","@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authenticationProvider());

    }

    @Autowired
    private UserDetailsService userDetailsService;

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(NoOpPasswordEncoder.getInstance());
        return provider;
    }

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                .authorizeRequests().antMatchers(""/login"", ""/post/blog/**"", ""/post/viewpost"", ""/authentication/create"").permitAll()
                .antMatchers(""/post/filter/page/**"", ""/post/sorted/page/**"", ""/post/search/page/**"").permitAll()
                .antMatchers(""/authentication/register"", ""/review/comment/**"").permitAll()
                .antMatchers(""/post/newPost"", ""/post/publish"", ""/post/update"", ""/post/delete"").hasAnyAuthority(""ADMIN"", ""AUTHOR"")
                .antMatchers( ""/review/updateComment"", ""/review/deleteComment"").hasAnyAuthority(""ADMIN"", ""AUTHOR"", ""USER"")
                .antMatchers(""/rest/authenticate"", ""/rest/blog/**"", ""/rest/viewpost/**"", ""/rest/create"").permitAll()
                .antMatchers(""/rest/filter/page/**"", ""/rest/sorted/page/**"", ""/rest/search/page/**"", ""/rest/comment"").permitAll()
                .antMatchers(""/post/register"").permitAll()
                .antMatchers(""/rest/newPost"", ""/rest/publish"", ""/rest/update"", ""/rest/delete"").hasAnyAuthority(""ADMIN"", ""AUTHOR"")
                .antMatchers(""/rest/comment/**"", ""/rest/updateComment/**"", ""/post/deleteComment/**"").hasAnyAuthority(""ADMIN"", ""AUTHOR"", ""USER"")
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginPage(""/authentication/login"").permitAll()
                .defaultSuccessUrl(""/post/blog"")
                .and()
                .logout().invalidateHttpSession(true)
                .clearAuthentication(true)
                .logoutRequestMatcher(new AntPathRequestMatcher(""/logout""))
                .logoutSuccessUrl(""/authentication/logout-success"").permitAll();
    }
}","                .antMatchers(""/post/newPost"", ""/post/publish"", ""/post/update"", ""/post/delete"").hasAnyAuthority(""ADMIN"", ""AUTHOR"")",StackOverflow
CloseResource,Ensure that resources like this ResultSet object are closed after use,"@Factory
public class JdbiFactory {
    @Inject
    DataSource dataSource;
    private static final Logger LOG = LoggerFactory.getLogger(JdbiFactory.class);

    @Bean
    @Singleton
    public Jdbi jdbi(ResourceResolver resourceResolver) {
        return Jdbi.create(dataSource)
            .installPlugin(new SqlObjectPlugin())
            .setSqlLogger(new SqlLogger() {
            @Override
            public void logAfterExecution(StatementContext context) {
                try {
                    var rSql = context.getRenderedSql();
                    LOG.debug(""RenderedSql: [{}] "", rSql);
                    if (rSql.contains(""CALL "")) {
                        // get warnings
                        final var warningSt = context.getStatement().getWarnings();
                        logThrowables(warningSt);
                        context.getStatement().clearWarnings();
                        // get warnings on results
                        do {
                            ResultSet resultSet = context.getStatement().getResultSet();
                            if (resultSet != null) {
                                final var warningRs = resultSet.getWarnings();
                                logThrowables(warningRs);
                                resultSet.clearWarnings();
                            }
                        } while ( context.getStatement().getMoreResults());
                    }
                } catch (SQLException e) {
                    LOG.error(""Inside logAfterExecution error "", e);
                    e.printStackTrace();
                }
                SqlLogger.super.logAfterExecution(context);
            }
        });
    }

    private static void logThrowables(SQLException warning) {
        var iterator = warning.iterator();
        do {
            Throwable next = iterator.next();
            LOG.info(""Print: [{}]"", next.getMessage());
        }while(iterator.hasNext());

    }
}",                            ResultSet resultSet = context.getStatement().getResultSet();,StackOverflow
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","public class Test {

    static int i = 0;
    static long[] measurements = new long[0x100];
    
    static void report(long value) {
        measurements[i++ & 0xff] = value;
        if (i > 10_000) {
            for (long m : measurements) {
                System.out.println(m);
            }
            System.exit(0);
        }
    }
    
    static void sleepyWait() throws Exception {
        while (true) {
            long before = System.nanoTime();
            Thread.sleep(1);
            long now = System.nanoTime();
            report(now - before);
        }                   
    }
    
    static void busyWait() {
        while (true) {
            long before = System.nanoTime();
            long now;
            do {
                now = System.nanoTime();
            } while (before + 1_000_000 >= now);
            report(now - before);
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        busyWait();
    }
}",public class Test {,StackOverflow
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class Test {

    static int i = 0;
    static long[] measurements = new long[0x100];
    
    static void report(long value) {
        measurements[i++ & 0xff] = value;
        if (i > 10_000) {
            for (long m : measurements) {
                System.out.println(m);
            }
            System.exit(0);
        }
    }
    
    static void sleepyWait() throws Exception {
        while (true) {
            long before = System.nanoTime();
            Thread.sleep(1);
            long now = System.nanoTime();
            report(now - before);
        }                   
    }
    
    static void busyWait() {
        while (true) {
            long before = System.nanoTime();
            long now;
            do {
                now = System.nanoTime();
            } while (before + 1_000_000 >= now);
            report(now - before);
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        busyWait();
    }
}",        if (i > 10_000) {,StackOverflow
DoNotTerminateVM,System.exit() should not be used in J2EE/JEE apps,"public class Test {

    static int i = 0;
    static long[] measurements = new long[0x100];
    
    static void report(long value) {
        measurements[i++ & 0xff] = value;
        if (i > 10_000) {
            for (long m : measurements) {
                System.out.println(m);
            }
            System.exit(0);
        }
    }
    
    static void sleepyWait() throws Exception {
        while (true) {
            long before = System.nanoTime();
            Thread.sleep(1);
            long now = System.nanoTime();
            report(now - before);
        }                   
    }
    
    static void busyWait() {
        while (true) {
            long before = System.nanoTime();
            long now;
            do {
                now = System.nanoTime();
            } while (before + 1_000_000 >= now);
            report(now - before);
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        busyWait();
    }
}",            System.exit(0);,StackOverflow
TestClassWithoutTestCases,"The class 'SchemaCrawlerTest' might be a test class, but it contains no test cases.","@DBTest
class SchemaCrawlerTest extends IntegrationSuite {
    @Test
    @SneakyThrows
    void schemaSpy() {
        // The @Cleanup is lombok annotation that generates try with resources
        @Cleanup final var schemaSpy =
            new GenericContainer<>(DockerImageName.parse(""schemaspy/schemaspy:6.1.0""))
                .withNetworkAliases(""schemaspy"")
                .withNetwork(NETWORK)
                .withLogConsumer(new Slf4jLogConsumer(LoggerFactory.getLogger(""SchemaSpy"")))
                .withCreateContainerCmdModifier(cmd -> cmd.withEntrypoint(""""))
                .withCommand(""sleep 500000"");

        schemaSpy.start();
        final var generateDocCommand = schemaSpy.execInContainer(
            ""java"",
            ""-jar"", ""/schemaspy-6.1.0.jar"",
            ""-t"", ""pgsql11"",
            ""-db"", POSTGRES.getDatabaseName(),
            ""-host"", ""postgres"",
            ""-u"", POSTGRES.getUsername(),
            ""-p"", POSTGRES.getPassword(),
            ""-o"", ""/output"",
            ""-dp"", ""/drivers_inc"",
            ""-debug""
        );
        if (generateDocCommand.getExitCode() != 0) {
            fail(""Output: %s, error: %s"".formatted(generateDocCommand.getStdout(), generateDocCommand.getStderr()));
        }
        schemaSpy.execInContainer(""tar"", ""-czvf"", ""/output/output.tar.gz"", ""/output"");
        schemaSpy.copyFileFromContainer(
            ""/output/output.tar.gz"",
            Path.of(getClass().getResource(""/"").getPath(), ""output.tar.gz"")
                .toAbsolutePath()
                .toString()
        );
        schemaSpy.stop();
    }
}

@Testcontainers
public class IntegrationSuite {
    protected static final Network NETWORK = Network.newNetwork();

    @Container
    protected static final PostgreSQLContainer<?> POSTGRES =
        new PostgreSQLContainer<>(DockerImageName.parse(""postgres:13.5""))
            .withNetworkAliases(""postgres"")
            .withNetwork(NETWORK);

    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add(""spring.datasource.url"", POSTGRES::getJdbcUrl);
        registry.add(""spring.datasource.username"", POSTGRES::getUsername);
        registry.add(""spring.datasource.password"", POSTGRES::getPassword);
    }
}",class SchemaCrawlerTest extends IntegrationSuite {,StackOverflow
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import javax.swing.*;
import java.awt.*;
import java.awt.geom.*;

class ShadowPanel extends JPanel {

    private static final int SHADOW_SIZE = 5; // Adjust shadow size as needed

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        // Draw rounded rectangle with white background
        Graphics2D g2d = (Graphics2D) g.create();
        g2d.setColor(Color.WHITE);
        g2d.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, 10, 10);
        g2d.dispose();

        // Draw box shadow
        Graphics2D shadowGraphics = (Graphics2D) g.create();
        shadowGraphics.setColor(new Color(0, 0, 0, 50)); // Adjust shadow opacity as needed
        shadowGraphics.fillRect(SHADOW_SIZE, getHeight() - SHADOW_SIZE, getWidth() - SHADOW_SIZE * 2, SHADOW_SIZE);
        shadowGraphics.fillRect(getWidth() - SHADOW_SIZE, SHADOW_SIZE, SHADOW_SIZE, getHeight() - SHADOW_SIZE * 2);
        shadowGraphics.dispose();
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(200, 200); // Adjust preferred size as needed
    }
}

public class Main {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""ShadowPanel Example"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLayout(new BorderLayout());

            JPanel contentPane = new JPanel(new FlowLayout(FlowLayout.CENTER, 20, 20));
            contentPane.setBackground(Color.LIGHT_GRAY);
            frame.setContentPane(contentPane);

            // Create and add ShadowPanel to the content pane
            ShadowPanel panel = new ShadowPanel();
            panel.setPreferredSize(new Dimension(150, 150));
            contentPane.add(panel);

            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }
}",class ShadowPanel extends JPanel {,ChatGPT
TestClassWithoutTestCases,"The class 'TestRowFactory' might be a test class, but it contains no test cases.","import javafx.application.Platform;
import javafx.css.PseudoClass;
import javafx.scene.control.TableRow;
import javafx.scene.control.Tooltip;
import javafx.scene.control.TableView;
import javafx.util.Callback;

public class TestRowFactory implements Callback<TableView<TestEntity>, TableRow<TestEntity>> {
    private final PseudoClass INVALID_PCLASS = PseudoClass.getPseudoClass(""invalid"");

    @Override
    public TableRow<TestEntity> call(TableView<TestEntity> param) {
        TableRow<TestEntity> row = new TableRow<>();

        Thread validationThread = new Thread(() -> {
            try {
                if (row.getItem() != null) {
                    Thread.sleep(500); // Perform validation and stuff...
                    boolean isValid = row.getItem().getC() % 2 == 0;
                    Platform.runLater(() -> {
                        if (isValid) {
                            Tooltip t = new Tooltip(""I am a new tooltip that should be shown only on red rows"");
                            row.setTooltip(t);
                            row.pseudoClassStateChanged(INVALID_PCLASS, true);
                        } else {
                            row.setTooltip(null);
                            row.pseudoClassStateChanged(INVALID_PCLASS, false);
                        }
                    });
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        row.itemProperty().addListener((observable, oldValue, newValue) -> {
            if (oldValue != null) {
                oldValue.firstNameProperty().removeListener(changeListener);
            }

            if (newValue != null) {
                newValue.firstNameProperty().removeListener(changeListener);
                AppThreadPool.perform(validationThread);
            } else {
                row.pseudoClassStateChanged(INVALID_PCLASS, false);
                row.setTooltip(null);
            }
        });

        row.focusedProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal) {
                AppThreadPool.perform(validationThread);
            }
        });

        return row;
    }
}","public class TestRowFactory implements Callback<TableView<TestEntity>, TableRow<TestEntity>> {",ChatGPT
AvoidFieldNameMatchingTypeName,It is somewhat confusing to have a field name matching the declaring class name,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(10);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            InputStream input = client.getInputStream();
            OutputStream output = client.getOutputStream();
            DataInputStream dataInput = new DataInputStream(input);
            DataOutputStream dataOutput = new DataOutputStream(output);

            int op = dataInput.readInt();

            int num1 = dataInput.readInt();
            int num2 = dataInput.readInt();
            int num3 = dataInput.readInt();

            switch (op) {
                case 0:
                    dataOutput.writeInt(num1 + num2 + num3);
                    break;
                case 1:
                    dataOutput.writeInt(num1 - num2 - num3);
                    break;
                case 2:
                    dataOutput.writeInt(num1 * num2 * num3);
                    break;
            }

            dataOutput.flush();
            dataOutput.close();
            dataInput.close();
            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",    ServerSocket server = new ServerSocket(10);,ChatGPT
CloseResource,Ensure that resources like this Socket object are closed after use,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(10);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            InputStream input = client.getInputStream();
            OutputStream output = client.getOutputStream();
            DataInputStream dataInput = new DataInputStream(input);
            DataOutputStream dataOutput = new DataOutputStream(output);

            int op = dataInput.readInt();

            int num1 = dataInput.readInt();
            int num2 = dataInput.readInt();
            int num3 = dataInput.readInt();

            switch (op) {
                case 0:
                    dataOutput.writeInt(num1 + num2 + num3);
                    break;
                case 1:
                    dataOutput.writeInt(num1 - num2 - num3);
                    break;
                case 2:
                    dataOutput.writeInt(num1 * num2 * num3);
                    break;
            }

            dataOutput.flush();
            dataOutput.close();
            dataInput.close();
            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            Socket client = server.accept();,ChatGPT
CloseResource,Ensure that resources like this InputStream object are closed after use,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(10);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            InputStream input = client.getInputStream();
            OutputStream output = client.getOutputStream();
            DataInputStream dataInput = new DataInputStream(input);
            DataOutputStream dataOutput = new DataOutputStream(output);

            int op = dataInput.readInt();

            int num1 = dataInput.readInt();
            int num2 = dataInput.readInt();
            int num3 = dataInput.readInt();

            switch (op) {
                case 0:
                    dataOutput.writeInt(num1 + num2 + num3);
                    break;
                case 1:
                    dataOutput.writeInt(num1 - num2 - num3);
                    break;
                case 2:
                    dataOutput.writeInt(num1 * num2 * num3);
                    break;
            }

            dataOutput.flush();
            dataOutput.close();
            dataInput.close();
            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            InputStream input = client.getInputStream();,ChatGPT
CloseResource,Ensure that resources like this OutputStream object are closed after use,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(10);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            InputStream input = client.getInputStream();
            OutputStream output = client.getOutputStream();
            DataInputStream dataInput = new DataInputStream(input);
            DataOutputStream dataOutput = new DataOutputStream(output);

            int op = dataInput.readInt();

            int num1 = dataInput.readInt();
            int num2 = dataInput.readInt();
            int num3 = dataInput.readInt();

            switch (op) {
                case 0:
                    dataOutput.writeInt(num1 + num2 + num3);
                    break;
                case 1:
                    dataOutput.writeInt(num1 - num2 - num3);
                    break;
                case 2:
                    dataOutput.writeInt(num1 * num2 * num3);
                    break;
            }

            dataOutput.flush();
            dataOutput.close();
            dataInput.close();
            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            OutputStream output = client.getOutputStream();,ChatGPT
CloseResource,Ensure that resources like this DataInputStream object are closed after use,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(10);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            InputStream input = client.getInputStream();
            OutputStream output = client.getOutputStream();
            DataInputStream dataInput = new DataInputStream(input);
            DataOutputStream dataOutput = new DataOutputStream(output);

            int op = dataInput.readInt();

            int num1 = dataInput.readInt();
            int num2 = dataInput.readInt();
            int num3 = dataInput.readInt();

            switch (op) {
                case 0:
                    dataOutput.writeInt(num1 + num2 + num3);
                    break;
                case 1:
                    dataOutput.writeInt(num1 - num2 - num3);
                    break;
                case 2:
                    dataOutput.writeInt(num1 * num2 * num3);
                    break;
            }

            dataOutput.flush();
            dataOutput.close();
            dataInput.close();
            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            DataInputStream dataInput = new DataInputStream(input);,ChatGPT
CloseResource,Ensure that resources like this DataOutputStream object are closed after use,"import java.net.*;
import java.io.*;

public class Server {

    ServerSocket server = new ServerSocket(10);

    Server() throws IOException {
        while (true) {
            Socket client = server.accept();
            InputStream input = client.getInputStream();
            OutputStream output = client.getOutputStream();
            DataInputStream dataInput = new DataInputStream(input);
            DataOutputStream dataOutput = new DataOutputStream(output);

            int op = dataInput.readInt();

            int num1 = dataInput.readInt();
            int num2 = dataInput.readInt();
            int num3 = dataInput.readInt();

            switch (op) {
                case 0:
                    dataOutput.writeInt(num1 + num2 + num3);
                    break;
                case 1:
                    dataOutput.writeInt(num1 - num2 - num3);
                    break;
                case 2:
                    dataOutput.writeInt(num1 * num2 * num3);
                    break;
            }

            dataOutput.flush();
            dataOutput.close();
            dataInput.close();
            input.close();
            output.close();
            client.close();
        }
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            DataOutputStream dataOutput = new DataOutputStream(output);,ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;

public class CustomButton extends JButton {

    private boolean appearPressed;

    public CustomButton(String text) {
        super(text);
        setOpaque(false);
        setContentAreaFilled(false);
        setBorderPainted(false);
    }

    public void setAppearPressed(boolean appearPressed) {
        this.appearPressed = appearPressed;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        if (getModel().isPressed() || appearPressed) {
            g.setColor(UIManager.getColor(""Button.shadow""));
        } else {
            g.setColor(getBackground());
        }
        g.fillRect(0, 0, getWidth(), getHeight());
        super.paintComponent(g);
    }

    @Override
    public void paintBorder(Graphics g) {
        if (getModel().isPressed() || appearPressed) {
            g.setColor(UIManager.getColor(""Button.darkShadow""));
        } else {
            g.setColor(getBackground());
        }
        g.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""Custom Button Example"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            JPanel panel = new JPanel();
            CustomButton button = new CustomButton(""Press Me"");
            panel.add(button);
            button.addActionListener(e -> button.setAppearPressed(!button.appearPressed));
            frame.add(panel);
            frame.pack();
            frame.setVisible(true);
        });
    }
}",public class CustomButton extends JButton {,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JComponent.setOpaque(boolean) ,"import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;

public class CustomButton extends JButton {

    private boolean appearPressed;

    public CustomButton(String text) {
        super(text);
        setOpaque(false);
        setContentAreaFilled(false);
        setBorderPainted(false);
    }

    public void setAppearPressed(boolean appearPressed) {
        this.appearPressed = appearPressed;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        if (getModel().isPressed() || appearPressed) {
            g.setColor(UIManager.getColor(""Button.shadow""));
        } else {
            g.setColor(getBackground());
        }
        g.fillRect(0, 0, getWidth(), getHeight());
        super.paintComponent(g);
    }

    @Override
    public void paintBorder(Graphics g) {
        if (getModel().isPressed() || appearPressed) {
            g.setColor(UIManager.getColor(""Button.darkShadow""));
        } else {
            g.setColor(getBackground());
        }
        g.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""Custom Button Example"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            JPanel panel = new JPanel();
            CustomButton button = new CustomButton(""Press Me"");
            panel.add(button);
            button.addActionListener(e -> button.setAppearPressed(!button.appearPressed));
            frame.add(panel);
            frame.pack();
            frame.setVisible(true);
        });
    }
}",        setOpaque(false);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: AbstractButton.setContentAreaFilled(boolean) ,"import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;

public class CustomButton extends JButton {

    private boolean appearPressed;

    public CustomButton(String text) {
        super(text);
        setOpaque(false);
        setContentAreaFilled(false);
        setBorderPainted(false);
    }

    public void setAppearPressed(boolean appearPressed) {
        this.appearPressed = appearPressed;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        if (getModel().isPressed() || appearPressed) {
            g.setColor(UIManager.getColor(""Button.shadow""));
        } else {
            g.setColor(getBackground());
        }
        g.fillRect(0, 0, getWidth(), getHeight());
        super.paintComponent(g);
    }

    @Override
    public void paintBorder(Graphics g) {
        if (getModel().isPressed() || appearPressed) {
            g.setColor(UIManager.getColor(""Button.darkShadow""));
        } else {
            g.setColor(getBackground());
        }
        g.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""Custom Button Example"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            JPanel panel = new JPanel();
            CustomButton button = new CustomButton(""Press Me"");
            panel.add(button);
            button.addActionListener(e -> button.setAppearPressed(!button.appearPressed));
            frame.add(panel);
            frame.pack();
            frame.setVisible(true);
        });
    }
}",        setContentAreaFilled(false);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: AbstractButton.setBorderPainted(boolean) ,"import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;

public class CustomButton extends JButton {

    private boolean appearPressed;

    public CustomButton(String text) {
        super(text);
        setOpaque(false);
        setContentAreaFilled(false);
        setBorderPainted(false);
    }

    public void setAppearPressed(boolean appearPressed) {
        this.appearPressed = appearPressed;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        if (getModel().isPressed() || appearPressed) {
            g.setColor(UIManager.getColor(""Button.shadow""));
        } else {
            g.setColor(getBackground());
        }
        g.fillRect(0, 0, getWidth(), getHeight());
        super.paintComponent(g);
    }

    @Override
    public void paintBorder(Graphics g) {
        if (getModel().isPressed() || appearPressed) {
            g.setColor(UIManager.getColor(""Button.darkShadow""));
        } else {
            g.setColor(getBackground());
        }
        g.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame(""Custom Button Example"");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            JPanel panel = new JPanel();
            CustomButton button = new CustomButton(""Press Me"");
            panel.add(button);
            button.addActionListener(e -> button.setAppearPressed(!button.appearPressed));
            frame.add(panel);
            frame.pack();
            frame.setVisible(true);
        });
    }
}",        setBorderPainted(false);,ChatGPT
TestClassWithoutTestCases,"The class 'PredefinedAspectTest' might be a test class, but it contains no test cases.","import static org.mockito.Mockito.verify;

@RunWith(SpringRunner.class)
@SpringBootTest
public class PredefinedAspectTest {

    @Autowired
    private ActionService actionService;

    @Autowired
    private PredefinedAspect predefinedAspect;

    @Test
    public void testPredefinedAspect() {
        // Call the method annotated with @PredefinedCheck
        actionService.updateMyEntity(new AuthenticationJwtToken(), new EntityUpdateRequest());

        // Verify that the aspect's check method was called
        verify(predefinedAspect).check(any(JoinPoint.class));
    }
}",public class PredefinedAspectTest {,ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawFigure extends JPanel {
    int type;
    int length, width, height, radius;

    public DrawFigure() {
        super();
        type = 5;
    }

    public DrawFigure(int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int x, int y, int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int myType, int myRadius, int myHeight) {
        super();
        type = myType;
        radius = myRadius;
        height = myHeight;
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (type == 1) { // Draw Rectangle

        } else if (type == 2) { // Draw Box

        } else if (type == 3) { // Draw Circle

        } else if (type == 4) { // Draw Cylinder
            int centerX = getWidth() / 2; // Center of the panel
            int centerY = getHeight() / 2;

            // Draw the sides of the cylinder
            g.setColor(Color.BLACK);
            g.drawLine(centerX, centerY, centerX, centerY + height);
            g.drawLine(centerX + radius, centerY, centerX + radius, centerY + height);

            // Draw the top and bottom circles
            int topY = centerY - height / 2;
            int bottomY = centerY + height / 2;

            g.setColor(Color.RED); // Base color
            g.fillOval(centerX, bottomY, radius, radius / 2); // Bottom circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, bottomY, radius, radius / 2); // Outline for bottom circle

            g.setColor(Color.WHITE); // Cylinder side color
            g.fillOval(centerX, topY, radius, radius / 2); // Top circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, topY, radius, radius / 2); // Outline for top circle
        }
    }
}",public class DrawFigure extends JPanel {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawFigure extends JPanel {
    int type;
    int length, width, height, radius;

    public DrawFigure() {
        super();
        type = 5;
    }

    public DrawFigure(int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int x, int y, int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int myType, int myRadius, int myHeight) {
        super();
        type = myType;
        radius = myRadius;
        height = myHeight;
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (type == 1) { // Draw Rectangle

        } else if (type == 2) { // Draw Box

        } else if (type == 3) { // Draw Circle

        } else if (type == 4) { // Draw Cylinder
            int centerX = getWidth() / 2; // Center of the panel
            int centerY = getHeight() / 2;

            // Draw the sides of the cylinder
            g.setColor(Color.BLACK);
            g.drawLine(centerX, centerY, centerX, centerY + height);
            g.drawLine(centerX + radius, centerY, centerX + radius, centerY + height);

            // Draw the top and bottom circles
            int topY = centerY - height / 2;
            int bottomY = centerY + height / 2;

            g.setColor(Color.RED); // Base color
            g.fillOval(centerX, bottomY, radius, radius / 2); // Bottom circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, bottomY, radius, radius / 2); // Outline for bottom circle

            g.setColor(Color.WHITE); // Cylinder side color
            g.fillOval(centerX, topY, radius, radius / 2); // Top circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, topY, radius, radius / 2); // Outline for top circle
        }
    }
}",        if (type == 1) { // Draw Rectangle,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawFigure extends JPanel {
    int type;
    int length, width, height, radius;

    public DrawFigure() {
        super();
        type = 5;
    }

    public DrawFigure(int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int x, int y, int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int myType, int myRadius, int myHeight) {
        super();
        type = myType;
        radius = myRadius;
        height = myHeight;
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (type == 1) { // Draw Rectangle

        } else if (type == 2) { // Draw Box

        } else if (type == 3) { // Draw Circle

        } else if (type == 4) { // Draw Cylinder
            int centerX = getWidth() / 2; // Center of the panel
            int centerY = getHeight() / 2;

            // Draw the sides of the cylinder
            g.setColor(Color.BLACK);
            g.drawLine(centerX, centerY, centerX, centerY + height);
            g.drawLine(centerX + radius, centerY, centerX + radius, centerY + height);

            // Draw the top and bottom circles
            int topY = centerY - height / 2;
            int bottomY = centerY + height / 2;

            g.setColor(Color.RED); // Base color
            g.fillOval(centerX, bottomY, radius, radius / 2); // Bottom circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, bottomY, radius, radius / 2); // Outline for bottom circle

            g.setColor(Color.WHITE); // Cylinder side color
            g.fillOval(centerX, topY, radius, radius / 2); // Top circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, topY, radius, radius / 2); // Outline for top circle
        }
    }
}",        } else if (type == 2) { // Draw Box,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawFigure extends JPanel {
    int type;
    int length, width, height, radius;

    public DrawFigure() {
        super();
        type = 5;
    }

    public DrawFigure(int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int x, int y, int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int myType, int myRadius, int myHeight) {
        super();
        type = myType;
        radius = myRadius;
        height = myHeight;
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (type == 1) { // Draw Rectangle

        } else if (type == 2) { // Draw Box

        } else if (type == 3) { // Draw Circle

        } else if (type == 4) { // Draw Cylinder
            int centerX = getWidth() / 2; // Center of the panel
            int centerY = getHeight() / 2;

            // Draw the sides of the cylinder
            g.setColor(Color.BLACK);
            g.drawLine(centerX, centerY, centerX, centerY + height);
            g.drawLine(centerX + radius, centerY, centerX + radius, centerY + height);

            // Draw the top and bottom circles
            int topY = centerY - height / 2;
            int bottomY = centerY + height / 2;

            g.setColor(Color.RED); // Base color
            g.fillOval(centerX, bottomY, radius, radius / 2); // Bottom circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, bottomY, radius, radius / 2); // Outline for bottom circle

            g.setColor(Color.WHITE); // Cylinder side color
            g.fillOval(centerX, topY, radius, radius / 2); // Top circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, topY, radius, radius / 2); // Outline for top circle
        }
    }
}",        } else if (type == 3) { // Draw Circle,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawFigure extends JPanel {
    int type;
    int length, width, height, radius;

    public DrawFigure() {
        super();
        type = 5;
    }

    public DrawFigure(int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int x, int y, int myType, int myWidth, int myLength, int myHeight) {
        super();
        type = myType;
        length = myLength;
        width = myWidth;
        height = myHeight;
    }

    public DrawFigure(int myType, int myRadius, int myHeight) {
        super();
        type = myType;
        radius = myRadius;
        height = myHeight;
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (type == 1) { // Draw Rectangle

        } else if (type == 2) { // Draw Box

        } else if (type == 3) { // Draw Circle

        } else if (type == 4) { // Draw Cylinder
            int centerX = getWidth() / 2; // Center of the panel
            int centerY = getHeight() / 2;

            // Draw the sides of the cylinder
            g.setColor(Color.BLACK);
            g.drawLine(centerX, centerY, centerX, centerY + height);
            g.drawLine(centerX + radius, centerY, centerX + radius, centerY + height);

            // Draw the top and bottom circles
            int topY = centerY - height / 2;
            int bottomY = centerY + height / 2;

            g.setColor(Color.RED); // Base color
            g.fillOval(centerX, bottomY, radius, radius / 2); // Bottom circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, bottomY, radius, radius / 2); // Outline for bottom circle

            g.setColor(Color.WHITE); // Cylinder side color
            g.fillOval(centerX, topY, radius, radius / 2); // Top circle

            g.setColor(Color.BLACK);
            g.drawOval(centerX, topY, radius, radius / 2); // Outline for top circle
        }
    }
}",        } else if (type == 4) { // Draw Cylinder,ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;

public class IT extends JPanel implements ActionListener, KeyListener {

    Timer shapeTimer = new Timer(5, this);

    public double xPosBigRect = 0, yPosBigRect = 0, movementXBigRect = 0, movementYBigRect = 0;
    public double xPosSmallRect = 100, yPosSmallRect = 100, movementXSmallRect = 0, movementYSmallRect = 0;

    public int rectSize = 50;
    public int rectSize2 = 35;

    public int windowWidth;
    int windowHeight;

    public int xBound;
    public int yBound;

    public IT(int w, int h) {
        shapeTimer.start();

        addKeyListener(this);
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);

        windowWidth = w;
        windowHeight = h;

        xBound = (windowWidth - rectSize);
        yBound = (windowHeight - rectSize);
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        Rectangle2D bigRect = new Rectangle2D.Double(xPosBigRect, yPosBigRect, rectSize, rectSize);
        g2.setColor(Color.BLUE);
        g2.draw(bigRect);
        g2.fill(bigRect);

        Rectangle2D smallRect = new Rectangle2D.Double(xPosSmallRect, yPosSmallRect, rectSize2, rectSize2);
        g2.setColor(Color.RED);
        g2.draw(smallRect);
        g2.fill(smallRect);
    }

    public void actionPerformed(ActionEvent e) {
        repaint();

        // Calculate distance between the centers of the two rectangles
        double distance = Math.sqrt(Math.pow(xPosBigRect - xPosSmallRect, 2) + Math.pow(yPosBigRect - yPosSmallRect, 2));

        // If distance is less than a certain threshold, move the small rectangle away
        if (distance < 100) {
            double angle = Math.atan2(yPosBigRect - yPosSmallRect, xPosBigRect - xPosSmallRect);
            movementXSmallRect = Math.cos(angle) * -1;
            movementYSmallRect = Math.sin(angle) * -1;
        } else {
            movementXSmallRect = 0;
            movementYSmallRect = 0;
        }

        xPosBigRect += movementXBigRect;
        yPosBigRect += movementYBigRect;
        xPosSmallRect += movementXSmallRect;
        yPosSmallRect += movementYSmallRect;
    }

    public void moveUp() {
        if (yPosBigRect == 0) {
            movementYBigRect = 0;
            movementXBigRect = 0;
        }
        movementYBigRect = -0.5;
        movementXBigRect = 0;
    }

    // Implement other move methods similarly

    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();
        // Handle key presses for moving the big rectangle
    }

    // Implement other KeyListener methods similarly
}","public class IT extends JPanel implements ActionListener, KeyListener {",ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Component.addKeyListener(KeyListener) ,"import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;

public class IT extends JPanel implements ActionListener, KeyListener {

    Timer shapeTimer = new Timer(5, this);

    public double xPosBigRect = 0, yPosBigRect = 0, movementXBigRect = 0, movementYBigRect = 0;
    public double xPosSmallRect = 100, yPosSmallRect = 100, movementXSmallRect = 0, movementYSmallRect = 0;

    public int rectSize = 50;
    public int rectSize2 = 35;

    public int windowWidth;
    int windowHeight;

    public int xBound;
    public int yBound;

    public IT(int w, int h) {
        shapeTimer.start();

        addKeyListener(this);
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);

        windowWidth = w;
        windowHeight = h;

        xBound = (windowWidth - rectSize);
        yBound = (windowHeight - rectSize);
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        Rectangle2D bigRect = new Rectangle2D.Double(xPosBigRect, yPosBigRect, rectSize, rectSize);
        g2.setColor(Color.BLUE);
        g2.draw(bigRect);
        g2.fill(bigRect);

        Rectangle2D smallRect = new Rectangle2D.Double(xPosSmallRect, yPosSmallRect, rectSize2, rectSize2);
        g2.setColor(Color.RED);
        g2.draw(smallRect);
        g2.fill(smallRect);
    }

    public void actionPerformed(ActionEvent e) {
        repaint();

        // Calculate distance between the centers of the two rectangles
        double distance = Math.sqrt(Math.pow(xPosBigRect - xPosSmallRect, 2) + Math.pow(yPosBigRect - yPosSmallRect, 2));

        // If distance is less than a certain threshold, move the small rectangle away
        if (distance < 100) {
            double angle = Math.atan2(yPosBigRect - yPosSmallRect, xPosBigRect - xPosSmallRect);
            movementXSmallRect = Math.cos(angle) * -1;
            movementYSmallRect = Math.sin(angle) * -1;
        } else {
            movementXSmallRect = 0;
            movementYSmallRect = 0;
        }

        xPosBigRect += movementXBigRect;
        yPosBigRect += movementYBigRect;
        xPosSmallRect += movementXSmallRect;
        yPosSmallRect += movementYSmallRect;
    }

    public void moveUp() {
        if (yPosBigRect == 0) {
            movementYBigRect = 0;
            movementXBigRect = 0;
        }
        movementYBigRect = -0.5;
        movementXBigRect = 0;
    }

    // Implement other move methods similarly

    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();
        // Handle key presses for moving the big rectangle
    }

    // Implement other KeyListener methods similarly
}",        addKeyListener(this);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Component.setFocusable(boolean) ,"import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;

public class IT extends JPanel implements ActionListener, KeyListener {

    Timer shapeTimer = new Timer(5, this);

    public double xPosBigRect = 0, yPosBigRect = 0, movementXBigRect = 0, movementYBigRect = 0;
    public double xPosSmallRect = 100, yPosSmallRect = 100, movementXSmallRect = 0, movementYSmallRect = 0;

    public int rectSize = 50;
    public int rectSize2 = 35;

    public int windowWidth;
    int windowHeight;

    public int xBound;
    public int yBound;

    public IT(int w, int h) {
        shapeTimer.start();

        addKeyListener(this);
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);

        windowWidth = w;
        windowHeight = h;

        xBound = (windowWidth - rectSize);
        yBound = (windowHeight - rectSize);
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        Rectangle2D bigRect = new Rectangle2D.Double(xPosBigRect, yPosBigRect, rectSize, rectSize);
        g2.setColor(Color.BLUE);
        g2.draw(bigRect);
        g2.fill(bigRect);

        Rectangle2D smallRect = new Rectangle2D.Double(xPosSmallRect, yPosSmallRect, rectSize2, rectSize2);
        g2.setColor(Color.RED);
        g2.draw(smallRect);
        g2.fill(smallRect);
    }

    public void actionPerformed(ActionEvent e) {
        repaint();

        // Calculate distance between the centers of the two rectangles
        double distance = Math.sqrt(Math.pow(xPosBigRect - xPosSmallRect, 2) + Math.pow(yPosBigRect - yPosSmallRect, 2));

        // If distance is less than a certain threshold, move the small rectangle away
        if (distance < 100) {
            double angle = Math.atan2(yPosBigRect - yPosSmallRect, xPosBigRect - xPosSmallRect);
            movementXSmallRect = Math.cos(angle) * -1;
            movementYSmallRect = Math.sin(angle) * -1;
        } else {
            movementXSmallRect = 0;
            movementYSmallRect = 0;
        }

        xPosBigRect += movementXBigRect;
        yPosBigRect += movementYBigRect;
        xPosSmallRect += movementXSmallRect;
        yPosSmallRect += movementYSmallRect;
    }

    public void moveUp() {
        if (yPosBigRect == 0) {
            movementYBigRect = 0;
            movementXBigRect = 0;
        }
        movementYBigRect = -0.5;
        movementXBigRect = 0;
    }

    // Implement other move methods similarly

    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();
        // Handle key presses for moving the big rectangle
    }

    // Implement other KeyListener methods similarly
}",        setFocusable(true);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Component.setFocusTraversalKeysEnabled(boolean) ,"import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;

public class IT extends JPanel implements ActionListener, KeyListener {

    Timer shapeTimer = new Timer(5, this);

    public double xPosBigRect = 0, yPosBigRect = 0, movementXBigRect = 0, movementYBigRect = 0;
    public double xPosSmallRect = 100, yPosSmallRect = 100, movementXSmallRect = 0, movementYSmallRect = 0;

    public int rectSize = 50;
    public int rectSize2 = 35;

    public int windowWidth;
    int windowHeight;

    public int xBound;
    public int yBound;

    public IT(int w, int h) {
        shapeTimer.start();

        addKeyListener(this);
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);

        windowWidth = w;
        windowHeight = h;

        xBound = (windowWidth - rectSize);
        yBound = (windowHeight - rectSize);
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        Rectangle2D bigRect = new Rectangle2D.Double(xPosBigRect, yPosBigRect, rectSize, rectSize);
        g2.setColor(Color.BLUE);
        g2.draw(bigRect);
        g2.fill(bigRect);

        Rectangle2D smallRect = new Rectangle2D.Double(xPosSmallRect, yPosSmallRect, rectSize2, rectSize2);
        g2.setColor(Color.RED);
        g2.draw(smallRect);
        g2.fill(smallRect);
    }

    public void actionPerformed(ActionEvent e) {
        repaint();

        // Calculate distance between the centers of the two rectangles
        double distance = Math.sqrt(Math.pow(xPosBigRect - xPosSmallRect, 2) + Math.pow(yPosBigRect - yPosSmallRect, 2));

        // If distance is less than a certain threshold, move the small rectangle away
        if (distance < 100) {
            double angle = Math.atan2(yPosBigRect - yPosSmallRect, xPosBigRect - xPosSmallRect);
            movementXSmallRect = Math.cos(angle) * -1;
            movementYSmallRect = Math.sin(angle) * -1;
        } else {
            movementXSmallRect = 0;
            movementYSmallRect = 0;
        }

        xPosBigRect += movementXBigRect;
        yPosBigRect += movementYBigRect;
        xPosSmallRect += movementXSmallRect;
        yPosSmallRect += movementYSmallRect;
    }

    public void moveUp() {
        if (yPosBigRect == 0) {
            movementYBigRect = 0;
            movementXBigRect = 0;
        }
        movementYBigRect = -0.5;
        movementXBigRect = 0;
    }

    // Implement other move methods similarly

    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();
        // Handle key presses for moving the big rectangle
    }

    // Implement other KeyListener methods similarly
}",        setFocusTraversalKeysEnabled(false);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;

public class IT extends JPanel implements ActionListener, KeyListener {

    Timer shapeTimer = new Timer(5, this);

    public double xPosBigRect = 0, yPosBigRect = 0, movementXBigRect = 0, movementYBigRect = 0;
    public double xPosSmallRect = 100, yPosSmallRect = 100, movementXSmallRect = 0, movementYSmallRect = 0;

    public int rectSize = 50;
    public int rectSize2 = 35;

    public int windowWidth;
    int windowHeight;

    public int xBound;
    public int yBound;

    public IT(int w, int h) {
        shapeTimer.start();

        addKeyListener(this);
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);

        windowWidth = w;
        windowHeight = h;

        xBound = (windowWidth - rectSize);
        yBound = (windowHeight - rectSize);
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        Rectangle2D bigRect = new Rectangle2D.Double(xPosBigRect, yPosBigRect, rectSize, rectSize);
        g2.setColor(Color.BLUE);
        g2.draw(bigRect);
        g2.fill(bigRect);

        Rectangle2D smallRect = new Rectangle2D.Double(xPosSmallRect, yPosSmallRect, rectSize2, rectSize2);
        g2.setColor(Color.RED);
        g2.draw(smallRect);
        g2.fill(smallRect);
    }

    public void actionPerformed(ActionEvent e) {
        repaint();

        // Calculate distance between the centers of the two rectangles
        double distance = Math.sqrt(Math.pow(xPosBigRect - xPosSmallRect, 2) + Math.pow(yPosBigRect - yPosSmallRect, 2));

        // If distance is less than a certain threshold, move the small rectangle away
        if (distance < 100) {
            double angle = Math.atan2(yPosBigRect - yPosSmallRect, xPosBigRect - xPosSmallRect);
            movementXSmallRect = Math.cos(angle) * -1;
            movementYSmallRect = Math.sin(angle) * -1;
        } else {
            movementXSmallRect = 0;
            movementYSmallRect = 0;
        }

        xPosBigRect += movementXBigRect;
        yPosBigRect += movementYBigRect;
        xPosSmallRect += movementXSmallRect;
        yPosSmallRect += movementYSmallRect;
    }

    public void moveUp() {
        if (yPosBigRect == 0) {
            movementYBigRect = 0;
            movementXBigRect = 0;
        }
        movementYBigRect = -0.5;
        movementXBigRect = 0;
    }

    // Implement other move methods similarly

    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();
        // Handle key presses for moving the big rectangle
    }

    // Implement other KeyListener methods similarly
}",        if (distance < 100) {,ChatGPT
AvoidFieldNameMatchingMethodName,Field isString has the same name as a method,"public class StringOrDouble {
    private String stringValue;
    private Double doubleValue;
    private boolean isString;

    public StringOrDouble(String value) {
        this.stringValue = value;
        this.isString = true;
    }

    public StringOrDouble(Double value) {
        this.doubleValue = value;
        this.isString = false;
    }

    public String getValueAsString() {
        return isString ? stringValue : (doubleValue != null ? doubleValue.toString() : null);
    }

    public Double getValueAsDouble() {
        return isString ? (stringValue != null ? Double.parseDouble(stringValue) : null) : doubleValue;
    }

    public boolean isString() {
        return isString;
    }
}",    private boolean isString;,ChatGPT
AssignmentToNonFinalStatic,Possible unsafe assignment to non-final static field 'animalArray' in a constructor.,"public abstract class Animal {
    private int capacity;
    public static int[] animalArray;

    public Animal(int value) {
        animalArray = new int[value];
    }

    public boolean adSteps(int element) {
        if (capacity >= animalArray.length) {
            return false;
        } else {
            animalArray[capacity++] = element;
            return true;
        }
    }

    public Moving letsMove() {
        return new Moving();
    }

    public abstract int getEfficiency(); // Abstract method

    public static int efficiency(int steps) {
        int equalSteps = steps + 10;
        return equalSteps;
    }
}

public class Cat extends Animal {
    public Cat(int value) {
        super(value);
    }

    @Override
    public int getEfficiency() { // Override abstract method
        return 50; // Specific efficiency for cats
    }
}

public class Moving {
    private int[] movingArray = Animal.animalArray.clone();
    private int totalWay;

    public int walk() {
        System.out.println(""Go ahead"");
        for (int i = 0; i < movingArray.length; i++) {
            totalWay += movingArray[i];
        }
        totalWay = Animal.efficiency(totalWay);
        return totalWay;
    }
}

public class Main {
    public static void main(String[] args) {

        Animal noName = new Cat(3);

        noName.adSteps(5);
        noName.adSteps(3);
        noName.adSteps(2);

        Moving iAmMoving = noName.letsMove();

        System.out.println(iAmMoving.walk()); // Will use Cat's efficiency
    }
}",        animalArray = new int[value];,ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {

    private List<Point> points;
    private Color nextColor; // Variable to store the color of the next circle and lines

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> new Circle().buildAndDisplayGui());
    }

    public Circle() {
        points = new ArrayList<>();
        setPreferredSize(new Dimension(500, 500));
        setBackground(Color.white);
        addMouseListener(this);
        nextColor = Color.black; // Default color
    }

    private void buildAndDisplayGui() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(this);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.addKeyListener(this);
    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(nextColor); // Set the color for the next circle and lines
        int count = points.size();
        for (int i = 0; i < count; i++) {
            Point pt0 = points.get(i);
            g.fillOval(pt0.x - 10, pt0.y - 11, 20, 20);
            if (i > 0) {
                Point pt1 = points.get(i - 1);
                g.drawLine(pt1.x, pt1.y, pt0.x, pt0.y);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println(""X: "" + e.getX() + "" Y: "" + e.getY());
        Point pt = new Point(e.getX(), e.getY());
        points.add(pt);
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {}

    @Override
    public void mouseExited(MouseEvent e) {}

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseDragged(MouseEvent e) {}

    @Override
    public void mouseMoved(MouseEvent e) {}

    @Override
    public void keyTyped(KeyEvent e) {
        char input = Character.toLowerCase(e.getKeyChar());
        if (input == 'r') {
            nextColor = Color.red;
        } else if (input == 'b') {
            nextColor = Color.blue;
        } else if (input == 'g') {
            nextColor = Color.green;
        } else if (input == 'l') {
            nextColor = Color.black;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {}
}","public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {",ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JComponent.setPreferredSize(Dimension) ,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {

    private List<Point> points;
    private Color nextColor; // Variable to store the color of the next circle and lines

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> new Circle().buildAndDisplayGui());
    }

    public Circle() {
        points = new ArrayList<>();
        setPreferredSize(new Dimension(500, 500));
        setBackground(Color.white);
        addMouseListener(this);
        nextColor = Color.black; // Default color
    }

    private void buildAndDisplayGui() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(this);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.addKeyListener(this);
    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(nextColor); // Set the color for the next circle and lines
        int count = points.size();
        for (int i = 0; i < count; i++) {
            Point pt0 = points.get(i);
            g.fillOval(pt0.x - 10, pt0.y - 11, 20, 20);
            if (i > 0) {
                Point pt1 = points.get(i - 1);
                g.drawLine(pt1.x, pt1.y, pt0.x, pt0.y);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println(""X: "" + e.getX() + "" Y: "" + e.getY());
        Point pt = new Point(e.getX(), e.getY());
        points.add(pt);
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {}

    @Override
    public void mouseExited(MouseEvent e) {}

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseDragged(MouseEvent e) {}

    @Override
    public void mouseMoved(MouseEvent e) {}

    @Override
    public void keyTyped(KeyEvent e) {
        char input = Character.toLowerCase(e.getKeyChar());
        if (input == 'r') {
            nextColor = Color.red;
        } else if (input == 'b') {
            nextColor = Color.blue;
        } else if (input == 'g') {
            nextColor = Color.green;
        } else if (input == 'l') {
            nextColor = Color.black;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {}
}","        setPreferredSize(new Dimension(500, 500));",ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JComponent.setBackground(Color) ,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {

    private List<Point> points;
    private Color nextColor; // Variable to store the color of the next circle and lines

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> new Circle().buildAndDisplayGui());
    }

    public Circle() {
        points = new ArrayList<>();
        setPreferredSize(new Dimension(500, 500));
        setBackground(Color.white);
        addMouseListener(this);
        nextColor = Color.black; // Default color
    }

    private void buildAndDisplayGui() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(this);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.addKeyListener(this);
    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(nextColor); // Set the color for the next circle and lines
        int count = points.size();
        for (int i = 0; i < count; i++) {
            Point pt0 = points.get(i);
            g.fillOval(pt0.x - 10, pt0.y - 11, 20, 20);
            if (i > 0) {
                Point pt1 = points.get(i - 1);
                g.drawLine(pt1.x, pt1.y, pt0.x, pt0.y);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println(""X: "" + e.getX() + "" Y: "" + e.getY());
        Point pt = new Point(e.getX(), e.getY());
        points.add(pt);
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {}

    @Override
    public void mouseExited(MouseEvent e) {}

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseDragged(MouseEvent e) {}

    @Override
    public void mouseMoved(MouseEvent e) {}

    @Override
    public void keyTyped(KeyEvent e) {
        char input = Character.toLowerCase(e.getKeyChar());
        if (input == 'r') {
            nextColor = Color.red;
        } else if (input == 'b') {
            nextColor = Color.blue;
        } else if (input == 'g') {
            nextColor = Color.green;
        } else if (input == 'l') {
            nextColor = Color.black;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {}
}",        setBackground(Color.white);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Component.addMouseListener(MouseListener) ,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {

    private List<Point> points;
    private Color nextColor; // Variable to store the color of the next circle and lines

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> new Circle().buildAndDisplayGui());
    }

    public Circle() {
        points = new ArrayList<>();
        setPreferredSize(new Dimension(500, 500));
        setBackground(Color.white);
        addMouseListener(this);
        nextColor = Color.black; // Default color
    }

    private void buildAndDisplayGui() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(this);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.addKeyListener(this);
    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(nextColor); // Set the color for the next circle and lines
        int count = points.size();
        for (int i = 0; i < count; i++) {
            Point pt0 = points.get(i);
            g.fillOval(pt0.x - 10, pt0.y - 11, 20, 20);
            if (i > 0) {
                Point pt1 = points.get(i - 1);
                g.drawLine(pt1.x, pt1.y, pt0.x, pt0.y);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println(""X: "" + e.getX() + "" Y: "" + e.getY());
        Point pt = new Point(e.getX(), e.getY());
        points.add(pt);
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {}

    @Override
    public void mouseExited(MouseEvent e) {}

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseDragged(MouseEvent e) {}

    @Override
    public void mouseMoved(MouseEvent e) {}

    @Override
    public void keyTyped(KeyEvent e) {
        char input = Character.toLowerCase(e.getKeyChar());
        if (input == 'r') {
            nextColor = Color.red;
        } else if (input == 'b') {
            nextColor = Color.blue;
        } else if (input == 'g') {
            nextColor = Color.green;
        } else if (input == 'l') {
            nextColor = Color.black;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {}
}",        addMouseListener(this);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {

    private List<Point> points;
    private Color nextColor; // Variable to store the color of the next circle and lines

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> new Circle().buildAndDisplayGui());
    }

    public Circle() {
        points = new ArrayList<>();
        setPreferredSize(new Dimension(500, 500));
        setBackground(Color.white);
        addMouseListener(this);
        nextColor = Color.black; // Default color
    }

    private void buildAndDisplayGui() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(this);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.addKeyListener(this);
    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(nextColor); // Set the color for the next circle and lines
        int count = points.size();
        for (int i = 0; i < count; i++) {
            Point pt0 = points.get(i);
            g.fillOval(pt0.x - 10, pt0.y - 11, 20, 20);
            if (i > 0) {
                Point pt1 = points.get(i - 1);
                g.drawLine(pt1.x, pt1.y, pt0.x, pt0.y);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println(""X: "" + e.getX() + "" Y: "" + e.getY());
        Point pt = new Point(e.getX(), e.getY());
        points.add(pt);
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {}

    @Override
    public void mouseExited(MouseEvent e) {}

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseDragged(MouseEvent e) {}

    @Override
    public void mouseMoved(MouseEvent e) {}

    @Override
    public void keyTyped(KeyEvent e) {
        char input = Character.toLowerCase(e.getKeyChar());
        if (input == 'r') {
            nextColor = Color.red;
        } else if (input == 'b') {
            nextColor = Color.blue;
        } else if (input == 'g') {
            nextColor = Color.green;
        } else if (input == 'l') {
            nextColor = Color.black;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {}
}",        if (input == 'r') {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {

    private List<Point> points;
    private Color nextColor; // Variable to store the color of the next circle and lines

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> new Circle().buildAndDisplayGui());
    }

    public Circle() {
        points = new ArrayList<>();
        setPreferredSize(new Dimension(500, 500));
        setBackground(Color.white);
        addMouseListener(this);
        nextColor = Color.black; // Default color
    }

    private void buildAndDisplayGui() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(this);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.addKeyListener(this);
    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(nextColor); // Set the color for the next circle and lines
        int count = points.size();
        for (int i = 0; i < count; i++) {
            Point pt0 = points.get(i);
            g.fillOval(pt0.x - 10, pt0.y - 11, 20, 20);
            if (i > 0) {
                Point pt1 = points.get(i - 1);
                g.drawLine(pt1.x, pt1.y, pt0.x, pt0.y);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println(""X: "" + e.getX() + "" Y: "" + e.getY());
        Point pt = new Point(e.getX(), e.getY());
        points.add(pt);
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {}

    @Override
    public void mouseExited(MouseEvent e) {}

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseDragged(MouseEvent e) {}

    @Override
    public void mouseMoved(MouseEvent e) {}

    @Override
    public void keyTyped(KeyEvent e) {
        char input = Character.toLowerCase(e.getKeyChar());
        if (input == 'r') {
            nextColor = Color.red;
        } else if (input == 'b') {
            nextColor = Color.blue;
        } else if (input == 'g') {
            nextColor = Color.green;
        } else if (input == 'l') {
            nextColor = Color.black;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {}
}",        } else if (input == 'b') {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {

    private List<Point> points;
    private Color nextColor; // Variable to store the color of the next circle and lines

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> new Circle().buildAndDisplayGui());
    }

    public Circle() {
        points = new ArrayList<>();
        setPreferredSize(new Dimension(500, 500));
        setBackground(Color.white);
        addMouseListener(this);
        nextColor = Color.black; // Default color
    }

    private void buildAndDisplayGui() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(this);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.addKeyListener(this);
    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(nextColor); // Set the color for the next circle and lines
        int count = points.size();
        for (int i = 0; i < count; i++) {
            Point pt0 = points.get(i);
            g.fillOval(pt0.x - 10, pt0.y - 11, 20, 20);
            if (i > 0) {
                Point pt1 = points.get(i - 1);
                g.drawLine(pt1.x, pt1.y, pt0.x, pt0.y);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println(""X: "" + e.getX() + "" Y: "" + e.getY());
        Point pt = new Point(e.getX(), e.getY());
        points.add(pt);
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {}

    @Override
    public void mouseExited(MouseEvent e) {}

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseDragged(MouseEvent e) {}

    @Override
    public void mouseMoved(MouseEvent e) {}

    @Override
    public void keyTyped(KeyEvent e) {
        char input = Character.toLowerCase(e.getKeyChar());
        if (input == 'r') {
            nextColor = Color.red;
        } else if (input == 'b') {
            nextColor = Color.blue;
        } else if (input == 'g') {
            nextColor = Color.green;
        } else if (input == 'l') {
            nextColor = Color.black;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {}
}",        } else if (input == 'g') {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Circle extends JPanel implements MouseListener, KeyListener, MouseMotionListener {

    private List<Point> points;
    private Color nextColor; // Variable to store the color of the next circle and lines

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> new Circle().buildAndDisplayGui());
    }

    public Circle() {
        points = new ArrayList<>();
        setPreferredSize(new Dimension(500, 500));
        setBackground(Color.white);
        addMouseListener(this);
        nextColor = Color.black; // Default color
    }

    private void buildAndDisplayGui() {
        JFrame frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(this);
        frame.pack();
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
        frame.addKeyListener(this);
    }

    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(nextColor); // Set the color for the next circle and lines
        int count = points.size();
        for (int i = 0; i < count; i++) {
            Point pt0 = points.get(i);
            g.fillOval(pt0.x - 10, pt0.y - 11, 20, 20);
            if (i > 0) {
                Point pt1 = points.get(i - 1);
                g.drawLine(pt1.x, pt1.y, pt0.x, pt0.y);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println(""X: "" + e.getX() + "" Y: "" + e.getY());
        Point pt = new Point(e.getX(), e.getY());
        points.add(pt);
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {}

    @Override
    public void mouseExited(MouseEvent e) {}

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseDragged(MouseEvent e) {}

    @Override
    public void mouseMoved(MouseEvent e) {}

    @Override
    public void keyTyped(KeyEvent e) {
        char input = Character.toLowerCase(e.getKeyChar());
        if (input == 'r') {
            nextColor = Color.red;
        } else if (input == 'b') {
            nextColor = Color.blue;
        } else if (input == 'g') {
            nextColor = Color.green;
        } else if (input == 'l') {
            nextColor = Color.black;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {}
}",        } else if (input == 'l') {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"class FooClass {
    int id;
    String first;
    String second;
    String third;
 
    FooClass(final int id, final String first, final String second, final String third) {
        this.id = id;
        this.first = first;
        this.second = second;
        this.third = third;
    }
 
    FooClass(final int id, final String first) {
        this(id, first, null, null);
    }
 
    FooClass(final int id, final String first, final String second) {
        this(id, first, second, null);
    }
 
    FooClass(final int id, final String... myStrings) {
        this(id, myStrings[0]);
        if (myStrings.length > 1) {
            this.second = myStrings[1];
        }
        if (myStrings.length > 2) {
            this.third = myStrings[2];
        }
    }
}",        if (myStrings.length > 1) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"class FooClass {
    int id;
    String first;
    String second;
    String third;
 
    FooClass(final int id, final String first, final String second, final String third) {
        this.id = id;
        this.first = first;
        this.second = second;
        this.third = third;
    }
 
    FooClass(final int id, final String first) {
        this(id, first, null, null);
    }
 
    FooClass(final int id, final String first, final String second) {
        this(id, first, second, null);
    }
 
    FooClass(final int id, final String... myStrings) {
        this(id, myStrings[0]);
        if (myStrings.length > 1) {
            this.second = myStrings[1];
        }
        if (myStrings.length > 2) {
            this.third = myStrings[2];
        }
    }
}",        if (myStrings.length > 2) {,ChatGPT
TestClassWithoutTestCases,"The class 'SomeTest' might be a test class, but it contains no test cases.","public class SomeTest {
    @Test
    public void test() {
        SomeInterface mock = Mockito.mock(SomeInterface.class, Mockito.withSettings().strictness(Strictness.STRICT_STUBS));

        // Stubbing for specific input value true
        Mockito.when(mock.test(Mockito.eq(true))).thenReturn(1);

        // Verification for specific input value true
        Assert.assertEquals(mock.test(true), 1);

        // Verification for any boolean argument other than true
        Assert.assertEquals(mock.test(false), 0);
    }

    interface SomeInterface {
        int test(Boolean arg);
    }
}",public class SomeTest {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"class Human {
    private Integer age;
    private String describe;

    public Human(Integer age) {
        this.age = age;
        setDescribe();
    }

    public void setAge(Integer age) {
        this.age = age;
        setDescribe(); // Call setDescribe whenever age is updated
    }

    // Modify setDescribe to not take any parameters
    private void setDescribe() {
        String description = """";
        if (this.age < 30) {
            description = ""young"";
        } else if (this.age <= 55 && this.age >= 30) {
            description = ""middle-aged"";
        } else {
            description = ""old"";
        }
        this.describe = description;
    }
}",        if (this.age < 30) {,ChatGPT
DoNotTerminateVM,System.exit() should not be used in J2EE/JEE apps,"package com.mycompany.audio;

import javax.swing.*;
import java.awt.event.*;

public class Audio {
    public static void main(String[] args) {
        JFrame GUI = new JFrame();
        GUI.setSize(300, 300);
        GUI.setLayout(null);
        GUI.setVisible(true);
        
        JPanel panel = new JPanel();
        GUI.add(panel);
        panel.requestFocusInWindow(); // Ensure the panel has focus to receive key events
        
        panel.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_A) {
                    System.exit(0); // Terminate the program if A is pressed
                }
            }
        });
    }
}",                    System.exit(0); // Terminate the program if A is pressed,ChatGPT
TestClassWithoutTestCases,"The class 'BookManagementServiceTest' might be a test class, but it contains no test cases.","@SpringBootTest
@ExtendWith(MockitoExtension.class)
class BookManagementServiceTest {

    // Inject the needed services and mock repos
    @InjectMocks private BookManagementService service;
    @Mock private BookItemRepo repoItem;
    @Mock private BookEditionRepo repoEdition;
    @Mock private BookRepo repo;
    @Mock private BookYearRepo yearRepo;
    @Mock private GenreRepo genreRepo;
    @Mock private AuthorRepo authorRepo;

    @BeforeEach
    void setUp() {
        // Instantiate and inject the mock services into the service
        service = new BookManagementService(repo, repoItem, repoEdition, yearService, genreService, authorService);
        
        // Set up behavior of mock services and repositories
        lenient().when(yearRepo.findByYear(""2006"")).thenReturn(year);
        lenient().when(yearRepo.save(year)).thenReturn(year);
        lenient().when(repoItem.save(item)).thenReturn(item);
        lenient().when(yearService.create(""2006"", edition)).thenReturn(year);
        lenient().when(repoEdition.save(edition)).thenReturn(edition);
        lenient().when(repo.save(book)).thenReturn(book);
        // Set up behavior of other services and repositories as needed
    }

    // Tests
}",class BookManagementServiceTest {,ChatGPT
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","import com.google.firebase.firestore.DocumentSnapshot;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class YourClass {

    // Method to convert Firestore snapshot data to ArrayList<Test>
    public List<Test> convertSnapshotToTestList(DocumentSnapshot documentSnapshot) {
        List<Test> testList = new ArrayList<>();

        // Iterate over the snapshot data
        for (Map.Entry<String, Object> entry : documentSnapshot.getData().entrySet()) {
            if (!""0"".equals(entry.getKey()) && !""1"".equals(entry.getKey())) {
                // Get the map containing field values
                Map<String, Object> data = (Map<String, Object>) entry.getValue();

                // Create a new Test object
                Test test = new Test();

                // Set values for Test object using data from Firestore snapshot
                test.setField1((String) data.get(""field1""));
                test.setField2((String) data.get(""field2""));
                test.setField3((String) data.get(""field3""));

                // Add Test object to the list
                testList.add(test);
            }
        }

        return testList;
    }

    // Your Test class definition
    static class Test {
        private String field1;
        private String field2;
        private String field3;

        public String getField1() {
            return field1;
        }

        public void setField1(String field1) {
            this.field1 = field1;
        }

        public String getField2() {
            return field2;
        }

        public void setField2(String field2) {
            this.field2 = field2;
        }

        public String getField3() {
            return field3;
        }

        public void setField3(String field3) {
            this.field3 = field3;
        }
    }
}",    static class Test {,ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import javax.swing.*;
import Pieces.*;
import java.awt.*;

public class Game extends JFrame {
    private static final int width = 8;
    private static final int height = 8;

    private static Piece clicked;

    private static Piece[][] fields = new Piece[width][height];

    private JPanel main = new JPanel();

    public static void init(JPanel g) {
        for (int y = 0; y < fields.length; y++) {
            for (int x = 0; x < fields[y].length; x++) {

                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns
                else if (y == 6) fields[y][x] = new Pawn(x, y, false);
                else {
                    fields[y][x] = new Empty(x,y,true);
                }

                fields[y][x].addActionListener(e -> {
                    var p = (Piece) e.getSource();
                    System.out.println(p.getX() + p.getY());
                });

                g.add(fields[y][x]);
            }
        }
    }

    public Game() {
        main.setBackground(Color.blue.darker());
        main.setLayout(new GridLayout(8,8));
        this.setSize(800,800);

        init(main);
        this.add(main);

        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            var g = new Game();
        });
    }
}",public class Game extends JFrame {,ChatGPT
AvoidFieldNameMatchingMethodName,Field main has the same name as a method,"import javax.swing.*;
import Pieces.*;
import java.awt.*;

public class Game extends JFrame {
    private static final int width = 8;
    private static final int height = 8;

    private static Piece clicked;

    private static Piece[][] fields = new Piece[width][height];

    private JPanel main = new JPanel();

    public static void init(JPanel g) {
        for (int y = 0; y < fields.length; y++) {
            for (int x = 0; x < fields[y].length; x++) {

                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns
                else if (y == 6) fields[y][x] = new Pawn(x, y, false);
                else {
                    fields[y][x] = new Empty(x,y,true);
                }

                fields[y][x].addActionListener(e -> {
                    var p = (Piece) e.getSource();
                    System.out.println(p.getX() + p.getY());
                });

                g.add(fields[y][x]);
            }
        }
    }

    public Game() {
        main.setBackground(Color.blue.darker());
        main.setLayout(new GridLayout(8,8));
        this.setSize(800,800);

        init(main);
        this.add(main);

        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            var g = new Game();
        });
    }
}",    private JPanel main = new JPanel();,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import javax.swing.*;
import Pieces.*;
import java.awt.*;

public class Game extends JFrame {
    private static final int width = 8;
    private static final int height = 8;

    private static Piece clicked;

    private static Piece[][] fields = new Piece[width][height];

    private JPanel main = new JPanel();

    public static void init(JPanel g) {
        for (int y = 0; y < fields.length; y++) {
            for (int x = 0; x < fields[y].length; x++) {

                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns
                else if (y == 6) fields[y][x] = new Pawn(x, y, false);
                else {
                    fields[y][x] = new Empty(x,y,true);
                }

                fields[y][x].addActionListener(e -> {
                    var p = (Piece) e.getSource();
                    System.out.println(p.getX() + p.getY());
                });

                g.add(fields[y][x]);
            }
        }
    }

    public Game() {
        main.setBackground(Color.blue.darker());
        main.setLayout(new GridLayout(8,8));
        this.setSize(800,800);

        init(main);
        this.add(main);

        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            var g = new Game();
        });
    }
}","                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns",ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import javax.swing.*;
import Pieces.*;
import java.awt.*;

public class Game extends JFrame {
    private static final int width = 8;
    private static final int height = 8;

    private static Piece clicked;

    private static Piece[][] fields = new Piece[width][height];

    private JPanel main = new JPanel();

    public static void init(JPanel g) {
        for (int y = 0; y < fields.length; y++) {
            for (int x = 0; x < fields[y].length; x++) {

                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns
                else if (y == 6) fields[y][x] = new Pawn(x, y, false);
                else {
                    fields[y][x] = new Empty(x,y,true);
                }

                fields[y][x].addActionListener(e -> {
                    var p = (Piece) e.getSource();
                    System.out.println(p.getX() + p.getY());
                });

                g.add(fields[y][x]);
            }
        }
    }

    public Game() {
        main.setBackground(Color.blue.darker());
        main.setLayout(new GridLayout(8,8));
        this.setSize(800,800);

        init(main);
        this.add(main);

        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            var g = new Game();
        });
    }
}","                else if (y == 6) fields[y][x] = new Pawn(x, y, false);",ChatGPT
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Window.setSize(int, int) ","import javax.swing.*;
import Pieces.*;
import java.awt.*;

public class Game extends JFrame {
    private static final int width = 8;
    private static final int height = 8;

    private static Piece clicked;

    private static Piece[][] fields = new Piece[width][height];

    private JPanel main = new JPanel();

    public static void init(JPanel g) {
        for (int y = 0; y < fields.length; y++) {
            for (int x = 0; x < fields[y].length; x++) {

                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns
                else if (y == 6) fields[y][x] = new Pawn(x, y, false);
                else {
                    fields[y][x] = new Empty(x,y,true);
                }

                fields[y][x].addActionListener(e -> {
                    var p = (Piece) e.getSource();
                    System.out.println(p.getX() + p.getY());
                });

                g.add(fields[y][x]);
            }
        }
    }

    public Game() {
        main.setBackground(Color.blue.darker());
        main.setLayout(new GridLayout(8,8));
        this.setSize(800,800);

        init(main);
        this.add(main);

        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            var g = new Game();
        });
    }
}","        this.setSize(800,800);",ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Container.add(Component) ,"import javax.swing.*;
import Pieces.*;
import java.awt.*;

public class Game extends JFrame {
    private static final int width = 8;
    private static final int height = 8;

    private static Piece clicked;

    private static Piece[][] fields = new Piece[width][height];

    private JPanel main = new JPanel();

    public static void init(JPanel g) {
        for (int y = 0; y < fields.length; y++) {
            for (int x = 0; x < fields[y].length; x++) {

                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns
                else if (y == 6) fields[y][x] = new Pawn(x, y, false);
                else {
                    fields[y][x] = new Empty(x,y,true);
                }

                fields[y][x].addActionListener(e -> {
                    var p = (Piece) e.getSource();
                    System.out.println(p.getX() + p.getY());
                });

                g.add(fields[y][x]);
            }
        }
    }

    public Game() {
        main.setBackground(Color.blue.darker());
        main.setLayout(new GridLayout(8,8));
        this.setSize(800,800);

        init(main);
        this.add(main);

        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            var g = new Game();
        });
    }
}",        this.add(main);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.setDefaultCloseOperation(int) ,"import javax.swing.*;
import Pieces.*;
import java.awt.*;

public class Game extends JFrame {
    private static final int width = 8;
    private static final int height = 8;

    private static Piece clicked;

    private static Piece[][] fields = new Piece[width][height];

    private JPanel main = new JPanel();

    public static void init(JPanel g) {
        for (int y = 0; y < fields.length; y++) {
            for (int x = 0; x < fields[y].length; x++) {

                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns
                else if (y == 6) fields[y][x] = new Pawn(x, y, false);
                else {
                    fields[y][x] = new Empty(x,y,true);
                }

                fields[y][x].addActionListener(e -> {
                    var p = (Piece) e.getSource();
                    System.out.println(p.getX() + p.getY());
                });

                g.add(fields[y][x]);
            }
        }
    }

    public Game() {
        main.setBackground(Color.blue.darker());
        main.setLayout(new GridLayout(8,8));
        this.setSize(800,800);

        init(main);
        this.add(main);

        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            var g = new Game();
        });
    }
}",        this.setDefaultCloseOperation(EXIT_ON_CLOSE);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setVisible(boolean) ,"import javax.swing.*;
import Pieces.*;
import java.awt.*;

public class Game extends JFrame {
    private static final int width = 8;
    private static final int height = 8;

    private static Piece clicked;

    private static Piece[][] fields = new Piece[width][height];

    private JPanel main = new JPanel();

    public static void init(JPanel g) {
        for (int y = 0; y < fields.length; y++) {
            for (int x = 0; x < fields[y].length; x++) {

                if (y == 1) fields[y][x] = new Pawn(x, y, true); //2nd or 7th row is filled with pawns
                else if (y == 6) fields[y][x] = new Pawn(x, y, false);
                else {
                    fields[y][x] = new Empty(x,y,true);
                }

                fields[y][x].addActionListener(e -> {
                    var p = (Piece) e.getSource();
                    System.out.println(p.getX() + p.getY());
                });

                g.add(fields[y][x]);
            }
        }
    }

    public Game() {
        main.setBackground(Color.blue.darker());
        main.setLayout(new GridLayout(8,8));
        this.setSize(800,800);

        init(main);
        this.add(main);

        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            var g = new Game();
        });
    }
}",        this.setVisible(true);,ChatGPT
CloseResource,Ensure that resources like this Connection object are closed after use,"import org.hibernate.engine.spi.SharedSessionContractImplementor;
import org.hibernate.usertype.UserType;

import java.io.Serializable;
import java.math.BigDecimal;
import java.sql.*;

public class BigDecimalArrayType implements UserType {

    private static final int[] SQL_TYPES = {Types.ARRAY};

    @Override
    public int[] sqlTypes() {
        return SQL_TYPES;
    }

    @Override
    public Class returnedClass() {
        return BigDecimal[][].class;
    }

    @Override
    public boolean equals(Object x, Object y) {
        if (x == null) {
            return y == null;
        }
        return x.equals(y);
    }

    @Override
    public int hashCode(Object x) {
        return x.hashCode();
    }

    @Override
    public Object nullSafeGet(
            ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner
    ) throws SQLException {
        if (rs.wasNull()) {
            return null;
        }
        Array array = rs.getArray(names[0]);
        if (array == null) {
            return null;
        }
        return array.getArray();
    }

    @Override
    public void nullSafeSet(
            PreparedStatement st, Object value, int index, SharedSessionContractImplementor session
    ) throws SQLException {
        if (value == null) {
            st.setNull(index, SQL_TYPES[0]);
        } else {
            Connection connection = st.getConnection();
            Array array = connection.createArrayOf(""DECIMAL"", (Object[]) value);
            st.setArray(index, array);
        }
    }

    @Override
    public Object deepCopy(Object value) {
        if (value == null) {
            return null;
        }
        BigDecimal[][] source = (BigDecimal[][]) value;
        BigDecimal[][] target = new BigDecimal[source.length][];
        for (int i = 0; i < source.length; i++) {
            target[i] = new BigDecimal[source[i].length];
            System.arraycopy(source[i], 0, target[i], 0, source[i].length);
        }
        return target;
    }

    @Override
    public boolean isMutable() {
        return true;
    }

    @Override
    public Serializable disassemble(Object value) {
        return (Serializable) value;
    }

    @Override
    public Object assemble(Serializable cached, Object owner) {
        return cached;
    }

    @Override
    public Object replace(Object original, Object target, Object owner) {
        return original;
    }
}",            Connection connection = st.getConnection();,ChatGPT
CloseResource,Ensure that resources like this BufferedReader object are closed after use,"import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.Toast;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;

public class MainActivity extends Activity {
    final String rtmp_url = ""rtsp://192.168.0.12:1935/live/test"";
    private int PREVIEW_WIDTH = 384;
    private int PREVIEW_HEIGHT = 292;
    private String TAG = ""MainActivity"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // Assuming this method is called to start preview
        try {
            handleStartPreview();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void handleStartPreview() throws InterruptedException, IOException {
        final String ffmpegPath = ""/path/to/ffmpeg""; // Replace with the path to your FFmpeg binary
        final String command[] = {ffmpegPath,
                ""-y"", // Overwrite output files without asking
                ""-f"", ""rawvideo"",
                ""-vcodec"", ""rawvideo"",
                ""-pix_fmt"", ""bgr24"",
                ""-s"", PREVIEW_WIDTH + ""x"" + PREVIEW_HEIGHT,
                ""-r"", ""10"", // Frame rate
                ""-i"", ""-"", // Input from standard input
                ""-c:v"", ""libx264"",
                ""-pix_fmt"", ""yuv420p"",
                ""-preset"", ""ultrafast"",
                ""-f"", ""rtsp"",
                rtmp_url};

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        Process process = pb.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        OutputStream writer = process.getOutputStream();

        // Replace this with your actual image data retrieval mechanism
        byte img[] = new byte[PREVIEW_WIDTH * PREVIEW_HEIGHT * 3];
        for (int i = 0; i < 10; i++) {
            // Write image data to FFmpeg stdin
            writer.write(img);
        }

        writer.close();

        String line;
        while ((line = reader.readLine()) != null) {
            Log.d(TAG, line);
        }

        process.waitFor();
        Toast.makeText(MainActivity.this, ""Preview started"", Toast.LENGTH_SHORT).show();
    }
}",        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));,ChatGPT
CloseResource,Ensure that resources like this OutputStream object are closed after use,"import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.Toast;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;

public class MainActivity extends Activity {
    final String rtmp_url = ""rtsp://192.168.0.12:1935/live/test"";
    private int PREVIEW_WIDTH = 384;
    private int PREVIEW_HEIGHT = 292;
    private String TAG = ""MainActivity"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // Assuming this method is called to start preview
        try {
            handleStartPreview();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void handleStartPreview() throws InterruptedException, IOException {
        final String ffmpegPath = ""/path/to/ffmpeg""; // Replace with the path to your FFmpeg binary
        final String command[] = {ffmpegPath,
                ""-y"", // Overwrite output files without asking
                ""-f"", ""rawvideo"",
                ""-vcodec"", ""rawvideo"",
                ""-pix_fmt"", ""bgr24"",
                ""-s"", PREVIEW_WIDTH + ""x"" + PREVIEW_HEIGHT,
                ""-r"", ""10"", // Frame rate
                ""-i"", ""-"", // Input from standard input
                ""-c:v"", ""libx264"",
                ""-pix_fmt"", ""yuv420p"",
                ""-preset"", ""ultrafast"",
                ""-f"", ""rtsp"",
                rtmp_url};

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        Process process = pb.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        OutputStream writer = process.getOutputStream();

        // Replace this with your actual image data retrieval mechanism
        byte img[] = new byte[PREVIEW_WIDTH * PREVIEW_HEIGHT * 3];
        for (int i = 0; i < 10; i++) {
            // Write image data to FFmpeg stdin
            writer.write(img);
        }

        writer.close();

        String line;
        while ((line = reader.readLine()) != null) {
            Log.d(TAG, line);
        }

        process.waitFor();
        Toast.makeText(MainActivity.this, ""Preview started"", Toast.LENGTH_SHORT).show();
    }
}",        OutputStream writer = process.getOutputStream();,ChatGPT
AssignmentInOperand,Avoid assignments in operands,"import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.Toast;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;

public class MainActivity extends Activity {
    final String rtmp_url = ""rtsp://192.168.0.12:1935/live/test"";
    private int PREVIEW_WIDTH = 384;
    private int PREVIEW_HEIGHT = 292;
    private String TAG = ""MainActivity"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // Assuming this method is called to start preview
        try {
            handleStartPreview();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void handleStartPreview() throws InterruptedException, IOException {
        final String ffmpegPath = ""/path/to/ffmpeg""; // Replace with the path to your FFmpeg binary
        final String command[] = {ffmpegPath,
                ""-y"", // Overwrite output files without asking
                ""-f"", ""rawvideo"",
                ""-vcodec"", ""rawvideo"",
                ""-pix_fmt"", ""bgr24"",
                ""-s"", PREVIEW_WIDTH + ""x"" + PREVIEW_HEIGHT,
                ""-r"", ""10"", // Frame rate
                ""-i"", ""-"", // Input from standard input
                ""-c:v"", ""libx264"",
                ""-pix_fmt"", ""yuv420p"",
                ""-preset"", ""ultrafast"",
                ""-f"", ""rtsp"",
                rtmp_url};

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        Process process = pb.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        OutputStream writer = process.getOutputStream();

        // Replace this with your actual image data retrieval mechanism
        byte img[] = new byte[PREVIEW_WIDTH * PREVIEW_HEIGHT * 3];
        for (int i = 0; i < 10; i++) {
            // Write image data to FFmpeg stdin
            writer.write(img);
        }

        writer.close();

        String line;
        while ((line = reader.readLine()) != null) {
            Log.d(TAG, line);
        }

        process.waitFor();
        Toast.makeText(MainActivity.this, ""Preview started"", Toast.LENGTH_SHORT).show();
    }
}",        while ((line = reader.readLine()) != null) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.Iterator;
import java.util.Map;

public class JsonExpressionEvaluator {

    private static final ObjectMapper objectMapper = new ObjectMapper();

    public static void evaluateExpressions(JsonNode node) {
        if (node.isObject()) {
            ObjectNode objectNode = (ObjectNode) node;
            Iterator<Map.Entry<String, JsonNode>> fields = objectNode.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                if (field.getValue().isObject() && field.getValue().has(""expression"")) {
                    String expression = field.getValue().get(""expression"").asText();
                    int value = evaluateExpression(expression, node);
                    objectNode.put(field.getKey(), value);
                } else {
                    evaluateExpressions(field.getValue());
                }
            }
        } else if (node.isArray()) {
            for (JsonNode element : node) {
                evaluateExpressions(element);
            }
        }
    }

    public static int evaluateExpression(String expression, JsonNode dataNode) {
        // Implement your expression evaluation logic here
        // For demonstration purposes, let's assume the expression format is ""calc(expression, data)""
        String[] parts = expression.split(""\\("");
        if (parts.length != 2) {
            throw new IllegalArgumentException(""Invalid expression: "" + expression);
        }
        String[] args = parts[1].replaceAll(""[()]"", """").split("","");
        String[] values = args[1].split("":"");
        String dataKey = values[0].trim();
        int dataValue = dataNode.at(""/"" + dataKey).asInt();
        String expressionWithoutCalc = parts[1].substring(0, parts[1].length() - 1).trim();
        // Evaluate expression - this should be your actual expression evaluation logic
        // For demonstration, we'll just add 100 to the data value
        int result = dataValue + Integer.parseInt(expressionWithoutCalc);
        return result;
    }

    public static void main(String[] args) throws Exception {
        String jsonString = ""{\""data\"":{\""A\"":1688,\""B\"":1363,\""C\"":{\""expression\"":\""calc(A+B,A:data.A,B:data.B)\""},\""D\"":{\""expression\"":\""calc(B+C,B:data.B,C:data.C)\""},\""drg\"":\""TEMPLATE(12).pdf\""},\""tbl02Modelmaster\"":{\""A\"":{\""expression\"":\""calc(A+100,A:$.data.A)\""},\""stageType\"":\""Multi\"",\""isPowerConstraint\"":true}}"";
        JsonNode rootNode = objectMapper.readTree(jsonString);
        evaluateExpressions(rootNode);
        System.out.println(rootNode.toString());
    }
}",        if (parts.length != 2) {,ChatGPT
TestClassWithoutTestCases,"The class 'TestActivity' might be a test class, but it contains no test cases.","public class TestActivity extends AppCompatActivity {

    private ViewPager2 viewpager2;
    private ViewPager2Adapter viewPager2Adapter;
    private VocabularyViewModel vocabularyViewModel;
    private Button btn_correct_2;
    private Button btn_false_2;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        initAll();

        btn_correct_2.setOnClickListener(view -> moveToNextCard(true));
        btn_false_2.setOnClickListener(view -> moveToNextCard(false));

        Objects.requireNonNull(getSupportActionBar()).setTitle(getResources().getString(R.string.learn_new_words));

        LiveData<List<VocabularyCard>> allNewCards = vocabularyViewModel.getAllNewCards(goal);
        allNewCards.observe(this, vocabularyCards -> {
            // Observe the current cards only once and then set them to the adapter and ViewPager2
            viewPager2Adapter.setCurrentCards(vocabularyCards);
            viewpager2.setAdapter(viewPager2Adapter);
        });
    }

    private void initAll() {
        // Initialize all your views, ViewModel, and ViewPager2Adapter here
    }

    private void moveToNextCard(boolean isCorrect) {
        int currentPos = viewpager2.getCurrentItem();
        vocabularyViewModel.getCurrentCards().observe(this, vocabularyCards -> {
            if (vocabularyCards != null && currentPos < vocabularyCards.size()) {
                VocabularyCard vocabularyCard = vocabularyCards.get(currentPos);
                // Update the vocabulary card based on the correctness
                if (isCorrect) {
                    vocabularyCard.setCorrect(true);
                } else {
                    vocabularyCard.setCorrect(false);
                }
                vocabularyViewModel.updateSingleVocabularyCard(vocabularyCard);

                // Move to the next card if available
                if (currentPos < vocabularyCards.size() - 1) {
                    viewpager2.setCurrentItem(currentPos + 1);
                } else {
                    // No more cards, navigate to another activity or perform any other action
                    Intent intent = new Intent(TestActivity.this, MainActivity.class);
                    startActivity(intent);
                }
            }
        });
    }
}",public class TestActivity extends AppCompatActivity {,ChatGPT
SimpleDateFormatNeedsLocale,"When instantiating a SimpleDateFormat object, specify a Locale","import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;

import java.io.IOException;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;

public class CustomTimestampSerializer extends JsonSerializer<Timestamp> {

    private final SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX"");

    @Override
    public void serialize(Timestamp timestamp, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        String formattedDate = dateFormat.format(timestamp);
        jsonGenerator.writeString(formattedDate);
    }
}","    private final SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX"");",ChatGPT
CloseResource,Ensure that resources like this BufferedReader object are closed after use,"import android.os.AsyncTask;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

public class GetData extends AsyncTask<String, Void, String> {

    @Override
    protected String doInBackground(String... strings) {
        String link = strings[0];
        StringBuilder response = new StringBuilder();

        try {
            URL url = new URL(link);
            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
            urlConnection.setRequestMethod(""GET"");

            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();
            urlConnection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return response.toString();
    }

    @Override
    protected void onPostExecute(String result) {
        // Update UI here with the fetched data
        // For example, set the text of a TextView
        textView.setText(result);
    }
}",            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));,ChatGPT
AssignmentInOperand,Avoid assignments in operands,"import android.os.AsyncTask;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

public class GetData extends AsyncTask<String, Void, String> {

    @Override
    protected String doInBackground(String... strings) {
        String link = strings[0];
        StringBuilder response = new StringBuilder();

        try {
            URL url = new URL(link);
            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
            urlConnection.setRequestMethod(""GET"");

            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();
            urlConnection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return response.toString();
    }

    @Override
    protected void onPostExecute(String result) {
        // Update UI here with the fetched data
        // For example, set the text of a TextView
        textView.setText(result);
    }
}",            while ((inputLine = in.readLine()) != null) {,ChatGPT
AvoidFieldNameMatchingMethodName,Field description has the same name as a method,"import org.springframework.context.ApplicationEvent;

public class OperationalEvent extends TrackedEvent {

    private OperationType type;
    private OperationStatus status;
    // ... several more fields here

    // Private constructor to prevent direct instantiation
    private OperationalEvent(Object source) {
        super(source);
    }

    public static OperationalEventBuilder builder(Object source) {
        return new OperationalEventBuilder(source);
    }

    public static class OperationalEventBuilder {
        private final Object source;
        private String correlationId;
        private String description;
        private OperationType type;
        private OperationStatus status;
        // ... other fields

        private OperationalEventBuilder(Object source) {
            this.source = source;
        }

        public OperationalEventBuilder description(String description) {
            this.description = description;
            return this;
        }

        public OperationalEventBuilder status(OperationStatus status) {
            this.status = status;
            return this;
        }

        // Other builder methods for additional fields

        public OperationalEvent build() {
            OperationalEvent event = new OperationalEvent(this.source);
            event.setCorrelationId(this.correlationId);
            event.setDescription(this.description);
            event.setType(this.type);
            event.setStatus(this.status);
            // Set other fields
            return event;
        }
    }
}",        private String description;,ChatGPT
AvoidFieldNameMatchingMethodName,Field status has the same name as a method,"import org.springframework.context.ApplicationEvent;

public class OperationalEvent extends TrackedEvent {

    private OperationType type;
    private OperationStatus status;
    // ... several more fields here

    // Private constructor to prevent direct instantiation
    private OperationalEvent(Object source) {
        super(source);
    }

    public static OperationalEventBuilder builder(Object source) {
        return new OperationalEventBuilder(source);
    }

    public static class OperationalEventBuilder {
        private final Object source;
        private String correlationId;
        private String description;
        private OperationType type;
        private OperationStatus status;
        // ... other fields

        private OperationalEventBuilder(Object source) {
            this.source = source;
        }

        public OperationalEventBuilder description(String description) {
            this.description = description;
            return this;
        }

        public OperationalEventBuilder status(OperationStatus status) {
            this.status = status;
            return this;
        }

        // Other builder methods for additional fields

        public OperationalEvent build() {
            OperationalEvent event = new OperationalEvent(this.source);
            event.setCorrelationId(this.correlationId);
            event.setDescription(this.description);
            event.setType(this.type);
            event.setStatus(this.status);
            // Set other fields
            return event;
        }
    }
}",        private OperationStatus status;,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.Random;
import java.util.Scanner;
import java.util.function.BinaryOperator;

public class CalculatorProgram {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();

        // Define an array of binary operators
        BinaryOperator<Integer>[] operators = new BinaryOperator[]{
                (a, b) -> a + b,  // Addition
                (a, b) -> a - b,  // Subtraction
                (a, b) -> a * b,  // Multiplication
                (a, b) -> a / b   // Division (integer division)
        };

        // Main loop for asking questions
        for (int i = 0; i < 10; i++) {
            int num1 = random.nextInt(10);
            int num2 = random.nextInt(10);
            BinaryOperator<Integer> operator = operators[random.nextInt(operators.length)];
            System.out.print(""What is "" + num1 + "" "" + getOperatorSymbol(operator) + "" "" + num2 + ""? "");
            int userAnswer = scanner.nextInt();
            int correctAnswer = operator.apply(num1, num2);
            if (userAnswer == correctAnswer) {
                System.out.println(""Correct!"");
            } else {
                System.out.println(""Incorrect. The correct answer is: "" + correctAnswer);
            }
        }

        // Ask if the player wants to continue
        System.out.print(""Do you want to continue? (yes/no): "");
        String choice = scanner.next();
        if (!choice.equalsIgnoreCase(""yes"")) {
            System.out.println(""Thanks for playing!"");
        }
    }

    // Helper method to get the symbol of the operator
    private static String getOperatorSymbol(BinaryOperator<Integer> operator) {
        if (operator == (a, b) -> a + b) return ""+"";
        if (operator == (a, b) -> a - b) return ""-"";
        if (operator == (a, b) -> a * b) return ""*"";
        if (operator == (a, b) -> a / b) return ""/"";
        return ""?"";
    }
}",        Scanner scanner = new Scanner(System.in);,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.BufferedInputStream;
import java.util.Scanner;

public class Main {
    
    public static long binomialCoefficientMod(long n, long k, long m) {
        if (k == 0 || k == n) {
            return 1;
        }
        
        // Initialize result
        long res = 1;
        
        // Since C(n, k) = C(n, n-k), we choose the smaller value of k
        if (k > n - k) {
            k = n - k;
        }
        
        // Calculate C(n, k) using multiplicative formula
        for (long i = 0; i < k; i++) {
            res *= (n - i);
            res /= (i + 1);
            res %= m; // Apply modulus after each multiplication
        }
        
        return res;
    }

    public static void main(String[] args) {
        // Declarations
        long n, k;
        long m = (long) Math.pow(10, 9) + 7; // modulus
        long c;

        // Input
        Scanner reader = new Scanner(new BufferedInputStream(System.in));
        n = reader.nextLong();
        k = reader.nextLong();

        // Calculations
        c = binomialCoefficientMod(n, k, m);

        // Output
        System.out.println(c);
    }
}",        Scanner reader = new Scanner(new BufferedInputStream(System.in));,ChatGPT
NullAssignment,Assigning an Object to null is a code smell.  Consider refactoring.,"public class LinkedListM {
    Node head;
    Node tail; // Add tail pointer

    class Node {
        Node next;
        int value;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    public void add(int value) {
        Node node = new Node(value);
        if (head == null) {
            head = node;
            tail = node; // Update tail when adding the first node
        } else {
            tail.next = node; // Append the new node to the end
            tail = node; // Update tail to the new node
        }
    }

    public void remove(int value) {
        if (head == null) {
            return; // Empty list, nothing to remove
        }
        // Remove nodes with the given value
        Node dummy = new Node(0);
        dummy.next = head;

        while (dummy.next != null) {
            if (dummy.next.value == value) {
                if (dummy.next == tail) {
                    tail = dummy; // Update tail if removing the last node
                }
                dummy.next = dummy.next.next;
            } else {
                dummy = dummy.next;
            }
        }
        // Update head if needed
        head = dummy.next;
    }

    public void printList() {
        Node current = head;
        while (current != null) {
            System.out.print(current.value + "" -> "");
            current = current.next;
        }
        System.out.println(""null"");
    }
}

public class p {
    public static void main(String[] args) {
        LinkedListM ll = new LinkedListM();
        ll.add(1);
        ll.add(2);
        ll.add(3);
        ll.add(4);
        ll.add(5);

        ll.printList();
    }
}",            this.next = null;,ChatGPT
CompareObjectsWithEquals,Use equals() to compare object references.,"public class LinkedListM {
    Node head;
    Node tail; // Add tail pointer

    class Node {
        Node next;
        int value;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    public void add(int value) {
        Node node = new Node(value);
        if (head == null) {
            head = node;
            tail = node; // Update tail when adding the first node
        } else {
            tail.next = node; // Append the new node to the end
            tail = node; // Update tail to the new node
        }
    }

    public void remove(int value) {
        if (head == null) {
            return; // Empty list, nothing to remove
        }
        // Remove nodes with the given value
        Node dummy = new Node(0);
        dummy.next = head;

        while (dummy.next != null) {
            if (dummy.next.value == value) {
                if (dummy.next == tail) {
                    tail = dummy; // Update tail if removing the last node
                }
                dummy.next = dummy.next.next;
            } else {
                dummy = dummy.next;
            }
        }
        // Update head if needed
        head = dummy.next;
    }

    public void printList() {
        Node current = head;
        while (current != null) {
            System.out.print(current.value + "" -> "");
            current = current.next;
        }
        System.out.println(""null"");
    }
}

public class p {
    public static void main(String[] args) {
        LinkedListM ll = new LinkedListM();
        ll.add(1);
        ll.add(2);
        ll.add(3);
        ll.add(4);
        ll.add(5);

        ll.printList();
    }
}",                if (dummy.next == tail) {,ChatGPT
TestClassWithoutTestCases,"The class 'MyServiceTest' might be a test class, but it contains no test cases.","import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class MyServiceTest {

    @InjectMocks
    private MyService myService;

    private final String USER = ""fakeuser"";

    @DisplayName(""unlockFailed should handle ExecutionException"")
    @Test
    public void unlockFailed_should_handle_ExecutionException() throws ExecutionException {
        // Arrange
        LoadingCache<String, Integer> attemptsCache = CacheBuilder.newBuilder()
                .expireAfterWrite(1, TimeUnit.HOURS)
                .build(new CacheLoader<String, Integer>() {
                    @Override
                    public Integer load(String key) throws Exception {
                        return 0;
                    }
                });

        MyService myServiceSpy = spy(myService);
        Whitebox.setInternalState(myServiceSpy, ""attemptsCache"", attemptsCache); // Inject the attemptsCache manually

        doThrow(new ExecutionException(""Dummy ExecutionException"", null)).when(attemptsCache).get(USER);

        // Act
        myServiceSpy.unlockFailed(USER);

        // Assert
        verify(myServiceSpy, times(1)).unlockFailed(USER);
    }
}",public class MyServiceTest {,ChatGPT
TestClassWithoutTestCases,"The class 'TestWatcherExtension' might be a test class, but it contains no test cases.","import org.junit.jupiter.api.extension.*;

public class TestWatcherExtension implements BeforeEachCallback, AfterEachCallback {

    @Override
    public void beforeEach(ExtensionContext context) throws Exception {
        System.out.println(""STARTING test: "" + context.getDisplayName());
    }

    @Override
    public void afterEach(ExtensionContext context) throws Exception {
        System.out.println(""FINISHED test: "" + context.getDisplayName());
    }
}","public class TestWatcherExtension implements BeforeEachCallback, AfterEachCallback {",ChatGPT
TestClassWithoutTestCases,"The class 'IntegrationTest' might be a test class, but it contains no test cases.","@TestPropertySource(properties = {""spring.application.environment=dev""})
@SpringBootTest
class IntegrationTest {

    @Autowired
    PropertyConfig propertyConfig;

    @Nested
    @SpringBootTest
    class ServerLoadConfiguration {

        @Autowired
        PropertyConfig propertyConfig;

        @Test
        void exampleTest() {
            String someProperty = propertyConfig.getSomeProperty(); // overridden value
            // ...
        }
    }
}",class IntegrationTest {,ChatGPT
CloseResource,Ensure that resources like this ScheduledExecutorService object are closed after use,"import java.util.concurrent.*;

public class TimeoutExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = new CompletableFuture<>();
        // Set a default value in case of timeout
        String defaultValue = ""Default Value"";
        
        // Create a ScheduledExecutorService
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

        // Schedule a task to complete the future with a default value after a timeout
        long timeout = 2; // Timeout value in seconds
        executor.schedule(() -> {
            if (!future.isDone()) {
                future.complete(defaultValue);
            }
        }, timeout, TimeUnit.SECONDS);

        // Simulate an asynchronous task
        simulateAsyncTask(future);
        
        // Get the result from the future
        future.thenAccept(result -> {
            System.out.println(""Result: "" + result);
            executor.shutdown(); // Shutdown the executor when done
        });
    }

    // Simulate an asynchronous task
    private static void simulateAsyncTask(CompletableFuture<String> future) {
        new Thread(() -> {
            try {
                // Simulate a long-running task
                Thread.sleep(3000);
                future.complete(""Actual Result"");
            } catch (InterruptedException e) {
                future.completeExceptionally(e);
            }
        }).start();
    }
}",        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        Scanner gimmiethetxtplz = null;
        try {
            gimmiethetxtplz = new Scanner(new File(""cars.txt""));
        } catch (FileNotFoundException e) {
            e.printStackTrace(); // Print the stack trace for debugging
            return; // Exit the program gracefully
        }

        int rows = input.nextInt();
        int columns = input.nextInt();
        String[][] cars = new String[rows][columns];

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                cars[i][j] = gimmiethetxtplz.nextLine();
                System.out.print(cars[i][j] + "" "");
            }
            System.out.println();
        }

        input.close();
        gimmiethetxtplz.close(); // Close the scanner for the file
    }
}",        Scanner input = new Scanner(System.in);,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        Scanner gimmiethetxtplz = null;
        try {
            gimmiethetxtplz = new Scanner(new File(""cars.txt""));
        } catch (FileNotFoundException e) {
            e.printStackTrace(); // Print the stack trace for debugging
            return; // Exit the program gracefully
        }

        int rows = input.nextInt();
        int columns = input.nextInt();
        String[][] cars = new String[rows][columns];

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                cars[i][j] = gimmiethetxtplz.nextLine();
                System.out.print(cars[i][j] + "" "");
            }
            System.out.println();
        }

        input.close();
        gimmiethetxtplz.close(); // Close the scanner for the file
    }
}",        Scanner gimmiethetxtplz = null;,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class FunPark {
    private final int climbWallPrice = 10;
    private final int trampoliningPrice = 12;
    private final int waterSlidesPrice = 15;
    
    private boolean enrolledClimbWall = false;
    private boolean enrolledTrampoline = false;
    private boolean enrolledWaterSlide = false;

    public float getTotalPrice() {
        float totalPrice = 0;
        if (enrolledClimbWall) {
            totalPrice += climbWallPrice;
        }
        if (enrolledTrampoline) {
            totalPrice += trampoliningPrice;
        }
        if (enrolledWaterSlide) {
            totalPrice += waterSlidesPrice;
        }
        
        // Calculate discount based on the number of activities enrolled
        int discountPercent = 0;
        int enrolledActivitiesCount = (enrolledClimbWall ? 1 : 0) +
                                      (enrolledTrampoline ? 1 : 0) +
                                      (enrolledWaterSlide ? 1 : 0);
        if (enrolledActivitiesCount == 2) {
            discountPercent = 10;
        } else if (enrolledActivitiesCount == 3) {
            discountPercent = 20;
        }
        
        // Apply discount
        if (discountPercent > 0) {
            totalPrice = applyDiscountTo(totalPrice, discountPercent);
        }
        
        return totalPrice;
    }

    private float applyDiscountTo(float applyTo, int discountInPercent) {
        float discount = (float) discountInPercent / 100;
        float discountValue = applyTo * discount;
        return applyTo - discountValue;
    }

    public void climbWall() {
        enrolledClimbWall = true;
    }

    public void trampoline() {
        enrolledTrampoline = true;
    }

    public void waterSlide() {
        enrolledWaterSlide = true;
    }
}",        if (enrolledActivitiesCount == 2) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class FunPark {
    private final int climbWallPrice = 10;
    private final int trampoliningPrice = 12;
    private final int waterSlidesPrice = 15;
    
    private boolean enrolledClimbWall = false;
    private boolean enrolledTrampoline = false;
    private boolean enrolledWaterSlide = false;

    public float getTotalPrice() {
        float totalPrice = 0;
        if (enrolledClimbWall) {
            totalPrice += climbWallPrice;
        }
        if (enrolledTrampoline) {
            totalPrice += trampoliningPrice;
        }
        if (enrolledWaterSlide) {
            totalPrice += waterSlidesPrice;
        }
        
        // Calculate discount based on the number of activities enrolled
        int discountPercent = 0;
        int enrolledActivitiesCount = (enrolledClimbWall ? 1 : 0) +
                                      (enrolledTrampoline ? 1 : 0) +
                                      (enrolledWaterSlide ? 1 : 0);
        if (enrolledActivitiesCount == 2) {
            discountPercent = 10;
        } else if (enrolledActivitiesCount == 3) {
            discountPercent = 20;
        }
        
        // Apply discount
        if (discountPercent > 0) {
            totalPrice = applyDiscountTo(totalPrice, discountPercent);
        }
        
        return totalPrice;
    }

    private float applyDiscountTo(float applyTo, int discountInPercent) {
        float discount = (float) discountInPercent / 100;
        float discountValue = applyTo * discount;
        return applyTo - discountValue;
    }

    public void climbWall() {
        enrolledClimbWall = true;
    }

    public void trampoline() {
        enrolledTrampoline = true;
    }

    public void waterSlide() {
        enrolledWaterSlide = true;
    }
}",        } else if (enrolledActivitiesCount == 3) {,ChatGPT
CloseResource,Ensure that resources like this ExecutorService object are closed after use,"import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        // Submit tasks for the first group of threads
        for (int i = 0; i < 10; i++) {
            executorService.submit(() -> {
                System.out.println(""First group: "" + Thread.currentThread().getName());
                // Your task logic here
            });
        }

        // Wait for the first group of tasks to complete
        executorService.shutdown();
        while (!executorService.isTerminated()) {
            // Wait
        }

        // Now submit tasks for the second group of threads
        executorService = Executors.newFixedThreadPool(10); // You can adjust the thread pool size as needed
        for (int i = 0; i < 10; i++) { // Change 10 to the desired number of threads for the second group
            executorService.submit(() -> {
                System.out.println(""Second group: "" + Thread.currentThread().getName());
                // Your task logic here
            });
        }

        executorService.shutdown();
    }
}",        ExecutorService executorService = Executors.newFixedThreadPool(10);,ChatGPT
TestClassWithoutTestCases,"The class 'TestRequestInterceptor' might be a test class, but it contains no test cases.","import okhttp3.Interceptor;
import okhttp3.Request;
import okhttp3.Response;

import java.io.IOException;

public class TestRequestInterceptor implements Interceptor {
    private boolean headerAdded = false;

    @Override
    public Response intercept(Chain chain) throws IOException {
        Request request = chain.request();

        // Check if the Authorization header is added
        if (request.header(""Authorization"") != null) {
            headerAdded = true;
        }

        return chain.proceed(request);
    }

    public boolean isHeaderAdded() {
        return headerAdded;
    }
}",public class TestRequestInterceptor implements Interceptor {,ChatGPT
AvoidCatchingThrowable,A catch statement should never catch throwable since it includes errors.,"import java.util.Properties;
import java.util.ResourceBundle;
import java.util.Enumeration;

public enum ApplicationResource {
    CONF_DIR_PATH(""conf.dir.path""),
    DB_NAME(""database.name""),
    FILE_SAVE_PATH(""save.file.path"");

    private final String value;
    private static final String BUNDLE_NAME = ""ApplicationResource"";
    private static final Properties props;

    static {
        try {
            Properties defaults = new Properties();
            initEnvironment(defaults, BUNDLE_NAME);
            props = new Properties(defaults);
            resolveEnvironmentVariables(props);
        } catch (Throwable t) {
            t.printStackTrace();
            throw new RuntimeException(""Error initializing ApplicationResource"", t);
        }
    }

    ApplicationResource(String value) {
        this.value = value;
    }

    private static void initEnvironment(Properties props, String bundleName) {
        ResourceBundle rb = ResourceBundle.getBundle(bundleName);
        Enumeration<?> enu = rb.getKeys();
        while (enu.hasMoreElements()) {
            String key = (String) enu.nextElement();
            String value = rb.getString(key);
            props.setProperty(key, value);
        }
    }

    private static void resolveEnvironmentVariables(Properties props) {
        props.forEach((key, value) -> {
            String resolvedValue = resolveEnvironmentVariablesInValue((String) value);
            props.setProperty((String) key, resolvedValue);
        });
    }

    private static String resolveEnvironmentVariablesInValue(String value) {
        if (value != null && value.contains(""${"")) {
            String resolvedValue = value;
            for (String envVariable : System.getenv().keySet()) {
                String envValue = System.getenv(envVariable);
                resolvedValue = resolvedValue.replace(""${"" + envVariable + ""}"", envValue);
            }
            return resolvedValue;
        }
        return value;
    }

    public String getString() {
        return props.getProperty(value);
    }

    public int getInt() throws NumberFormatException {
        String str = getString();
        if (str == null || str.length() == 0) {
            return 0;
        } else {
            return Integer.parseInt(str);
        }
    }
}",        } catch (Throwable t) {,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.ArrayList;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        
        int row = 2; // example row size
        int col = 3; // example column size

        ArrayList<ArrayList<Integer>> al = new ArrayList<ArrayList<Integer>>();
        int[][] mat = new int[row][col];

        // Input values into the matrix
        for(int i = 0; i < row; i++) {
            for(int j = 0; j < col; j++) {
                mat[i][j] = s.nextInt();
            }
        }

        // Convert each row of the matrix to an ArrayList and add to the outer list
        for(int i = 0; i < row; i++) {
            ArrayList<Integer> rowList = new ArrayList<>();
            for(int j = 0; j < col; j++) {
                rowList.add(mat[i][j]);
            }
            al.add(rowList);
        }

        // Print the ArrayList of ArrayLists
        System.out.println(al);
    }
}",        Scanner s = new Scanner(System.in);,ChatGPT
AvoidFieldNameMatchingMethodName,Field charsIndex has the same name as a method,"import java.util.*;

public class Main {
    private static final String text = ""Hello Word!"";
    static Map<String, List<Integer>> charsIndex = new HashMap<>();

    public static void main(String[] args) {
        charsIndex();
        charsToString();
    }

    static void charsIndex() {
        List<Character> charsList = text
                .chars()
                .mapToObj(e -> (char) e)
                .toList();
        System.out.println(charsList);

        int position = 0;
        for (Character c : charsList) {
            if (!c.toString().isBlank()) {
                charsIndex.computeIfAbsent(c.toString(), addCharPosition -> new ArrayList<>()).add(position);
            }
            position += 1;
        }

        System.out.println(charsIndex);
    }

    static void charsToString() {
        StringBuilder stringBuilder = new StringBuilder();
        charsIndex.keySet().stream()
                .sorted()
                .forEach(character -> {
                    List<Integer> positions = charsIndex.get(character);
                    positions.forEach(position -> {
                        stringBuilder.insert(position, character);
                    });
                });

        System.out.println(""Rebuilt Word: "" + stringBuilder.toString());
    }
}","    static Map<String, List<Integer>> charsIndex = new HashMap<>();",ChatGPT
ReturnEmptyCollectionRatherThanNull,Return an empty collection rather than null.,"import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class CSVUtil {

    public ByteArrayInputStream dataToCSV(List<?> dataList, char delimiter) {
        try (ByteArrayOutputStream out = new ByteArrayOutputStream();
             PrintWriter printWriter = new PrintWriter(out)) {

            final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(delimiter);
            CSVPrinter csvPrinter = new CSVPrinter(printWriter, format.withQuote(null));

            if (!dataList.isEmpty()) {
                // Write headers
                csvPrinter.printRecord(getHeaders(dataList.get(0)));

                // Write data records
                for (Object object : dataList) {
                    List<String> data = getRecordData(object);
                    csvPrinter.printRecord(data);
                }
            }

            csvPrinter.flush();
            return new ByteArrayInputStream(out.toByteArray());

        } catch (IOException e) {
            throw new RuntimeException(""Error converting data to CSV"", e);
        }
    }

    private List<String> getHeaders(Object object) {
        // Implement logic to get headers from object
        return null;
    }

    private List<String> getRecordData(Object object) {
        // Implement logic to get data for each record from object
        return null;
    }

    private String formatDate(LocalDateTime dateTime) {
        // Custom date/time format
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""MM-dd-yyyy HH:mm:ss.SSSSSS"");
        return dateTime.format(formatter);
    }
}",        return null;,ChatGPT
ReturnEmptyCollectionRatherThanNull,Return an empty collection rather than null.,"import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class CSVUtil {

    public ByteArrayInputStream dataToCSV(List<?> dataList, char delimiter) {
        try (ByteArrayOutputStream out = new ByteArrayOutputStream();
             PrintWriter printWriter = new PrintWriter(out)) {

            final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(delimiter);
            CSVPrinter csvPrinter = new CSVPrinter(printWriter, format.withQuote(null));

            if (!dataList.isEmpty()) {
                // Write headers
                csvPrinter.printRecord(getHeaders(dataList.get(0)));

                // Write data records
                for (Object object : dataList) {
                    List<String> data = getRecordData(object);
                    csvPrinter.printRecord(data);
                }
            }

            csvPrinter.flush();
            return new ByteArrayInputStream(out.toByteArray());

        } catch (IOException e) {
            throw new RuntimeException(""Error converting data to CSV"", e);
        }
    }

    private List<String> getHeaders(Object object) {
        // Implement logic to get headers from object
        return null;
    }

    private List<String> getRecordData(Object object) {
        // Implement logic to get data for each record from object
        return null;
    }

    private String formatDate(LocalDateTime dateTime) {
        // Custom date/time format
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""MM-dd-yyyy HH:mm:ss.SSSSSS"");
        return dateTime.format(formatter);
    }
}",        return null;,ChatGPT
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","public class Test {
    public void launch() {
        Event.register(Test::test);
    }

    public static Unit test(Value data) {
        System.out.println(""Hello world!"");
        return Unit.INSTANCE;
    }
}",public class Test {,ChatGPT
CloseResource,Ensure that resources like this InputStream object are closed after use,"import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

public class Main {
    public static void main(String[] args) {
        try {
            // Connect to the website and get the HTML document
            String url = ""YOUR_WEBSITE_URL_HERE"";
            Document document = Jsoup.connect(url).get();

            // Select all audio elements with class 'daud'
            for (Element element : document.select(""span[class='daud']>audio"")) {
                // Get the source URL of the audio file
                String audioUrl = element.attr(""src"");
                
                // Download the audio file
                downloadFile(audioUrl);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void downloadFile(String fileUrl) {
        try {
            // Open a connection to the file URL
            URL url = new URL(fileUrl);
            URLConnection connection = url.openConnection();

            // Get the file name from the URL
            String fileName = fileUrl.substring(fileUrl.lastIndexOf(""/"") + 1);

            // Get the input stream from the connection
            InputStream inputStream = connection.getInputStream();

            // Create a file output stream
            FileOutputStream outputStream = new FileOutputStream(fileName);

            // Read data from the input stream and write it to the output stream
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }

            // Close the streams
            inputStream.close();
            outputStream.close();

            System.out.println(""File downloaded: "" + fileName);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            InputStream inputStream = connection.getInputStream();,ChatGPT
CloseResource,Ensure that resources like this FileOutputStream object are closed after use,"import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

public class Main {
    public static void main(String[] args) {
        try {
            // Connect to the website and get the HTML document
            String url = ""YOUR_WEBSITE_URL_HERE"";
            Document document = Jsoup.connect(url).get();

            // Select all audio elements with class 'daud'
            for (Element element : document.select(""span[class='daud']>audio"")) {
                // Get the source URL of the audio file
                String audioUrl = element.attr(""src"");
                
                // Download the audio file
                downloadFile(audioUrl);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void downloadFile(String fileUrl) {
        try {
            // Open a connection to the file URL
            URL url = new URL(fileUrl);
            URLConnection connection = url.openConnection();

            // Get the file name from the URL
            String fileName = fileUrl.substring(fileUrl.lastIndexOf(""/"") + 1);

            // Get the input stream from the connection
            InputStream inputStream = connection.getInputStream();

            // Create a file output stream
            FileOutputStream outputStream = new FileOutputStream(fileName);

            // Read data from the input stream and write it to the output stream
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }

            // Close the streams
            inputStream.close();
            outputStream.close();

            System.out.println(""File downloaded: "" + fileName);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            FileOutputStream outputStream = new FileOutputStream(fileName);,ChatGPT
AssignmentInOperand,Avoid assignments in operands,"import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

public class Main {
    public static void main(String[] args) {
        try {
            // Connect to the website and get the HTML document
            String url = ""YOUR_WEBSITE_URL_HERE"";
            Document document = Jsoup.connect(url).get();

            // Select all audio elements with class 'daud'
            for (Element element : document.select(""span[class='daud']>audio"")) {
                // Get the source URL of the audio file
                String audioUrl = element.attr(""src"");
                
                // Download the audio file
                downloadFile(audioUrl);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void downloadFile(String fileUrl) {
        try {
            // Open a connection to the file URL
            URL url = new URL(fileUrl);
            URLConnection connection = url.openConnection();

            // Get the file name from the URL
            String fileName = fileUrl.substring(fileUrl.lastIndexOf(""/"") + 1);

            // Get the input stream from the connection
            InputStream inputStream = connection.getInputStream();

            // Create a file output stream
            FileOutputStream outputStream = new FileOutputStream(fileName);

            // Read data from the input stream and write it to the output stream
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }

            // Close the streams
            inputStream.close();
            outputStream.close();

            System.out.println(""File downloaded: "" + fileName);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            while ((bytesRead = inputStream.read(buffer)) != -1) {,ChatGPT
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}",public class Test {,ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}",    public class TestPane extends JPanel {,ChatGPT
TestClassWithoutTestCases,"The class 'TestPane' might be a test class, but it contains no test cases.","import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}",    public class TestPane extends JPanel {,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JComponent.setBorder(Border) ,"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}","            setBorder(new EmptyBorder(16, 16, 16, 16));",ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Container.setLayout(LayoutManager) ,"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}",            setLayout(new GridBagLayout());,ChatGPT
DoNotTerminateVM,System.exit() should not be used in J2EE/JEE apps,"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}",                    System.exit(1);,ChatGPT
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}","            add(enterClassPane, gbc);",ChatGPT
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}","            add(new JScrollPane(panelCheckBox), gbc);",ChatGPT
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}","            add(classPane, gbc);",ChatGPT
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Container.add(Component, Object) ","import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}","            add(actionsPane, gbc);",ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}",    public class WrapLayout extends FlowLayout {,ChatGPT
AvoidFieldNameMatchingMethodName,Field preferredLayoutSize has the same name as a method,"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;

public class Test {

    public static void main(String[] args) {
        new Test();
    }

    public Test() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame frame = new JFrame();
                frame.add(new TestPane());
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TestPane extends JPanel {

        private Set<String> selectedValues = new HashSet<>(8);

        public TestPane() {
            setBorder(new EmptyBorder(16, 16, 16, 16));
            setLayout(new GridBagLayout());

            JTextField textField = new JTextField(40);

            JPanel panelCheckBox = new JPanel(new WrapLayout(WrapLayout.LEADING));

            JRadioButton yes = new JRadioButton(""Yes"");
            yes.setSelected(true);
            yes.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (yes.isSelected()) {
                        textField.setEnabled(true);
                        enableCheckboxes(panelCheckBox, false);
                    }
                }
            });

            JRadioButton no = new JRadioButton(""No"");
            no.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    if (no.isSelected()) {
                        textField.setText("""");
                        textField.setEnabled(false);
                        enableCheckboxes(panelCheckBox, true);
                    }
                }
            });

            ButtonGroup bg = new ButtonGroup();
            bg.add(yes);
            bg.add(no);

            JPanel enterClassPane = new JPanel(new GridBagLayout());
            enterClassPane.setBorder(new TitledBorder(null, ""Enter Your MetaClass"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            enterClassPane.add(yes);
            enterClassPane.add(no);

            int numberCheckBox = 10;
            JCheckBox[] checkBoxList = new JCheckBox[numberCheckBox];

            for (int i = 0; i < numberCheckBox; i++) {
                checkBoxList[i] = new JCheckBox(""Diagram "" + i);
                panelCheckBox.add(checkBoxList[i]);

                checkBoxList[i].addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        System.out.println(""Selected Diagram "" + e.getActionCommand());
                        if (e.getSource() instanceof JCheckBox) {
                            JCheckBox cb = (JCheckBox) e.getSource();
                            if (cb.isSelected()) {
                                selectedValues.add(cb.getActionCommand());
                            } else {
                                selectedValues.remove(cb.getActionCommand());
                            }
                        }
                    }
                });
            }

            JPanel classPane = new JPanel(new GridBagLayout());
            classPane.setBorder(new TitledBorder(null, ""Enter Meta Class"", TitledBorder.LEADING, TitledBorder.TOP, null, null));
            classPane.add(textField);

            JPanel actionsPane = new JPanel(new GridBagLayout());
            JButton btnCancel = new JButton(""Cancel"");
            btnCancel.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.exit(1);
                }
            });
            JButton btnOkay = new JButton(""Okay"");
            btnOkay.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    System.out.println(textField.getText());
                    for (String command : selectedValues) {
                        System.out.println(command);
                    }
                }
            });
            actionsPane.add(btnOkay);
            actionsPane.add(btnCancel);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.insets = new Insets(4, 4, 4, 4);
            gbc.gridwidth = gbc.REMAINDER;
            gbc.fill = gbc.HORIZONTAL;

            add(enterClassPane, gbc);
            add(new JScrollPane(panelCheckBox), gbc);
            add(classPane, gbc);
            add(actionsPane, gbc);
        }

        private void enableCheckboxes(Container container, boolean enabled) {
            Component[] components = container.getComponents();
            for (Component component : components) {
                if (component instanceof JCheckBox) {
                    component.setEnabled(enabled);
                }
            }
        }
    }

    public class WrapLayout extends FlowLayout {

        private Dimension preferredLayoutSize;

        public WrapLayout() {
            super();
        }

        public WrapLayout(int align) {
            super(align);
        }

        public WrapLayout(int align, int hgap, int vgap) {
            super(align, hgap, vgap);
        }

        @Override
        public Dimension preferredLayoutSize(Container target) {
            return layoutSize(target, true);
        }

        @Override
        public Dimension minimumLayoutSize(Container target) {
            Dimension minimum = layoutSize(target, false);
            minimum.width -= (getHgap() + 1);
            return minimum;
        }

        private Dimension layoutSize(Container target, boolean preferred) {
            synchronized (target.getTreeLock()) {

                int targetWidth = target.getSize().width;
                Container container = target;

                while (container.getSize().width == 0 && container.getParent() != null) {
                    container = container.getParent();
                }

                targetWidth = container.getSize().width;

                if (targetWidth == 0) {
                    targetWidth = Integer.MAX_VALUE;
                }

                int hgap = getHgap();
                int vgap = getVgap();
                Insets insets = target.getInsets();
                int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
                int maxWidth = targetWidth - horizontalInsetsAndGap;

                Dimension dim = new Dimension(0, 0);
                int rowWidth = 0;
                int rowHeight = 0;

                int nmembers = target.getComponentCount();

                for (int i = 0; i < nmembers; i++) {
                    Component m = target.getComponent(i);

                    if (m.isVisible()) {
                        Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

                        if (rowWidth + d.width > maxWidth) {
                            addRow(dim, rowWidth, rowHeight);
                            rowWidth = 0;
                            rowHeight = 0;
                        }

                        if (rowWidth != 0) {
                            rowWidth += hgap;
                        }

                        rowWidth += d.width;
                        rowHeight = Math.max(rowHeight, d.height);
                    }
                }

                addRow(dim, rowWidth, rowHeight);

                dim.width += horizontalInsetsAndGap;
                dim.height += insets.top + insets.bottom + vgap * 2;

                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

                if (scrollPane != null && target.isValid()) {
                    dim.width -= (hgap + 1);
                }

                return dim;
            }
        }

        private void addRow(Dimension dim, int rowWidth, int rowHeight) {
            dim.width = Math.max(dim.width, rowWidth);

            if (dim.height > 0) {
                dim.height += getVgap();
            }

            dim.height += rowHeight;
        }
    }
}",        private Dimension preferredLayoutSize;,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.Scanner; // Corrected 'import java.until.Scanner;' to 'import java.util.Scanner;'

public class ShoppingCartPrinter {
    // main method
    public static void main(String[] args) {
        // create object of scanner
        Scanner scnr = new Scanner(System.in);
        // variable declaration
        int i = 0;
        String productName;
        int productPrice = 0;
        int productQuantity = 0;
        int cartTotal = 0;

        ItemToPurchase item1 = new ItemToPurchase();
        ItemToPurchase item2 = new ItemToPurchase();

        // get item 1 details
        System.out.println(""Item 1"");

        System.out.println(""Enter the item name: "");
        productName = scnr.nextLine();
        item1.setName(productName);

        System.out.println(""Enter the item price: "");
        productPrice = scnr.nextInt();
        item1.setPrice(productPrice);
        scnr.nextLine();

        System.out.println(""Enter the item quantity: "");
        productQuantity = scnr.nextInt();
        item1.setQuantity(productQuantity);
        scnr.nextLine();

        scnr.nextLine();
        System.out.println("""");

        // get item 2 details
        System.out.println(""Item 2"");

        System.out.println(""Enter the item name: "");
        productName = scnr.nextLine();
        item2.setName(productName);

        System.out.println(""Enter the item price: "");
        productPrice = scnr.nextInt();
        item2.setPrice(productPrice);
        scnr.nextLine();

        System.out.println(""Enter the item quantity: "");
        productQuantity = scnr.nextInt();
        item2.setQuantity(productQuantity);
        scnr.nextLine();

        System.out.println("""");

        // add cost of item 1 and 2 and print total
        cartTotal = (item1.getQuantity() * item1.getPrice()) + (item2.getQuantity() * item2.getPrice());
        System.out.println(""TOTAL COST"");
        // cart total is item 1 price * quantity + item 2 price * quantity
        // item 1 info
        int item1Total = item1.getPrice() * item1.getQuantity();
        System.out.println(item1.getName() + "" "" + item1.getQuantity() + "" @ $"" + item1.getPrice() + "" = $"" + item1Total);

        // item 2 info
        int item2Total = item2.getPrice() * item2.getQuantity();
        System.out.println(item2.getName() + "" "" + item2.getQuantity() + "" @ $"" + item2.getPrice() + "" = $"" + item2Total);

        // output total
        System.out.println("""");
        System.out.print(""Total: $"" + cartTotal);
    } // Added closing curly brace to close the main method

} // Added closing curly brace to close the class definition",        Scanner scnr = new Scanner(System.in);,ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}",public class Wordle extends JFrame implements ActionListener {,ChatGPT
ConstructorCallsOverridableMethod,"Overridable method called during object construction: Window.setSize(int, int) ","import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}","        setSize(500, 300);",ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.setDefaultCloseOperation(int) ,"import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}",        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.getContentPane() ,"import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}",        getContentPane().setLayout(new BorderLayout());,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.getContentPane() ,"import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}","        getContentPane().add(p1, BorderLayout.NORTH);",ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.getContentPane() ,"import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}","        getContentPane().add(p2, BorderLayout.SOUTH);",ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setVisible(boolean) ,"import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}",        setVisible(true);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}",            if (currentCol < 5) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Wordle extends JFrame implements ActionListener {
    private JPanel p1;
    private JPanel p2;
    private JTextField[][] g;
    private int currentRow = 0;
    private int currentCol = 0;

    public Wordle() {
        setSize(500, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        p1 = new JPanel();
        p1.setLayout(new GridLayout(6, 5));
        g = new JTextField[6][5];
        for (int r = 0; r < g.length; r++) {
            for (int c = 0; c < g[r].length; c++) {
                g[r][c] = new JTextField();
                p1.add(g[r][c]);
            }
        }

        p2 = new JPanel();
        p2.setLayout(new GridLayout(4, 7));
        for (char ch = 'A'; ch <= 'Z'; ch++) {
            JButton button = new JButton(String.valueOf(ch));
            button.addActionListener(this);
            p2.add(button);
        }
        JButton backspace = new JButton(""<-"");
        backspace.addActionListener(this);
        p2.add(backspace);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(p1, BorderLayout.NORTH);
        getContentPane().add(p2, BorderLayout.SOUTH);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(""<-"")) { // Backspace button
            if (currentCol > 0) {
                currentCol--;
                g[currentRow][currentCol].setText("""");
            } else if (currentRow > 0) {
                currentRow--;
                currentCol = 4;
                g[currentRow][currentCol].setText("""");
            }
        } else { // Letter buttons
            char letter = e.getActionCommand().charAt(0);
            if (currentCol < 5) {
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            } else if (currentRow < 5) {
                currentRow++;
                currentCol = 0;
                g[currentRow][currentCol].setText(String.valueOf(letter));
                currentCol++;
            }
        }
    }

    public static void main(String[] args) {
        new Wordle();
    }
}",            } else if (currentRow < 5) {,ChatGPT
ReturnEmptyCollectionRatherThanNull,Return an empty collection rather than null.,"import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;

public class SetDeserializer extends JsonDeserializer<Set<?>> {

    @Override
    public Set<?> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        JsonNode node = p.readValueAsTree();
        if (node == null || node.isNull() || node.isEmpty()) {
            return null;
        }
        
        Set<Object> set = new HashSet<>();
        for (JsonNode elementNode : node) {
            // Deserialize each element and add it to the set
            // You may need to use ObjectMapper to deserialize the elements, depending on their types
            // For simplicity, assuming all elements are strings
            set.add(elementNode.asText());
        }
        return set;
    }
}",            return null;,ChatGPT
EmptyCatchBlock,Avoid empty catch blocks,"import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Component
public class ScheduledTask {

    private final MyAsyncService service;

    public ScheduledTask(MyAsyncService service) {
        this.service = service;
    }

    @Scheduled(fixedRate = 300000) // Run every 5 minutes
    public void processTask() {
        List<CompletableFuture<Integer>> futures = new ArrayList<>();
        List<Integer> successTasks = new ArrayList<>();
        List<Integer> failedTasks = new ArrayList<>();

        for (int i = 0; i < 1000; i++) {
            futures.add(service.performTask(i).exceptionally(ex -> {
                failedTasks.add(i);
                return -1; // Return a dummy value for failed task
            }));
        }

        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        for (CompletableFuture<Integer> future : futures) {
            try {
                Integer result = future.get(); // This will throw an exception if the task failed
                if (result != -1) { // Check if the task failed or succeeded
                    successTasks.add(result);
                }
            } catch (Exception e) {
                // Exception occurred, task failed
            }
        }

        System.out.println(""Success tasks: "" + successTasks);
        System.out.println(""Failed tasks: "" + failedTasks);
    }
}","            } catch (Exception e) {
                // Exception occurred, task failed
            }",ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.AbstractMap;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Comparator;

public class HashPriorityQueue<K, V> extends HashMap<K, V> implements Iterable<AbstractMap.SimpleEntry<K, V>> {
    private final PriorityQueue<K> queue;
    private int modCount = 0;

    /* CONSTRUCTORS */

    public HashPriorityQueue(Comparator<K> comparator) {
        queue = new PriorityQueue<>(comparator);
    }

    public HashPriorityQueue() {
        queue = new PriorityQueue<>();
    }

    /* QUEUE METHODS */

    public AbstractMap.SimpleEntry<K, V> poll() {
        K key = queue.poll();
        V val = remove(key);
        return new AbstractMap.SimpleEntry<>(key, val);
    }

    public AbstractMap.SimpleEntry<K, V> peek() {
        K key = queue.peek();
        V val = get(key);
        return new AbstractMap.SimpleEntry<>(key, val);
    }

    @Override
    public V remove(Object key) {
        queue.remove(key);
        modCount++;
        return super.remove(key);
    }

    @Override
    public V put(K key, V value) {
        queue.add(key);
        modCount++;
        return super.put(key, value);
    }

    @Override
    public Iterator<AbstractMap.SimpleEntry<K, V>> iterator() {
        return new PriorityIterator();
    }

    private class PriorityIterator implements Iterator<AbstractMap.SimpleEntry<K, V>> {
        private final int expectedModCount = modCount;
        private final PriorityQueue<K> keys = new PriorityQueue<>(queue);
        private K cursor;

        @Override
        public boolean hasNext() {
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            return !keys.isEmpty();
        }

        @Override
        public AbstractMap.SimpleEntry<K, V> next() {
            if (!hasNext()) {
                throw new IllegalStateException(""No more elements to iterate"");
            }
            cursor = keys.poll();
            V v = HashPriorityQueue.this.get(cursor);
            return new AbstractMap.SimpleEntry<>(cursor, v);
        }

        @Override
        public void remove() {
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            HashPriorityQueue.this.remove(cursor);
            modCount++;
        }
    }
}","public class HashPriorityQueue<K, V> extends HashMap<K, V> implements Iterable<AbstractMap.SimpleEntry<K, V>> {",ChatGPT
TestClassWithoutTestCases,"The class 'FlagsmithGatewayTest' might be a test class, but it contains no test cases.","import static org.mockito.Mockito.when;

// Your imports...

@ExtendWith(MockitoExtension.class)
public class FlagsmithGatewayTest {

    private FlagsmithGateway flagsmithGateway;

    @Mock
    private FlagsmithClient flagsmithClient;

    @BeforeEach
    public void setup() {
        flagsmithGateway = new FlagsmithGateway(flagsmithClient);
    }

    @Test
    public void isEnabled_shouldReturnWhetherFeatureIsEnabled() throws FlagsmithClientError {
        // Setup the behavior of the mocked FlagsmithClient
        Flags flags = setupFlags(""test_toggle"", true);
        when(flagsmithClient.getEnvironmentFlags()).thenReturn(flags);

        // Call the method being tested
        boolean result = flagsmithGateway.isEnabled(FeatureFlags.TOGGLE_FOR_TESTS);

        // Verify the result
        assertThat(result).isTrue();
    }

    private static Flags setupFlags(String featureName, Boolean enabled) {
        Flags flag = new Flags();
        BaseFlag baseFlag = new BaseFlag();
        Map<String, BaseFlag> someFlags = new HashMap<>();

        baseFlag.setFeatureName(featureName);
        baseFlag.setEnabled(enabled);
        someFlags.put(featureName, baseFlag);
        flag.setFlags(someFlags);

        return flag;
    }
}",public class FlagsmithGatewayTest {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import org.hibernate.event.spi.PreInsertEvent;
import org.hibernate.event.spi.PreInsertEventListener;

public class CustomPreInsertListener implements PreInsertEventListener {

    @Override
    public boolean onPreInsert(PreInsertEvent event) {
        String[] propertyNames = event.getPersister().getPropertyNames();
        Object[] state = event.getState();
        
        // Modify the state or property values before insertion
        // For example, add additional SQL conditions
        for (int i = 0; i < propertyNames.length; i++) {
            if (""c_deleted"".equals(propertyNames[i])) {
                state[i] = 0;
            }
        }
        
        return false; // Continue with the normal insert operation
    }
}","            if (""c_deleted"".equals(propertyNames[i])) {",ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

public class Main11 {

    public static void main(String[] args) {

        Scanner s = new Scanner(System.in);

        System.out.println(""<Source file> <Words to filter>"");

        String st1 = s.nextLine();

        String[] split1 = st1.split("" "");

        Path p = Paths.get(split1[0]);

        try {

            List<String> lines = Files.readAllLines(p, StandardCharsets.UTF_8);
            List<String> filter = lines;

            for (int i = 0; i < lines.size(); i++) {

                String[] words = lines.get(i).split(""\\s+""); // Splitting line into separate words

                for (int j = 0; j < split1.length; j++) {

                    final int x = j;

                    filter = filter.stream().filter(line -> {
                        for (String word : words) {
                            if (word.equals(split1[x])) {
                                return false; // Remove the line if the word matches
                            }
                        }
                        return true;
                    }).collect(Collectors.toList());

                }
            }

            BufferedWriter writer = Files.newBufferedWriter(p);

            for (int c = 0; c < filter.size(); c++) {
                writer.write(""\n"" + filter.get(c));
            }

            writer.close();

            System.out.println(""Done"");

        } catch (IOException e) {

            System.out.println(""file not found"");
        }

        s.close();

    }

}",        Scanner s = new Scanner(System.in);,ChatGPT
CloseResource,Ensure that resources like this BufferedWriter object are closed after use,"import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

public class Main11 {

    public static void main(String[] args) {

        Scanner s = new Scanner(System.in);

        System.out.println(""<Source file> <Words to filter>"");

        String st1 = s.nextLine();

        String[] split1 = st1.split("" "");

        Path p = Paths.get(split1[0]);

        try {

            List<String> lines = Files.readAllLines(p, StandardCharsets.UTF_8);
            List<String> filter = lines;

            for (int i = 0; i < lines.size(); i++) {

                String[] words = lines.get(i).split(""\\s+""); // Splitting line into separate words

                for (int j = 0; j < split1.length; j++) {

                    final int x = j;

                    filter = filter.stream().filter(line -> {
                        for (String word : words) {
                            if (word.equals(split1[x])) {
                                return false; // Remove the line if the word matches
                            }
                        }
                        return true;
                    }).collect(Collectors.toList());

                }
            }

            BufferedWriter writer = Files.newBufferedWriter(p);

            for (int c = 0; c < filter.size(); c++) {
                writer.write(""\n"" + filter.get(c));
            }

            writer.close();

            System.out.println(""Done"");

        } catch (IOException e) {

            System.out.println(""file not found"");
        }

        s.close();

    }

}",            BufferedWriter writer = Files.newBufferedWriter(p);,ChatGPT
TestClassWithoutTestCases,"The class 'TestClass' might be a test class, but it contains no test cases.","import java.util.*;
import java.util.stream.Collectors;

public class TestClass {
    public static void main(String[] args) {
        TestClass test = new TestClass();
        List<Object[]> resultList = test.buildResultList();

        List<MyBean> beans = helpNeededToConvert(resultList);

        System.out.println(beans);
    }

    private static List<MyBean> helpNeededToConvert(List<Object[]> resultList) {
        Map<Integer, List<Object[]>> idObjectsLookup = resultList.stream()
                .collect(Collectors.groupingBy(o -> (Integer) o[0]));

        return idObjectsLookup.entrySet().stream()
                .map(entry -> {
                    MyBean mb = new MyBean();
                    mb.setId(entry.getKey());
                    mb.setName((String) entry.getValue().get(0)[1]); // Name will be same for all entries with same id
                    Map<String, Object> customAttributes = entry.getValue().stream()
                            .collect(Collectors.toMap(o -> (String) o[2], o -> o[3]));
                    mb.setCustomAttributes(customAttributes);
                    return mb;
                })
                .collect(Collectors.toList());
    }

    private List<Object[]> buildResultList() {
        List<Object[]> resultList = new ArrayList<>();

        resultList.add(new Object[]{1, ""name 1"", ""custom_attr_1"", ""custom_attr_1_val_1""});
        resultList.add(new Object[]{1, ""name 1"", ""custom_attr_2"", ""custom_attr_2_val_1""});
        resultList.add(new Object[]{1, ""name 1"", ""custom_attr_3"", ""custom_attr_3_val_1""});
        resultList.add(new Object[]{2, ""name 2"", ""custom_attr_1"", ""custom_attr_1_val_2""});
        resultList.add(new Object[]{2, ""name 2"", ""custom_attr_2"", ""custom_attr_2_val_2""});
        resultList.add(new Object[]{2, ""name 2"", ""custom_attr_3"", ""custom_attr_3_val_2""});
        resultList.add(new Object[]{3, ""name 3"", ""custom_attr_1"", ""custom_attr_1_val_3""});
        resultList.add(new Object[]{3, ""name 3"", ""custom_attr_2"", ""custom_attr_2_val_3""});
        resultList.add(new Object[]{3, ""name 3"", ""custom_attr_3"", ""custom_attr_3_val_3""});

        return resultList;
    }
}

@Getter @ToString @Builder(toBuilder = true)
class MyBean {
    private Integer id;
    private String name;
    private Map<String, Object> customAttributes;
}",public class TestClass {,ChatGPT
ReturnEmptyCollectionRatherThanNull,Return an empty collection rather than null.,"import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import javax.persistence.AttributeConverter;
import javax.persistence.Converter;
import java.io.IOException;
import java.util.HashSet;

@Converter
public class HashSetDayOfWeekConverter implements AttributeConverter<HashSet<DayOfWeek>, String> {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public String convertToDatabaseColumn(HashSet<DayOfWeek> attribute) {
        try {
            return objectMapper.writeValueAsString(attribute);
        } catch (JsonProcessingException e) {
            // Handle exception
            return null;
        }
    }

    @Override
    public HashSet<DayOfWeek> convertToEntityAttribute(String dbData) {
        try {
            return objectMapper.readValue(dbData, HashSet.class);
        } catch (IOException e) {
            // Handle exception
            return null;
        }
    }
}",            return null;,ChatGPT
ConstructorCallsOverridableMethod,"This method may call an overridable method during object construction: Mainframe.setImagePanel(JPanel) (call stack: [Mainframe.initialize(), Mainframe.setImagePanel(JPanel)])","import java.awt.EventQueue;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;

public class Mainframe {

    private JFrame frmOceanlife;
    private JPanel imagePanel; // Panel to hold the image

    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    Mainframe window = new Mainframe();
                    window.frmOceanlife.setVisible(true);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
    }

    public Mainframe() {
        initialize();
    }

    private void initialize() {
        frmOceanlife = new JFrame();
        frmOceanlife.setTitle(""OceanLife"");
        frmOceanlife.setBounds(100, 100, 750, 600);
        frmOceanlife.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frmOceanlife.getContentPane().setLayout(new FlowLayout()); // Using FlowLayout

        JButton btnNewButton_4 = new JButton(""Quit"");
        frmOceanlife.getContentPane().add(btnNewButton_4);

        btnNewButton_4.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        });

        JButton btnNewButton_5 = new JButton(""EinfÃ¼gen"");
        frmOceanlife.getContentPane().add(btnNewButton_5);

        btnNewButton_5.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                ImageIcon icon = new ImageIcon(""Stone.png"");
                JLabel label = new JLabel(icon);
                getImagePanel().add(label); // Add label to the image panel
                frmOceanlife.getContentPane().revalidate(); // Revalidate the content pane
                frmOceanlife.getContentPane().repaint(); // Repaint the content pane
            }
        });

        // Panel to hold the image
        setImagePanel(new JPanel());
        getImagePanel().setBackground(Color.WHITE);
        getImagePanel().setPreferredSize(new Dimension(600, 450));
        getImagePanel().setLayout(new FlowLayout());
        JLabel piclabel = new JLabel(new ImageIcon(""underwater-600x450.png""));
        getImagePanel().add(piclabel);
        frmOceanlife.getContentPane().add(getImagePanel());

        JLabel lblNewLabel_2 = new JLabel(""Welcome to Oceanlife - Your Ocean size is 600x450!"");
        lblNewLabel_2.setHorizontalAlignment(SwingConstants.CENTER);
        frmOceanlife.getContentPane().add(lblNewLabel_2);

        frmOceanlife.pack(); // Pack the frame to fit the components
    }

    public JPanel getImagePanel() {
        return imagePanel;
    }

    public void setImagePanel(JPanel imagePanel) {
        this.imagePanel = imagePanel;
    }
}",        initialize();,ChatGPT
DoNotTerminateVM,System.exit() should not be used in J2EE/JEE apps,"import java.awt.EventQueue;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;

public class Mainframe {

    private JFrame frmOceanlife;
    private JPanel imagePanel; // Panel to hold the image

    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    Mainframe window = new Mainframe();
                    window.frmOceanlife.setVisible(true);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
    }

    public Mainframe() {
        initialize();
    }

    private void initialize() {
        frmOceanlife = new JFrame();
        frmOceanlife.setTitle(""OceanLife"");
        frmOceanlife.setBounds(100, 100, 750, 600);
        frmOceanlife.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frmOceanlife.getContentPane().setLayout(new FlowLayout()); // Using FlowLayout

        JButton btnNewButton_4 = new JButton(""Quit"");
        frmOceanlife.getContentPane().add(btnNewButton_4);

        btnNewButton_4.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        });

        JButton btnNewButton_5 = new JButton(""EinfÃ¼gen"");
        frmOceanlife.getContentPane().add(btnNewButton_5);

        btnNewButton_5.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                ImageIcon icon = new ImageIcon(""Stone.png"");
                JLabel label = new JLabel(icon);
                getImagePanel().add(label); // Add label to the image panel
                frmOceanlife.getContentPane().revalidate(); // Revalidate the content pane
                frmOceanlife.getContentPane().repaint(); // Repaint the content pane
            }
        });

        // Panel to hold the image
        setImagePanel(new JPanel());
        getImagePanel().setBackground(Color.WHITE);
        getImagePanel().setPreferredSize(new Dimension(600, 450));
        getImagePanel().setLayout(new FlowLayout());
        JLabel piclabel = new JLabel(new ImageIcon(""underwater-600x450.png""));
        getImagePanel().add(piclabel);
        frmOceanlife.getContentPane().add(getImagePanel());

        JLabel lblNewLabel_2 = new JLabel(""Welcome to Oceanlife - Your Ocean size is 600x450!"");
        lblNewLabel_2.setHorizontalAlignment(SwingConstants.CENTER);
        frmOceanlife.getContentPane().add(lblNewLabel_2);

        frmOceanlife.pack(); // Pack the frame to fit the components
    }

    public JPanel getImagePanel() {
        return imagePanel;
    }

    public void setImagePanel(JPanel imagePanel) {
        this.imagePanel = imagePanel;
    }
}",                System.exit(0);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class MySpecificationsBuilder extends BaseSpecification<Student> {

    public MySpecificationsBuilder(final SearchCriteria criteria) {
        super(criteria);
    }

    @Override
    protected Expression<String> getPath(SearchCriteria criteria, Root<Student> root) {
        if (criteria.getKey().equals(""lastRollResult"")) {
            Join<Result, Student> resultsJoin = root.join(""lastRoll"", JoinType.LEFT); // Use LEFT join
            return resultsJoin.get(""result"");
        }
        return root.get(criteria.getKey());
    }

    @Override
    public Predicate toPredicate(Root<Student> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
        if (criteria.getKey().equals(""lastRollResult"")) {
            if (""null"".equals(criteria.getValue())) {
                // Filter where lastRoll is null
                return builder.isNull(root.join(""lastRoll"", JoinType.LEFT).get(""id""));
            } else {
                // Filter where lastRollResult matches the provided value
                return super.toPredicate(root, query, builder);
            }
        }
        return super.toPredicate(root, query, builder);
    }
}","            if (""null"".equals(criteria.getValue())) {",ChatGPT
TestClassWithoutTestCases,"The class 'ProgressIndicatorTableCellTest' might be a test class, but it contains no test cases.","import javafx.application.Application;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.value.ObservableValue;
import javafx.concurrent.Task;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import javafx.util.Callback;

import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ProgressIndicatorTableCellTest extends Application {
    public void start(Stage primaryStage) {
        TableView<TestTask> table = new TableView<>();
        Random rng = new Random();
        for (int i = 0; i < 3; i++) {
            table.getItems().add(new TestTask(rng.nextInt(3000) + 2000, ""Test""));
        }

        TableColumn<TestTask, String> nameCol = new TableColumn<>(""Name"");
        nameCol.setCellValueFactory(new PropertyValueFactory<TestTask, String>(""name""));
        nameCol.setPrefWidth(75);

        TableColumn<TestTask, Double> progressCol = new TableColumn<>(""Progress"");
        progressCol.setCellValueFactory(new PropertyValueFactory<TestTask, Double>(""progress""));
        progressCol.setCellFactory(ProgressIndicatorTableCell.<TestTask>forTableColumn());

        table.getColumns().addAll(nameCol, progressCol);

        BorderPane root = new BorderPane();
        root.setCenter(table);
        Button btn = new Button(""Start"");
        btn.setOnAction(actionEvent -> {
            ExecutorService executor = Executors.newSingleThreadExecutor();

            for (TestTask task : table.getItems()) {
                task.resetProgress(); // Reset progress before resubmitting task
                executor.submit(task);
            }
        });

        root.setBottom(btn);
        primaryStage.setScene(new Scene(root));
        primaryStage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }

    public static class TestTask extends Task<Void> {
        private final int waitTime; // milliseconds
        final ReadOnlyStringWrapper name = new ReadOnlyStringWrapper();
        public static final int NUM_ITERATIONS = 100;

        public TestTask(int waitTime, String name) {
            this.waitTime = waitTime;
            this.name.set(name);
        }

        public ReadOnlyStringProperty nameProperty() {
            return name.getReadOnlyProperty();
        }

        @Override
        protected Void call() throws Exception {
            this.updateProgress(0, 1); // Set progress to 0 initially
            Thread.sleep(waitTime);
            this.updateProgress(1, 1);
            return null;
        }

        public void resetProgress() {
            this.updateProgress(0, 1); // Reset progress to 0
        }
    }
}

class ProgressIndicatorTableCell<S> extends TableCell<S, Double> {
    public static <S> Callback<TableColumn<S, Double>, TableCell<S, Double>> forTableColumn() {
        return new Callback<TableColumn<S, Double>, TableCell<S, Double>>() {
            @Override
            public TableCell<S, Double> call(TableColumn<S, Double> param) {
                return new ProgressIndicatorTableCell<>();
            }
        };
    }

    private final ProgressIndicator progressIndicator;
    private ObservableValue observable;

    public ProgressIndicatorTableCell() {
        this.progressIndicator = new ProgressIndicator();
        setGraphic(progressIndicator);
    }

    @Override
    public void updateItem(Double item, boolean empty) {
        super.updateItem(item, empty);

        if (empty) {
            setGraphic(null);
        } else {
            progressIndicator.progressProperty().unbind();

            observable = getTableColumn().getCellObservableValue(getIndex());
            if (observable != null) {
                progressIndicator.progressProperty().bind(observable);
            } else {
                progressIndicator.setProgress(item);
            }

            setGraphic(progressIndicator);
        }
    }
}",public class ProgressIndicatorTableCellTest extends Application {,ChatGPT
TestClassWithoutTestCases,"The class 'TestTask' might be a test class, but it contains no test cases.","import javafx.application.Application;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.value.ObservableValue;
import javafx.concurrent.Task;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import javafx.util.Callback;

import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ProgressIndicatorTableCellTest extends Application {
    public void start(Stage primaryStage) {
        TableView<TestTask> table = new TableView<>();
        Random rng = new Random();
        for (int i = 0; i < 3; i++) {
            table.getItems().add(new TestTask(rng.nextInt(3000) + 2000, ""Test""));
        }

        TableColumn<TestTask, String> nameCol = new TableColumn<>(""Name"");
        nameCol.setCellValueFactory(new PropertyValueFactory<TestTask, String>(""name""));
        nameCol.setPrefWidth(75);

        TableColumn<TestTask, Double> progressCol = new TableColumn<>(""Progress"");
        progressCol.setCellValueFactory(new PropertyValueFactory<TestTask, Double>(""progress""));
        progressCol.setCellFactory(ProgressIndicatorTableCell.<TestTask>forTableColumn());

        table.getColumns().addAll(nameCol, progressCol);

        BorderPane root = new BorderPane();
        root.setCenter(table);
        Button btn = new Button(""Start"");
        btn.setOnAction(actionEvent -> {
            ExecutorService executor = Executors.newSingleThreadExecutor();

            for (TestTask task : table.getItems()) {
                task.resetProgress(); // Reset progress before resubmitting task
                executor.submit(task);
            }
        });

        root.setBottom(btn);
        primaryStage.setScene(new Scene(root));
        primaryStage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }

    public static class TestTask extends Task<Void> {
        private final int waitTime; // milliseconds
        final ReadOnlyStringWrapper name = new ReadOnlyStringWrapper();
        public static final int NUM_ITERATIONS = 100;

        public TestTask(int waitTime, String name) {
            this.waitTime = waitTime;
            this.name.set(name);
        }

        public ReadOnlyStringProperty nameProperty() {
            return name.getReadOnlyProperty();
        }

        @Override
        protected Void call() throws Exception {
            this.updateProgress(0, 1); // Set progress to 0 initially
            Thread.sleep(waitTime);
            this.updateProgress(1, 1);
            return null;
        }

        public void resetProgress() {
            this.updateProgress(0, 1); // Reset progress to 0
        }
    }
}

class ProgressIndicatorTableCell<S> extends TableCell<S, Double> {
    public static <S> Callback<TableColumn<S, Double>, TableCell<S, Double>> forTableColumn() {
        return new Callback<TableColumn<S, Double>, TableCell<S, Double>>() {
            @Override
            public TableCell<S, Double> call(TableColumn<S, Double> param) {
                return new ProgressIndicatorTableCell<>();
            }
        };
    }

    private final ProgressIndicator progressIndicator;
    private ObservableValue observable;

    public ProgressIndicatorTableCell() {
        this.progressIndicator = new ProgressIndicator();
        setGraphic(progressIndicator);
    }

    @Override
    public void updateItem(Double item, boolean empty) {
        super.updateItem(item, empty);

        if (empty) {
            setGraphic(null);
        } else {
            progressIndicator.progressProperty().unbind();

            observable = getTableColumn().getCellObservableValue(getIndex());
            if (observable != null) {
                progressIndicator.progressProperty().bind(observable);
            } else {
                progressIndicator.setProgress(item);
            }

            setGraphic(progressIndicator);
        }
    }
}",    public static class TestTask extends Task<Void> {,ChatGPT
TestClassWithoutTestCases,"The class 'TestConfig' might be a test class, but it contains no test cases.","import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import javax.sql.DataSource;

@TestConfiguration
@EnableJpaRepositories(basePackages = ""your.package.repository"")
public class TestConfig {

    @MockBean
    private YourJpaRepository yourJpaRepository; // Mock your JPA repository
    
    @Bean
    public DataSource dataSource() {
        // Create and configure an in-memory DataSource
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(""org.h2.Driver"");
        dataSource.setUrl(""jdbc:h2:mem:testdb"");
        dataSource.setUsername(""sa"");
        dataSource.setPassword("""");
        return dataSource;
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        // Create a mock JdbcTemplate
        return new JdbcTemplate(dataSource);
    }
}",public class TestConfig {,ChatGPT
AvoidAccessibilityAlteration,"You should not modify visibility of constructors, methods or fields using setAccessible()","import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.jackson.JsonComponent;

import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@JsonComponent
@Slf4j
public class MyDataSerializer extends JsonSerializer<MyData> {

    @Override
    public void serialize(MyData myData, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeStartObject();

        Field[] fields = MyData.class.getDeclaredFields();
        for (Field field : fields) {
            try {
                field.setAccessible(true);
                Object value = field.get(myData);
                String fieldName = field.getName();
                boolean isRequired = field.isAnnotationPresent(Required.class);
                String type = field.getType().getSimpleName();

                Map<String, Object> fieldInfo = new HashMap<>();
                fieldInfo.put(""type"", type);
                fieldInfo.put(""isRequired"", isRequired);
                fieldInfo.put(""value"", value);

                jsonGenerator.writeObjectField(fieldName, fieldInfo);
            } catch (IllegalAccessException e) {
                log.error(""Error accessing field: {}"", e.getMessage());
            }
        }

        jsonGenerator.writeEndObject();
    }
}",                field.setAccessible(true);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        try {
            loadFile();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    private static void loadFile() throws FileNotFoundException {
        File txt = new File(""Users.txt"");
        try (Scanner scan = new Scanner(txt)) {
            ArrayList<String> data = new ArrayList<>();
            while (scan.hasNextLine()) {
                String line = scan.nextLine();
                String[] parts = line.split("", "");
                if (parts.length == 3) {
                    String json = ""{\""number\"":\"""" + parts[0] + ""\"",\""name\"":\"""" + parts[1] + ""\"",\""age\"":\"""" + parts[2] + ""\""}"";
                    data.add(json);
                }
            }
            System.out.println(data);
        }
    }
}",                if (parts.length == 3) {,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        System.out.println(num(n - 1, ""1""));
    }

    public static String num(int times, String x) {
        if (times == 0) {
            return x;
        } else {
            String y = """";
            int counter = 1; // Initialize counter to 1 for the first occurrence
            for (int i = 1; i < x.length(); i++) {
                if (x.charAt(i) == x.charAt(i - 1)) {
                    counter++; // Increment counter for consecutive characters
                } else {
                    y += counter + """" + x.charAt(i - 1); // Append count and character to y
                    counter = 1; // Reset counter for a new character
                }
            }
            y += counter + """" + x.charAt(x.length() - 1); // Append count and last character
            return num(times - 1, y); // Use post-decrement operator
        }
    }
}",        Scanner scan = new Scanner(System.in);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.*;

class CountString {
    static int count(String S, List<String> substrings) {
        int n = S.length();
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            for (String sub : substrings) {
                int len = sub.length();
                if (i >= len && S.substring(i - len, i).equals(sub)) {
                    if (len == 1 || (i >= 2 && S.substring(i - len + 1, i).equals(substrings.get(4)))) {
                        dp[i] += dp[i - len];
                    } else if (len == 2 && S.charAt(i - 2) == '0') {
                        dp[i] += dp[i - len];
                    }
                }
            }
        }

        return dp[n];
    }

    public static void main(String[] args) {
        ArrayList<String> substrings = new ArrayList<>();
        substrings.add(""0"");
        substrings.add(""00"");
        substrings.add(""001"");
        substrings.add(""010"");
        substrings.add(""0010"");
        substrings.add(""0100"");
        substrings.add(""0110"");
        substrings.add(""0001"");

        if (args.length != 1) {
            System.err.println(""ERROR - execute with: java CountString -filename-"");
            System.exit(1);
        }

        String S = ""00100"";

        int count = count(S, substrings);

        System.out.println(count);
    }
}",        if (args.length != 1) {,ChatGPT
CloseResource,Ensure that resources like this BufferedReader object are closed after use,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProcessorArchitecture {
    public static void main(String[] args) {
        try {
            Process process = Runtime.getRuntime().exec(""uname -m"");
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String architecture = reader.readLine().trim();
            process.waitFor();
            System.out.println(""Architecture: "" + architecture);
            
            // Check if the architecture matches a specific platform
            if (architecture.equals(""x86_64"")) {
                // Perform actions for Intel/AMD processors
                System.out.println(""Intel/AMD processor detected"");
            } else if (architecture.equals(""arm64"")) {
                // Perform actions for ARM64 processors (e.g., Apple Silicon)
                System.out.println(""ARM64 (Apple Silicon) processor detected"");
            } else {
                // Handle other architectures
                System.out.println(""Unknown processor architecture"");
            }
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}",            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));,ChatGPT
TestClassWithoutTestCases,"The class 'Test4' might be a test class, but it contains no test cases.","import javafx.beans.property.DoubleProperty;
import javafx.scene.shape.Rectangle;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Random;

public class Test4 {

    public static void main(String[] args) {
        Random rnd = new Random();

        List<Rectangle> rectangles = new ArrayList<>();

        for (int i = 0; i < 50; i++) {
            rectangles.add(new Rectangle(rnd.nextDouble(), rnd.nextDouble(), 100, 100));
        }

        Optional<Double> minX = rectangles.stream()
                .map(Rectangle::xProperty)
                .map(DoubleProperty::get) // Map to double values
                .min(Double::compare); // Find the minimum

        minX.ifPresent(min -> System.out.println(""Minimum x value: "" + min));
    }
}",public class Test4 {,ChatGPT
CloseResource,Ensure that resources like this ExecutorService object are closed after use,"import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class ParallelTaskExecutor {

    public static void main(String[] args) {
        List<Input> inputs = generateInputs(); // Generate your list of inputs

        List<Output> results = executeTasks(inputs);
        for (Output result : results) {
            System.out.println(result);
        }
    }

    public static List<Output> executeTasks(List<Input> inputs) {
        List<Output> results = new ArrayList<>();
        ExecutorService executorService = Executors.newFixedThreadPool(inputs.size());

        List<CompletableFuture<Output>> futuresList = new ArrayList<>();
        for (Input input : inputs) {
            CompletableFuture<Output> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return executeTask(input);
                } catch (TimeoutException e) {
                    return new Output(input.getUniqueIdentifier(), ""fail"", ""Timeout occurred"");
                } catch (Exception e) {
                    return new Output(input.getUniqueIdentifier(), ""fail"", ""Exception occurred: "" + e.getMessage());
                }
            }, executorService);
            futuresList.add(future);
        }

        CompletableFuture<Void> allFutures = CompletableFuture.allOf(futuresList.toArray(new CompletableFuture[0]));
        CompletableFuture<List<Output>> allCompletableFuture = allFutures.thenApply(future ->
                futuresList.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList()));

        try {
            results = allCompletableFuture.get(); // Get the results
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executorService.shutdown();
        }

        return results;
    }

    public static Output executeTask(Input input) throws Exception {
        // Perform the task
        // You can modify this method to execute the appropriate task based on the input
        Thread.sleep(1000); // Simulating task execution (Replace with your task logic)

        // Assuming task is successful
        return new Output(input.getUniqueIdentifier(), ""success"", ""Task completed successfully"");
    }

    public static List<Input> generateInputs() {
        // Generate your list of inputs here
        // For demonstration, creating a list of dummy inputs
        List<Input> inputs = new ArrayList<>();
        for (int i = 1; i <= 5; i++) {
            inputs.add(new Input(""Task_"" + i));
        }
        return inputs;
    }

    static class Input {
        private String uniqueIdentifier;

        public Input(String uniqueIdentifier) {
            this.uniqueIdentifier = uniqueIdentifier;
        }

        public String getUniqueIdentifier() {
            return uniqueIdentifier;
        }
    }

    static class Output {
        private String uniqueIdentifier;
        private String result;
        private String data;

        public Output(String uniqueIdentifier, String result, String data) {
            this.uniqueIdentifier = uniqueIdentifier;
            this.result = result;
            this.data = data;
        }

        @Override
        public String toString() {
            return ""Output{"" +
                    ""uniqueIdentifier='"" + uniqueIdentifier + '\'' +
                    "", result='"" + result + '\'' +
                    "", data='"" + data + '\'' +
                    '}';
        }
    }
}",        ExecutorService executorService = Executors.newFixedThreadPool(inputs.size());,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String name = """";
        boolean error = false;

        do {
            if (error) System.out.println(""Sorry, error. Try again"");
            System.out.print(""Enter your name: "");
            name = sc.nextLine(); // Use nextLine() to read the entire line
            error = name.trim().isEmpty() || name.contains("" ""); // Check if name is empty or contains whitespace
        } while (error);

        double amount = 0.00;

        do {
            if (error) System.out.println(""Sorry, error. Try again"");
            System.out.print(""Enter amount of purchase: "");
            amount = sc.nextDouble();
            error = amount <= 1;
        } while (error);
    }
}",        Scanner sc = new Scanner(System.in);,ChatGPT
CloseResource,Ensure that resources like this ExecutorService object are closed after use,"import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(1);

        CompletableFuture.supplyAsync(() -> {
            /*
            try {
                Thread.sleep(2000);
            } catch (InterruptedException ignored) {}
            */
            //System.out.println(""supplyAsync: "" + Thread.currentThread().getName());
            return 1;
        }, executor)
        .thenApplyAsync(i -> {
            System.out.println(""apply: "" + Thread.currentThread().getName());
            return i + 1;
        }, executor)
        .thenAcceptAsync((i) -> {
            System.out.println(""accept: "" + Thread.currentThread().getName());
            System.out.println(""result: "" + i);
        }, executor)
        .join();

        executor.shutdown();
    }
}",        ExecutorService executor = Executors.newFixedThreadPool(1);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class App extends Application {

    @Override
    public void start(Stage stage) {
        HBox platform = new HBox();
        VBox[] towerBoxes = new VBox[] { new VBox(), new VBox(), new VBox()};
        platform.getChildren().addAll(Arrays.asList(towerBoxes));
        Hanoi testing = new Hanoi(10);
        testing.towerBoxes = towerBoxes;
        var scene = new Scene(platform, 640, 480);
        stage.setScene(scene);
        stage.show();

        // Start solving process in a new thread
        Thread solvingThread = new Thread(() -> {
            testing.solve();
        });
        solvingThread.start();
    }

    public static void main(String[] args) {
        launch();
    }
}

class Hanoi {
    // Other code remains the same...

    public void solve() {
        renderHanoi();
        solve(n, src, aux, dest);
    }

    private void solve(int n, Tower src, Tower aux, Tower dest) {
        if (n < 1) {
            return;
        }
        solve(n-1, src, dest, aux);
        dest.push(src.pop());

        // Call renderHanoi on the JavaFX application thread to update UI
        Platform.runLater(this::renderHanoi);

        solve(n-1, aux, src, dest);
    }

    // Other code remains the same...
}",        if (n < 1) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class UserListGenerator {

    public static String generateJavaSource(String input) {
        // Define regex pattern to extract user details
        Pattern pattern = Pattern.compile(""User\\[firstName=(\\w+), lastName=(\\w+)\\]"");
        Matcher matcher = pattern.matcher(input);

        StringBuilder javaSource = new StringBuilder(""Arrays.asList("");
        while (matcher.find()) {
            String firstName = matcher.group(1);
            String lastName = matcher.group(2);
            javaSource.append(""new User(\"""").append(firstName).append(""\"", \"""").append(lastName).append(""\""), "");
        }

        // Remove the trailing comma and space
        if (javaSource.length() > 14) { // Checking if at least one user found
            javaSource.setLength(javaSource.length() - 2);
        }

        javaSource.append("");"");

        return javaSource.toString();
    }

    public static void main(String[] args) {
        String input = ""[User[firstName=John, lastName=Smith], User[firstName=Alice, lastName=Johnson]]"";
        String javaSource = generateJavaSource(input);
        System.out.println(javaSource);
    }
}",        if (javaSource.length() > 14) { // Checking if at least one user found,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"class Solution {
    public static int binaryToDecimal(String str) { 
        int res = 0;
        int power = 0;
        for (int i = str.length() - 1; i >= 0; i--) {
            if (str.charAt(i) == '1') {
                res += Math.pow(2, power);
            }
            power++;
        }
        return res;
    }
}",            if (str.charAt(i) == '1') {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.*;

public class EmployeePhoneNums {
    public static void main(String[] args) {
        String[][] emps2 = new String[][]{
                // EmployeeID, ManagerID, City, Phone number
                {""e1"", ""e1"", ""SF"", ""phone-1""},
                {""e2"", ""e1"", ""SF"", ""phone-2""},
                {""e3"", ""e1"", ""SF"", ""phone-3""},
                {""e4"", ""e2"", ""SF"", ""phone-4""},
                {""e5"", ""e2"", ""PH"", ""phone-5""},
                {""e6"", ""e3"", ""NY"", ""phone-6""}
        };
        Map<String, String> phoneNums = getManagerPhoneNums(emps2);
        System.out.println(phoneNums);
    }

    public static Map<String, String> getManagerPhoneNums(String[][] input) {
        Map<String, String> managerPhoneNums = new HashMap<>();
        Map<String, Set<String>> managerCities = new HashMap<>();

        for (String[] emp : input) {
            String managerId = emp[1];
            String city = emp[2];
            String phoneNum = emp[3];

            // Add city to manager's direct report cities
            managerCities.computeIfAbsent(managerId, k -> new HashSet<>()).add(city);
        }

        // Iterate over the manager-cities map
        for (Map.Entry<String, Set<String>> entry : managerCities.entrySet()) {
            String managerId = entry.getKey();
            Set<String> cities = entry.getValue();

            // If manager has direct reports in more than one city, add manager's phone number to result
            if (cities.size() > 1) {
                for (String[] emp : input) {
                    if (emp[0].equals(managerId)) {
                        managerPhoneNums.put(managerId, emp[3]);
                        break;
                    }
                }
            }
        }

        return managerPhoneNums;
    }
}",            if (cities.size() > 1) {,ChatGPT
SimpleDateFormatNeedsLocale,"When instantiating a SimpleDateFormat object, specify a Locale","import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.RefineryUtilities;

import java.awt.*;

public class PortfolioValueChart extends ApplicationFrame {

    private static final String CHART_NAME_PORTFOLIO = ""Portfolio Value"";

    public PortfolioValueChart(String title) {
        super(title);
        JFreeChart chart = createChart();
        ChartPanel chartPanel = new ChartPanel(chart);
        chartPanel.setPreferredSize(new Dimension(800, 600));
        setContentPane(chartPanel);
    }

    private JFreeChart createChart() {
        TimeSeries series1 = new TimeSeries(CHART_NAME_PORTFOLIO);
        // Assuming positionPrices.getPrices() returns a list of PriceAction objects
        for (PriceAction pa : positionPrices.getPrices()) {
            series1.add(new Day(pa.date), pa.close); // Assuming pa.date is of type java.util.Date
        }

        TimeSeriesCollection dataset = new TimeSeriesCollection();
        dataset.addSeries(series1);

        JFreeChart chart = ChartFactory.createTimeSeriesChart(
                ""Portfolio Value Chart"",
                ""Date"", // X-axis label
                ""Value"", // Y-axis label
                dataset
        );

        XYPlot plot = (XYPlot) chart.getPlot();
        DateAxis domainAxis = (DateAxis) plot.getDomainAxis();
        domainAxis.setDateFormatOverride(new java.text.SimpleDateFormat(""MM-yyyy"")); // Customize date format if needed

        return chart;
    }

    public static void main(String[] args) {
        PortfolioValueChart chart = new PortfolioValueChart(""Portfolio Value Chart"");
        chart.pack();
        RefineryUtilities.centerFrameOnScreen(chart);
        chart.setVisible(true);
    }
}","        domainAxis.setDateFormatOverride(new java.text.SimpleDateFormat(""MM-yyyy"")); // Customize date format if needed",ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class addItem extends AppCompatActivity {

    LoadingDialog loadingDialog;
    RecyclerView imgList;
    ArrayList<Bitmap> bitmapList = new ArrayList<>();
    BitmapAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        /*
        / Code Unnecessary to the problemÃ¢â¬Â¦
        */
        et_title.setOnFocusChangeListener((v, hasFocus) -> {
            if (!hasFocus) {
                getImageLogo(et_title.getText().toString());
            }
        });
    }

    private void getImageLogo(String serviceName) {
        new GoogleImageSearchTask().execute(serviceName);
    }

    private class GoogleImageSearchTask extends AsyncTask<String, Void, ArrayList<Bitmap>> {

        @Override
        protected void onPreExecute() {
            // Show loading dialog or perform any pre-execution tasks
            loadingDialog.show();
        }

        @Override
        protected ArrayList<Bitmap> doInBackground(String... strings) {
            String serviceName = strings[0];
            return getBitmapsFromGoogle(serviceName);
        }

        @Override
        protected void onPostExecute(ArrayList<Bitmap> result) {
            // Dismiss loading dialog
            loadingDialog.dismiss();
            if (result != null) {
                bitmapList.clear();
                bitmapList.addAll(result);
            } else {
                bitmapList.clear();
            }
            adapter.notifyDataSetChanged();
        }
    }

    private ArrayList<Bitmap> getBitmapsFromGoogle(String keyword) {
        ArrayList<Bitmap> imgRealList = new ArrayList<>();
        String newKeyword = keyword.toLowerCase(Locale.ROOT).replace(' ', '+');
        String url = ""https://www.google.gr/search?bih=427&biw=1835&hl=el&gbv=1&tbm=isch&og=&ags=&q="" + newKeyword;
        try {
            Document document = Jsoup.connect(url).get();
            Elements imgList = document.select(""img"");
            for (int i = 1; i < imgList.size(); i++) {
                if (i == 8) break;
                String imgSrc = imgList.get(i).absUrl(""src"");
                InputStream input = new java.net.URL(imgSrc).openStream();
                Bitmap bitmap = BitmapFactory.decodeStream(input);
                imgRealList.add(bitmap);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return imgRealList;
    }
}",                if (i == 8) break;,ChatGPT
AvoidFieldNameMatchingTypeName,It is somewhat confusing to have a field name matching the declaring class name,"final class Cache {
    private static final ConcurrentHashMap<String, List<String>> CACHE = new ConcurrentHashMap<>();

    static List<String> byName(String name) {
        List<String> result = CACHE.putIfAbsent(name, createList(name));

        if (result == null) {
            // This is the first load into the cache, do X
        } else {
            // This is a read of an existing mapping, do Y
        }

        return result;
    }

    private static List<String> createList(String name) {
        // Some expensive operation to create the list
        return new ArrayList<>();
    }
}","    private static final ConcurrentHashMap<String, List<String>> CACHE = new ConcurrentHashMap<>();",ChatGPT
AssignmentInOperand,Avoid assignments in operands,"import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Main {

    public static void main(String[] args) {
        String inputFile = ""pathToInputFile"";
        String outputFile = ""pathToOutputFile"";

        // Read JSON lines from the input file and convert them to a JSON array
        JsonArray jsonArray = readJsonLines(inputFile);

        // Write the JSON array to the output file
        writeJsonArray(jsonArray, outputFile);
    }

    private static JsonArray readJsonLines(String inputFile) {
        JsonArray jsonArray = new JsonArray();

        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(inputFile))) {
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                // Parse each line into a JsonObject
                JsonObject jsonObject = new Gson().fromJson(line, JsonObject.class);
                jsonArray.add(jsonObject);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return jsonArray;
    }

    private static void writeJsonArray(JsonArray jsonArray, String outputFile) {
        try (FileWriter fileWriter = new FileWriter(outputFile)) {
            // Create a JsonObject with the 'entries' key and add the JsonArray to it
            JsonObject jsonObject = new JsonObject();
            jsonObject.add(""entries"", jsonArray);

            // Use Gson to pretty print the JSON and write it to the output file
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            gson.toJson(jsonObject, fileWriter);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",            while ((line = bufferedReader.readLine()) != null) {,ChatGPT
CloseResource,Ensure that resources like this ExecutorService object are closed after use,"import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;
import java.util.concurrent.TimeUnit;

public class VirtualThreadExample {

    public static void main(String[] args) {
        ExecutorService executor = Executors.newVirtualThreadExecutor(); // Create a pool of virtual threads

        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(executor, Flow.defaultBufferSize());

        RecursiveActionExample action = new RecursiveActionExample(publisher, 0, 10); // Example of RecursiveAction

        executor.execute(action); // Execute the RecursiveAction

        publisher.subscribe(new Flow.Subscriber<Integer>() {
            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                subscription.request(Long.MAX_VALUE);
            }

            @Override
            public void onNext(Integer item) {
                System.out.println(""Received: "" + item);
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(""Completed"");
            }
        });

        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class RecursiveActionExample extends java.util.concurrent.RecursiveAction {
    private final SubmissionPublisher<Integer> publisher;
    private final int start;
    private final int end;

    public RecursiveActionExample(SubmissionPublisher<Integer> publisher, int start, int end) {
        this.publisher = publisher;
        this.start = start;
        this.end = end;
    }

    @Override
    protected void compute() {
        if (end - start <= 1) {
            publisher.submit(start);
        } else {
            int mid = (start + end) / 2;
            RecursiveActionExample left = new RecursiveActionExample(publisher, start, mid);
            RecursiveActionExample right = new RecursiveActionExample(publisher, mid, end);
            left.fork();
            right.compute();
            left.join();
        }
    }
}",        ExecutorService executor = Executors.newVirtualThreadExecutor(); // Create a pool of virtual threads,ChatGPT
CloseResource,Ensure that resources like this SubmissionPublisher object are closed after use,"import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;
import java.util.concurrent.TimeUnit;

public class VirtualThreadExample {

    public static void main(String[] args) {
        ExecutorService executor = Executors.newVirtualThreadExecutor(); // Create a pool of virtual threads

        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(executor, Flow.defaultBufferSize());

        RecursiveActionExample action = new RecursiveActionExample(publisher, 0, 10); // Example of RecursiveAction

        executor.execute(action); // Execute the RecursiveAction

        publisher.subscribe(new Flow.Subscriber<Integer>() {
            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                subscription.request(Long.MAX_VALUE);
            }

            @Override
            public void onNext(Integer item) {
                System.out.println(""Received: "" + item);
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(""Completed"");
            }
        });

        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class RecursiveActionExample extends java.util.concurrent.RecursiveAction {
    private final SubmissionPublisher<Integer> publisher;
    private final int start;
    private final int end;

    public RecursiveActionExample(SubmissionPublisher<Integer> publisher, int start, int end) {
        this.publisher = publisher;
        this.start = start;
        this.end = end;
    }

    @Override
    protected void compute() {
        if (end - start <= 1) {
            publisher.submit(start);
        } else {
            int mid = (start + end) / 2;
            RecursiveActionExample left = new RecursiveActionExample(publisher, start, mid);
            RecursiveActionExample right = new RecursiveActionExample(publisher, mid, end);
            left.fork();
            right.compute();
            left.join();
        }
    }
}","        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(executor, Flow.defaultBufferSize());",ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;
import java.util.concurrent.TimeUnit;

public class VirtualThreadExample {

    public static void main(String[] args) {
        ExecutorService executor = Executors.newVirtualThreadExecutor(); // Create a pool of virtual threads

        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(executor, Flow.defaultBufferSize());

        RecursiveActionExample action = new RecursiveActionExample(publisher, 0, 10); // Example of RecursiveAction

        executor.execute(action); // Execute the RecursiveAction

        publisher.subscribe(new Flow.Subscriber<Integer>() {
            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                subscription.request(Long.MAX_VALUE);
            }

            @Override
            public void onNext(Integer item) {
                System.out.println(""Received: "" + item);
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(""Completed"");
            }
        });

        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class RecursiveActionExample extends java.util.concurrent.RecursiveAction {
    private final SubmissionPublisher<Integer> publisher;
    private final int start;
    private final int end;

    public RecursiveActionExample(SubmissionPublisher<Integer> publisher, int start, int end) {
        this.publisher = publisher;
        this.start = start;
        this.end = end;
    }

    @Override
    protected void compute() {
        if (end - start <= 1) {
            publisher.submit(start);
        } else {
            int mid = (start + end) / 2;
            RecursiveActionExample left = new RecursiveActionExample(publisher, start, mid);
            RecursiveActionExample right = new RecursiveActionExample(publisher, mid, end);
            left.fork();
            right.compute();
            left.join();
        }
    }
}",class RecursiveActionExample extends java.util.concurrent.RecursiveAction {,ChatGPT
NonSerializableClass,The field 'publisher' of serializable class 'RecursiveActionExample' is of non-serializable type 'java.util.concurrent.SubmissionPublisher<java.lang.Integer>'.,"import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;
import java.util.concurrent.TimeUnit;

public class VirtualThreadExample {

    public static void main(String[] args) {
        ExecutorService executor = Executors.newVirtualThreadExecutor(); // Create a pool of virtual threads

        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(executor, Flow.defaultBufferSize());

        RecursiveActionExample action = new RecursiveActionExample(publisher, 0, 10); // Example of RecursiveAction

        executor.execute(action); // Execute the RecursiveAction

        publisher.subscribe(new Flow.Subscriber<Integer>() {
            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                subscription.request(Long.MAX_VALUE);
            }

            @Override
            public void onNext(Integer item) {
                System.out.println(""Received: "" + item);
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(""Completed"");
            }
        });

        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class RecursiveActionExample extends java.util.concurrent.RecursiveAction {
    private final SubmissionPublisher<Integer> publisher;
    private final int start;
    private final int end;

    public RecursiveActionExample(SubmissionPublisher<Integer> publisher, int start, int end) {
        this.publisher = publisher;
        this.start = start;
        this.end = end;
    }

    @Override
    protected void compute() {
        if (end - start <= 1) {
            publisher.submit(start);
        } else {
            int mid = (start + end) / 2;
            RecursiveActionExample left = new RecursiveActionExample(publisher, start, mid);
            RecursiveActionExample right = new RecursiveActionExample(publisher, mid, end);
            left.fork();
            right.compute();
            left.join();
        }
    }
}",    private final SubmissionPublisher<Integer> publisher;,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;
import java.util.concurrent.TimeUnit;

public class VirtualThreadExample {

    public static void main(String[] args) {
        ExecutorService executor = Executors.newVirtualThreadExecutor(); // Create a pool of virtual threads

        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(executor, Flow.defaultBufferSize());

        RecursiveActionExample action = new RecursiveActionExample(publisher, 0, 10); // Example of RecursiveAction

        executor.execute(action); // Execute the RecursiveAction

        publisher.subscribe(new Flow.Subscriber<Integer>() {
            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                subscription.request(Long.MAX_VALUE);
            }

            @Override
            public void onNext(Integer item) {
                System.out.println(""Received: "" + item);
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(""Completed"");
            }
        });

        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class RecursiveActionExample extends java.util.concurrent.RecursiveAction {
    private final SubmissionPublisher<Integer> publisher;
    private final int start;
    private final int end;

    public RecursiveActionExample(SubmissionPublisher<Integer> publisher, int start, int end) {
        this.publisher = publisher;
        this.start = start;
        this.end = end;
    }

    @Override
    protected void compute() {
        if (end - start <= 1) {
            publisher.submit(start);
        } else {
            int mid = (start + end) / 2;
            RecursiveActionExample left = new RecursiveActionExample(publisher, start, mid);
            RecursiveActionExample right = new RecursiveActionExample(publisher, mid, end);
            left.fork();
            right.compute();
            left.join();
        }
    }
}",        if (end - start <= 1) {,ChatGPT
TestClassWithoutTestCases,"The class 'NetworkSpeedTest' might be a test class, but it contains no test cases.","import okhttp3.*;

public class NetworkSpeedTest {

    public static void measureUploadSpeed(String url, byte[] data, Callback callback) {
        OkHttpClient client = new OkHttpClient();

        RequestBody requestBody = RequestBody.create(data);
        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();

        long startTime = System.nanoTime();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                // Handle failure
                e.printStackTrace();
                callback.onFailure(call, e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                // Handle response
                long endTime = System.nanoTime();
                long durationNs = endTime - startTime;
                double durationSeconds = durationNs / 1e9;
                long fileSizeBytes = data.length;
                double uploadSpeedMbps = (fileSizeBytes * 8) / (durationSeconds * 1024 * 1024);
                callback.onResponse(call, response, uploadSpeedMbps);
            }
        });
    }
}",public class NetworkSpeedTest {,ChatGPT
TestClassWithoutTestCases,"The class 'TransparencyTest' might be a test class, but it contains no test cases.","import java.awt.Color;
import java.awt.ComponentAdapter;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class TransparencyTest {
    public static void main(String[] args) {
        JPanel panel = new Custom();
        panel.setOpaque(false);
        JFrame frame = new JFrame();
        frame.setUndecorated(true);
        frame.setBackground(new Color(0, 0, 0, 0));
        frame.setTitle(""Test"");
        frame.getContentPane().add(panel);
        frame.setSize(320, 240);
        frame.setResizable(false);
        frame.setMinimumSize(new Dimension(1, 1));
        frame.setLocation(1920, 0);
        frame.setVisible(true);

        // Add a component listener to listen for componentMoved events
        frame.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentMoved(java.awt.event.ComponentEvent e) {
                updateFrameGraphicsConfiguration(frame);
            }
        });
    }

    // Method to update the frame's graphics configuration
    private static void updateFrameGraphicsConfiguration(JFrame frame) {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] gs = ge.getScreenDevices();
        GraphicsConfiguration[] gc = gs[1].getConfigurations(); // Assuming secondary monitor is gs[1]
        frame.setGraphicsConfiguration(gc[0]);
    }

    private static class Custom extends JPanel {
        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            g.clearRect(0, 0, getWidth(), getHeight());
            g.setColor(new Color(255, 0, 0, 127));
            g.fillOval(0, 0, getWidth(), getHeight());
        }
    }
}",public class TransparencyTest {,ChatGPT
MissingSerialVersionUID,Classes implementing Serializable should set a serialVersionUID,"import java.awt.Color;
import java.awt.ComponentAdapter;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class TransparencyTest {
    public static void main(String[] args) {
        JPanel panel = new Custom();
        panel.setOpaque(false);
        JFrame frame = new JFrame();
        frame.setUndecorated(true);
        frame.setBackground(new Color(0, 0, 0, 0));
        frame.setTitle(""Test"");
        frame.getContentPane().add(panel);
        frame.setSize(320, 240);
        frame.setResizable(false);
        frame.setMinimumSize(new Dimension(1, 1));
        frame.setLocation(1920, 0);
        frame.setVisible(true);

        // Add a component listener to listen for componentMoved events
        frame.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentMoved(java.awt.event.ComponentEvent e) {
                updateFrameGraphicsConfiguration(frame);
            }
        });
    }

    // Method to update the frame's graphics configuration
    private static void updateFrameGraphicsConfiguration(JFrame frame) {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] gs = ge.getScreenDevices();
        GraphicsConfiguration[] gc = gs[1].getConfigurations(); // Assuming secondary monitor is gs[1]
        frame.setGraphicsConfiguration(gc[0]);
    }

    private static class Custom extends JPanel {
        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            g.clearRect(0, 0, getWidth(), getHeight());
            g.setColor(new Color(255, 0, 0, 127));
            g.fillOval(0, 0, getWidth(), getHeight());
        }
    }
}",    private static class Custom extends JPanel {,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.Scanner;

public class MovieSimilarity {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] rankingListOfMe = new int[n];
        int[] rankingListOfPeter = new int[n];
        for (int i = 0; i < n; ++i) rankingListOfMe[i] = in.nextInt();
        for (int i = 0; i < n; ++i) rankingListOfPeter[i] = in.nextInt();
        long similarity = countSimilarities(rankingListOfMe, rankingListOfPeter);
        System.out.println(similarity);
    }

    private static long countSimilarities(int[] rankingListOfMe, int[] rankingListOfPeter) {
        int[] tmp = new int[rankingListOfMe.length];
        return mergeSort(rankingListOfMe, rankingListOfPeter, tmp, 0, rankingListOfMe.length - 1);
    }

    private static long mergeSort(int[] rankingListOfMe, int[] rankingListOfPeter, int[] tmp, int left, int right) {
        if (left >= right) return 0;

        int mid = left + (right - left) / 2;
        long count = mergeSort(rankingListOfMe, rankingListOfPeter, tmp, left, mid);
        count += mergeSort(rankingListOfMe, rankingListOfPeter, tmp, mid + 1, right);

        int i = left, j = mid + 1, k = left;
        while (i <= mid && j <= right) {
            if (rankingListOfMe[i] <= rankingListOfMe[j]) {
                tmp[k++] = rankingListOfMe[i++];
            } else {
                tmp[k++] = rankingListOfMe[j++];
                count += mid - i + 1; // Count similarities
            }
        }
        while (i <= mid) tmp[k++] = rankingListOfMe[i++];
        while (j <= right) tmp[k++] = rankingListOfMe[j++];
        System.arraycopy(tmp, left, rankingListOfMe, left, right - left + 1);

        return count;
    }
}",        Scanner in = new Scanner(System.in);,ChatGPT
AvoidAccessibilityAlteration,"You should not modify visibility of constructors, methods or fields using setAccessible()","import org.json.JSONObject;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public record Order(
        String id,
        String userId,
        String securityId,
        String type,
        Double price,
        Long quantity
) {
    public JSONObject toJson() {
        Map<String, Object> map = new HashMap<>();
        for (Field field : getClass().getDeclaredFields()) {
            try {
                field.setAccessible(true);
                map.put(field.getName(), field.get(this));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        return new JSONObject(map);
    }
}

public class Main {
    public static void main(String[] args) {
        String json = new Order("""", ""Albert"", ""GOOGL"", ""SELL"", 97.9, 90L).toJson().toString();
        System.out.println(json);
    }
}",                field.setAccessible(true);,ChatGPT
SimpleDateFormatNeedsLocale,"When instantiating a SimpleDateFormat object, specify a Locale","import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

public class DateTimeParser {
    public static void main(String[] args) {
        String timestampString = ""2023-01-28 20:36"";
        SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm"");
        dateFormat.setTimeZone(TimeZone.getTimeZone(""Europe/Brussels""));
        
        try {
            Date date = dateFormat.parse(timestampString);
            System.out.println(""Timestamp: "" + dateFormat.format(date));
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
}","        SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm"");",ChatGPT
AvoidFieldNameMatchingTypeName,It is somewhat confusing to have a field name matching the declaring class name,"import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

interface Request {
    String getUrl();
}

class A implements Request {
    private String a;
    private String b;
    private String c;

    public void setA(String a) {
        this.a = a;
    }

    public void setB(String b) {
        this.b = b;
    }

    public void setC(String c) {
        this.c = c;
    }

    public String getUrl() {
        Map<String, String> parameters = new HashMap<>();
        for (Field field : this.getClass().getDeclaredFields()) {
            try {
                Object value = field.get(this);
                if (value != null) {
                    parameters.put(field.getName(), value.toString());
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }

        StringBuilder urlBuilder = new StringBuilder();
        urlBuilder.append(""https://example.com?"");
        for (Map.Entry<String, String> entry : parameters.entrySet()) {
            urlBuilder.append(entry.getKey()).append(""="").append(entry.getValue()).append(""&"");
        }
        urlBuilder.deleteCharAt(urlBuilder.length() - 1); // Remove the last '&'
        return urlBuilder.toString();
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new A();
        a.setA(""valueA"");
        a.setC(""valueC"");
        System.out.println(a.getUrl()); // Output: https://example.com?a=valueA&c=valueC
    }
}",    private String a;,ChatGPT
AvoidAccessibilityAlteration,"You should not modify visibility of constructors, methods or fields using setAccessible()","import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

interface Request {
    String getUrl();
}

class Foo implements Request {
    private String a;
    private String b;
    private String c;

    // Constructor, getters, and setters...

    public String getUrl() {
        Map<String, String> params = new HashMap<>();
        for (Field field : getClass().getDeclaredFields()) {
            try {
                field.setAccessible(true);
                Object value = field.get(this);
                if (value != null) {
                    params.put(field.getName(), value.toString());
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }

        StringBuilder urlBuilder = new StringBuilder(""http://example.com/?"");
        for (Map.Entry<String, String> entry : params.entrySet()) {
            urlBuilder.append(entry.getKey()).append(""="").append(entry.getValue()).append(""&"");
        }
        // Remove the trailing '&'
        urlBuilder.setLength(urlBuilder.length() - 1);
        return urlBuilder.toString();
    }
}

public class Main {
    public static void main(String[] args) {
        Foo foo = new Foo();
        foo.setA(""a"");
        foo.setC(""c"");
        System.out.println(foo.getUrl()); // Output: http://example.com/?a=a&c=c
    }
}",                field.setAccessible(true);,ChatGPT
TestClassWithoutTestCases,"The class 'TestDecrypt' might be a test class, but it contains no test cases.","import java.io.*;
import java.nio.charset.StandardCharsets;

import org.apache.commons.io.FileUtils;
import org.bouncycastle.crypto.digests.MD5Digest;
import org.bouncycastle.crypto.engines.AESEngine;
import org.bouncycastle.crypto.generators.OpenSSLPBEParametersGenerator;
import org.bouncycastle.crypto.io.CipherInputStream;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.params.ParametersWithIV;

public class TestDecrypt {
    public static void main(String[] args) {
        try {
            File keyFile = new File(""/home/roxane/key"");
            String passwordStr = FileUtils.readFileToString(keyFile, StandardCharsets.UTF_8);

            String outputPath = ""/home/roxane/test1"";
            String inputPath = ""/home/roxane/test"";

            // Derive key and IV
            byte[] password = passwordStr.getBytes(StandardCharsets.UTF_8);
            OpenSSLPBEParametersGenerator pbeGenerator = new OpenSSLPBEParametersGenerator(new MD5Digest());
            pbeGenerator.init(password, null); // No salt for file-based encryption
            ParametersWithIV parameters = (ParametersWithIV) pbeGenerator.generateDerivedParameters(256, 128);

            // Decrypt file
            try (FileInputStream fis = new FileInputStream(inputPath);
                 FileOutputStream fos = new FileOutputStream(outputPath)) {
                // Decrypt using AES in CBC mode
                AESEngine engine = new AESEngine();
                CBCBlockCipher cipher = new CBCBlockCipher(engine);
                cipher.init(false, parameters);

                CipherInputStream cis = new CipherInputStream(fis, cipher);
                byte[] buffer = new byte[64 * 1024];
                int bytesRead;
                while ((bytesRead = cis.read(buffer)) != -1) {
                    fos.write(buffer, 0, bytesRead);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",public class TestDecrypt {,ChatGPT
AssignmentInOperand,Avoid assignments in operands,"import java.io.*;
import java.nio.charset.StandardCharsets;

import org.apache.commons.io.FileUtils;
import org.bouncycastle.crypto.digests.MD5Digest;
import org.bouncycastle.crypto.engines.AESEngine;
import org.bouncycastle.crypto.generators.OpenSSLPBEParametersGenerator;
import org.bouncycastle.crypto.io.CipherInputStream;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.params.ParametersWithIV;

public class TestDecrypt {
    public static void main(String[] args) {
        try {
            File keyFile = new File(""/home/roxane/key"");
            String passwordStr = FileUtils.readFileToString(keyFile, StandardCharsets.UTF_8);

            String outputPath = ""/home/roxane/test1"";
            String inputPath = ""/home/roxane/test"";

            // Derive key and IV
            byte[] password = passwordStr.getBytes(StandardCharsets.UTF_8);
            OpenSSLPBEParametersGenerator pbeGenerator = new OpenSSLPBEParametersGenerator(new MD5Digest());
            pbeGenerator.init(password, null); // No salt for file-based encryption
            ParametersWithIV parameters = (ParametersWithIV) pbeGenerator.generateDerivedParameters(256, 128);

            // Decrypt file
            try (FileInputStream fis = new FileInputStream(inputPath);
                 FileOutputStream fos = new FileOutputStream(outputPath)) {
                // Decrypt using AES in CBC mode
                AESEngine engine = new AESEngine();
                CBCBlockCipher cipher = new CBCBlockCipher(engine);
                cipher.init(false, parameters);

                CipherInputStream cis = new CipherInputStream(fis, cipher);
                byte[] buffer = new byte[64 * 1024];
                int bytesRead;
                while ((bytesRead = cis.read(buffer)) != -1) {
                    fos.write(buffer, 0, bytesRead);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",                while ((bytesRead = cis.read(buffer)) != -1) {,ChatGPT
UseLocaleWithCaseConversions,"When doing a String.toLowerCase()/toUpperCase() call, use a Locale","public class Stringer {

    public Stringer() {}

    public int getOccurrences(String s) {
        String lower = s.toLowerCase();
        int occurrences = 0;
        int x = 0;

        while (x < lower.length() - 3) { // Ensure there are at least 4 characters remaining in the string
            int traverser = lower.indexOf(""l"", x);
            if (traverser != -1) {
                if (traverser + 3 < lower.length()) { // Ensure there are enough characters for substring extraction
                    String sub = lower.substring(traverser + 1, traverser + 4);
                    if (sub.equals(""ane"")) {
                        occurrences++;
                    }
                    // Move index to the end of the current occurrence
                    x = traverser + 1;
                } else {
                    break; // Break if there are not enough characters remaining for substring extraction
                }
            } else {
                break; // Break if no more occurrences of ""l"" found
            }
        }
        return occurrences;
    }

    public static void main(String[] args) {
        Stringer stringer = new Stringer();
        System.out.println(stringer.getOccurrences(""Lanee"")); // Output: 1
        System.out.println(stringer.getOccurrences(""LineLone"")); // Output: 2
        System.out.println(stringer.getOccurrences(""LLoenLL"")); // Output: 1
        System.out.println(stringer.getOccurrences(""enaLLLmnee"")); // Output: 1
        System.out.println(stringer.getOccurrences(""LLONElllneL"")); // Output: 1
    }
}",        String lower = s.toLowerCase();,ChatGPT
NullAssignment,Assigning an Object to null is a code smell.  Consider refactoring.,"import java.util.Queue;
import java.util.ArrayDeque;

class TreeNode<T extends Number> { // Restricting T to types that extend Number
    T value;
    TreeNode<T> leftChild;
    TreeNode<T> rightChild;

    TreeNode(T value) {
        this.value = value;
        leftChild = null;
        rightChild = null;
    }
}

public class BinaryTree<T extends Number> { // BinaryTree is generic with type parameter T extending Number
    public double sum(TreeNode<T> root) {
        Queue<TreeNode<T>> queue = new ArrayDeque<>();
        double sum = 0;
        if (root != null) {
            queue.add(root);
        }
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode<T> current = queue.remove();
                sum += current.value.doubleValue(); // Using doubleValue() to get the numeric value
                if (current.leftChild != null)
                    queue.add(current.leftChild);
                if (current.rightChild != null)
                    queue.add(current.rightChild);
            }
        }
        return sum;
    }

    // Other methods for insert, delete, search, maximum, minimum, etc.
}",        leftChild = null;,ChatGPT
NullAssignment,Assigning an Object to null is a code smell.  Consider refactoring.,"import java.util.Queue;
import java.util.ArrayDeque;

class TreeNode<T extends Number> { // Restricting T to types that extend Number
    T value;
    TreeNode<T> leftChild;
    TreeNode<T> rightChild;

    TreeNode(T value) {
        this.value = value;
        leftChild = null;
        rightChild = null;
    }
}

public class BinaryTree<T extends Number> { // BinaryTree is generic with type parameter T extending Number
    public double sum(TreeNode<T> root) {
        Queue<TreeNode<T>> queue = new ArrayDeque<>();
        double sum = 0;
        if (root != null) {
            queue.add(root);
        }
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode<T> current = queue.remove();
                sum += current.value.doubleValue(); // Using doubleValue() to get the numeric value
                if (current.leftChild != null)
                    queue.add(current.leftChild);
                if (current.rightChild != null)
                    queue.add(current.rightChild);
            }
        }
        return sum;
    }

    // Other methods for insert, delete, search, maximum, minimum, etc.
}",        rightChild = null;,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.*;

public class GroupChar {
    static void groupLetters(String str, int n) {
        // Create an array list to store groups
        List<StringBuilder> groups = new ArrayList<>();

        // Initialize the groups
        for (int i = 0; i < n; i++) {
            groups.add(new StringBuilder());
        }

        // Iterate over the input string and assign characters to groups
        for (int i = 0; i < str.length(); i++) {
            int groupIndex = i % n;
            groups.get(groupIndex).append(str.charAt(i));
        }

        // Print the groups
        for (int i = 0; i < n; i++) {
            System.out.println(""Group "" + (i + 1) + "" - \"""" + groups.get(i) + ""\"""");
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt user for input string
        System.out.println(""Enter string:"");
        String message = scanner.nextLine();

        // Prompt user for group size
        System.out.println(""Enter group size:"");
        int groupSize = scanner.nextInt();

        // Call groupLetters method
        groupLetters(message, groupSize);
    }
}",        Scanner scanner = new Scanner(System.in);,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.*;

class GroupChar {

    static void groupLetters(String str, int n) {
        String[] groups = new String[n]; // Array to store each group
        Arrays.fill(groups, """"); // Initialize each group as an empty string

        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            int groupIndex = i % n; // Calculate the group index for the current character
            groups[groupIndex] += ch; // Append the character to the corresponding group
        }

        // Print the result
        for (int i = 0; i < n; i++) {
            System.out.println(""Group "" + (i + 1) + "" - \"""" + groups[i] + ""\"""");
        }
    }

    public static void main(String[] args) {

        Scanner inputMessage = new Scanner(System.in);
        System.out.println(""Enter string: "");
        String message = inputMessage.nextLine();

        System.out.println(""Enter a number: "");
        Scanner inputNumber = new Scanner(System.in);
        int number = Integer.parseInt(inputNumber.nextLine());

        System.out.println(""String is - "" + message);
        System.out.println(""Number is - "" + number);

        groupLetters(message, number);
    }
}",        Scanner inputMessage = new Scanner(System.in);,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.*;

class GroupChar {

    static void groupLetters(String str, int n) {
        String[] groups = new String[n]; // Array to store each group
        Arrays.fill(groups, """"); // Initialize each group as an empty string

        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            int groupIndex = i % n; // Calculate the group index for the current character
            groups[groupIndex] += ch; // Append the character to the corresponding group
        }

        // Print the result
        for (int i = 0; i < n; i++) {
            System.out.println(""Group "" + (i + 1) + "" - \"""" + groups[i] + ""\"""");
        }
    }

    public static void main(String[] args) {

        Scanner inputMessage = new Scanner(System.in);
        System.out.println(""Enter string: "");
        String message = inputMessage.nextLine();

        System.out.println(""Enter a number: "");
        Scanner inputNumber = new Scanner(System.in);
        int number = Integer.parseInt(inputNumber.nextLine());

        System.out.println(""String is - "" + message);
        System.out.println(""Number is - "" + number);

        groupLetters(message, number);
    }
}",        Scanner inputNumber = new Scanner(System.in);,ChatGPT
AvoidDuplicateLiterals,"The String literal ""Drama"" appears 4 times in this file; the first occurrence is on line 53","import java.util.*;
import java.util.stream.Collectors;

class Movie {
    private int id;
    private String name;

    public Movie(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}

class Genre {
    private int id;
    private String name;

    public Genre(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Movie> movies = new ArrayList<>();
        movies.add(new Movie(1, ""Titanic""));
        movies.add(new Movie(2, ""Batman""));
        movies.add(new Movie(3, ""Silence of the Lambs""));
        movies.add(new Movie(4, ""1917""));
        movies.add(new Movie(5, ""Fight Club""));
        movies.add(new Movie(6, ""Inception""));
        movies.add(new Movie(7, ""The Godfather""));
        movies.add(new Movie(8, ""Pearl Harbor""));

        List<Genre> genres = new ArrayList<>();
        genres.add(new Genre(1, ""Drama""));
        genres.add(new Genre(4, ""Drama""));
        genres.add(new Genre(8, ""Drama""));
        genres.add(new Genre(7, ""Drama""));
        genres.add(new Genre(2, ""Action""));
        genres.add(new Genre(5, ""Action""));
        genres.add(new Genre(6, ""SF""));
        genres.add(new Genre(3, ""Thriller""));
        genres.add(new Genre(5, ""Thriller""));
        genres.add(new Genre(5, ""Crime""));
        genres.add(new Genre(16, ""Comedy""));
        genres.add(new Genre(3, ""Horror""));
        genres.add(new Genre(1, ""Disaster""));
        genres.add(new Genre(7, ""Noir""));
        genres.add(new Genre(1, ""Romance""));

        // Group genres by movie id
        Map<Integer, List<String>> genresByMovieId = genres.stream()
                .collect(Collectors.groupingBy(Genre::getId, Collectors.mapping(Genre::getName, Collectors.toList())));

        // Combine movies and genres
        List<Map<String, Object>> result = movies.stream()
                .map(movie -> {
                    Map<String, Object> movieMap = new LinkedHashMap<>();
                    movieMap.put(""id"", movie.getId());
                    movieMap.put(""name"", movie.getName());
                    movieMap.put(""genres"", genresByMovieId.getOrDefault(movie.getId(), Collections.emptyList()));
                    return movieMap;
                })
                .collect(Collectors.toList());

        // Print the result
        result.forEach(System.out::println);
    }
}","        genres.add(new Genre(1, ""Drama""));",ChatGPT
NullAssignment,Assigning an Object to null is a code smell.  Consider refactoring.,"public class Main {
    Link first, last;

    public static void main(String args[]) {
        Main ob = new Main();

        Link arr[] = {
            new Link(1), new Link(2), new Link(3)
        };
        int len = 3;

        for (int i = 0; i < len; i++)
            ob.insertFirst(arr[i]);
        System.out.print(""Data in the list: "");
        while (ob.first != null)
            System.out.print(ob.removeAndReturn() + "", "");

        for (int i = 0; i < len; i++)
            ob.insertLast(new Link(arr[i].data)); // Create new Link objects
        System.out.print(""\nData in the list: "");
        while (ob.first != null)
            System.out.print(ob.removeAndReturn() + "", "");
    }

    void insertFirst(Link arg) {
        if (isEmpty())
            last = arg;
        arg.next = first;
        first = arg;
    }

    Object removeAndReturn() {
        Object ret = null;
        try {
            ret = first.data;
            if (first.next == null)
                last = null;
            first = first.next;
        } catch (NullPointerException NPe) {
            System.out.println(""You are referring to a null.\nLinked List is empty."");
        }
        return ret;
    }

    void insertLast(Link arg) {
        if (isEmpty())
            first = arg;
        else
            last.next = arg;
        last = arg;
    }

    boolean isEmpty() {
        return first == null;
    }
}

class Link {
    Object data;
    Link next;

    Link(Object data) {
        this.data = data;
    }
}",                last = null;,ChatGPT
AvoidCatchingNPE,Avoid catching NullPointerException; consider removing the cause of the NPE.,"public class Main {
    Link first, last;

    public static void main(String args[]) {
        Main ob = new Main();

        Link arr[] = {
            new Link(1), new Link(2), new Link(3)
        };
        int len = 3;

        for (int i = 0; i < len; i++)
            ob.insertFirst(arr[i]);
        System.out.print(""Data in the list: "");
        while (ob.first != null)
            System.out.print(ob.removeAndReturn() + "", "");

        for (int i = 0; i < len; i++)
            ob.insertLast(new Link(arr[i].data)); // Create new Link objects
        System.out.print(""\nData in the list: "");
        while (ob.first != null)
            System.out.print(ob.removeAndReturn() + "", "");
    }

    void insertFirst(Link arg) {
        if (isEmpty())
            last = arg;
        arg.next = first;
        first = arg;
    }

    Object removeAndReturn() {
        Object ret = null;
        try {
            ret = first.data;
            if (first.next == null)
                last = null;
            first = first.next;
        } catch (NullPointerException NPe) {
            System.out.println(""You are referring to a null.\nLinked List is empty."");
        }
        return ret;
    }

    void insertLast(Link arg) {
        if (isEmpty())
            first = arg;
        else
            last.next = arg;
        last = arg;
    }

    boolean isEmpty() {
        return first == null;
    }
}

class Link {
    Object data;
    Link next;

    Link(Object data) {
        this.data = data;
    }
}",        } catch (NullPointerException NPe) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;

public class Main {
    public static void main(String[] args) {
        // Parse the server's date-time string
        String serverDateTimeString = ""Sa. 07.01.2023 16:39:15"";
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""E. dd.MM.yyyy HH:mm:ss"");
        LocalDateTime serverDateTime = LocalDateTime.parse(serverDateTimeString, formatter);

        // Get the current time in the Europe/Vienna time zone
        ZoneId viennaZoneId = ZoneId.of(""Europe/Vienna"");
        ZonedDateTime currentZonedDateTime = ZonedDateTime.now(viennaZoneId);

        // Calculate the difference in minutes
        long minutesDifference = java.time.Duration.between(serverDateTime, currentZonedDateTime.toLocalDateTime()).toMinutes();

        // Check if one minute has passed
        if (minutesDifference >= 1) {
            System.out.println(""One minute or more has passed since the server time."");
        } else {
            System.out.println(""Less than one minute has passed since the server time."");
        }
    }
}",        if (minutesDifference >= 1) {,ChatGPT
TestClassWithoutTestCases,"The class 'Test' might be a test class, but it contains no test cases.","import com.sun.net.httpserver.HttpServer;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.LocalDateTime;

public class Test {
    public static void main(String[] args) throws IOException, InterruptedException {
        var httpServer = HttpServer.create();
        httpServer.createContext(""/"", exchange -> {
            exchange.sendResponseHeaders(200, -1);
            exchange.close();
        });
        httpServer.bind(new InetSocketAddress(""127.0.0.1"", 0), 0);
        httpServer.start();

        var httpClient = HttpClient.newHttpClient();

        var host = httpServer.getAddress().getAddress().getHostAddress();
        var port = httpServer.getAddress().getPort();

        var httpRequest = HttpRequest.newBuilder()
                .uri(URI.create(""http://"" + host + "":"" + port + ""/""))
                .GET()
                .build();

        var httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofByteArray());

        System.out.println(httpResponse.statusCode());

        System.out.println(LocalDateTime.now() + "" Stopping server"");

        // Stop the server asynchronously to avoid blocking
        new Thread(() -> {
            httpServer.stop(0);
            System.out.println(LocalDateTime.now() + "" Server stopped"");
        }).start();
    }
}",public class Test {,ChatGPT
CloseResource,Ensure that resources like this HttpClient object are closed after use,"import com.sun.net.httpserver.HttpServer;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.LocalDateTime;

public class Test {
    public static void main(String[] args) throws IOException, InterruptedException {
        var httpServer = HttpServer.create();
        httpServer.createContext(""/"", exchange -> {
            exchange.sendResponseHeaders(200, -1);
            exchange.close();
        });
        httpServer.bind(new InetSocketAddress(""127.0.0.1"", 0), 0);
        httpServer.start();

        var httpClient = HttpClient.newHttpClient();

        var host = httpServer.getAddress().getAddress().getHostAddress();
        var port = httpServer.getAddress().getPort();

        var httpRequest = HttpRequest.newBuilder()
                .uri(URI.create(""http://"" + host + "":"" + port + ""/""))
                .GET()
                .build();

        var httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofByteArray());

        System.out.println(httpResponse.statusCode());

        System.out.println(LocalDateTime.now() + "" Stopping server"");

        // Stop the server asynchronously to avoid blocking
        new Thread(() -> {
            httpServer.stop(0);
            System.out.println(LocalDateTime.now() + "" Server stopped"");
        }).start();
    }
}",        var httpClient = HttpClient.newHttpClient();,ChatGPT
CompareObjectsWithEquals,Use equals() to compare object references.,"import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class ArrayMerger {

    public static List<String[]> mergeArrays(List<String[]> dictionary) {
        List<String[]> mergedDictionary = new ArrayList<>();

        // Set to keep track of merged arrays
        Set<String[]> mergedSet = new HashSet<>();

        for (String[] array : dictionary) {
            // Skip processing if the array has already been merged
            if (mergedSet.contains(array)) {
                continue;
            }

            // Create a new merged array
            List<String> mergedArray = new ArrayList<>();
            for (String value : array) {
                mergedArray.add(value);
            }

            // Check for shared values with other arrays
            for (String[] otherArray : dictionary) {
                if (array != otherArray && !mergedSet.contains(otherArray)) {
                    for (String value : otherArray) {
                        if (!mergedArray.contains(value)) {
                            if (containsSharedValue(array, otherArray)) {
                                mergedArray.addAll(List.of(otherArray));
                                mergedSet.add(otherArray);
                                break;
                            }
                        }
                    }
                }
            }

            // Add the merged array to the result if not empty
            if (!mergedArray.isEmpty()) {
                mergedDictionary.add(mergedArray.toArray(new String[0]));
            }
        }

        return mergedDictionary;
    }

    private static boolean containsSharedValue(String[] array1, String[] array2) {
        for (String value : array1) {
            for (String otherValue : array2) {
                if (value.equals(otherValue)) {
                    return true;
                }
            }
        }
        return false;
    }

    public static void main(String[] args) {
        List<String[]> dictionary = new ArrayList<>();
        dictionary.add(new String[]{""A"", ""B""});
        dictionary.add(new String[]{""B"", ""C""});
        dictionary.add(new String[]{""D"", ""E""});
        dictionary.add(new String[]{""F"", ""C""});
        dictionary.add(new String[]{""G"", ""H""});
        dictionary.add(new String[]{""T"", ""D""});

        List<String[]> mergedDictionary = mergeArrays(dictionary);

        for (String[] array : mergedDictionary) {
            System.out.println(java.util.Arrays.toString(array));
        }
    }
}",                if (array != otherArray && !mergedSet.contains(otherArray)) {,ChatGPT
AvoidDuplicateLiterals,"The String literal ""ACC1"" appears 4 times in this file; the first occurrence is on line 23","import java.util.ArrayList;
import java.util.List;

class Position {
    String account;
    String date;
    String cycle;
    String status;

    public Position(String account, String date, String cycle, String status) {
        this.account = account;
        this.date = date;
        this.cycle = cycle;
        this.status = status;
    }

    // Getters and setters
}

public class Main {
    public static void main(String[] args) {
        List<Position> listA = new ArrayList<>();
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""2"", ""closing""));

        List<Position> listB = new ArrayList<>();
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closed""));
        listB.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));

        List<String> accountsToExtract = listA.stream()
                .filter(a -> listB.stream()
                        .anyMatch(b -> a.account.equals(b.account)
                                && a.date.equals(b.date)
                                && a.cycle.equals(b.cycle)
                                && a.status.equals(b.status)))
                .map(a -> a.account)
                .distinct()
                .toList();

        System.out.println(""Accounts to extract: "" + accountsToExtract);
    }
}","        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));",ChatGPT
AvoidDuplicateLiterals,"The String literal ""20-Jan-23"" appears 11 times in this file; the first occurrence is on line 23","import java.util.ArrayList;
import java.util.List;

class Position {
    String account;
    String date;
    String cycle;
    String status;

    public Position(String account, String date, String cycle, String status) {
        this.account = account;
        this.date = date;
        this.cycle = cycle;
        this.status = status;
    }

    // Getters and setters
}

public class Main {
    public static void main(String[] args) {
        List<Position> listA = new ArrayList<>();
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""2"", ""closing""));

        List<Position> listB = new ArrayList<>();
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closed""));
        listB.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));

        List<String> accountsToExtract = listA.stream()
                .filter(a -> listB.stream()
                        .anyMatch(b -> a.account.equals(b.account)
                                && a.date.equals(b.date)
                                && a.cycle.equals(b.cycle)
                                && a.status.equals(b.status)))
                .map(a -> a.account)
                .distinct()
                .toList();

        System.out.println(""Accounts to extract: "" + accountsToExtract);
    }
}","        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));",ChatGPT
AvoidDuplicateLiterals,"The String literal ""open"" appears 6 times in this file; the first occurrence is on line 23","import java.util.ArrayList;
import java.util.List;

class Position {
    String account;
    String date;
    String cycle;
    String status;

    public Position(String account, String date, String cycle, String status) {
        this.account = account;
        this.date = date;
        this.cycle = cycle;
        this.status = status;
    }

    // Getters and setters
}

public class Main {
    public static void main(String[] args) {
        List<Position> listA = new ArrayList<>();
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""2"", ""closing""));

        List<Position> listB = new ArrayList<>();
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closed""));
        listB.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));

        List<String> accountsToExtract = listA.stream()
                .filter(a -> listB.stream()
                        .anyMatch(b -> a.account.equals(b.account)
                                && a.date.equals(b.date)
                                && a.cycle.equals(b.cycle)
                                && a.status.equals(b.status)))
                .map(a -> a.account)
                .distinct()
                .toList();

        System.out.println(""Accounts to extract: "" + accountsToExtract);
    }
}","        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));",ChatGPT
AvoidDuplicateLiterals,"The String literal ""closing"" appears 4 times in this file; the first occurrence is on line 24","import java.util.ArrayList;
import java.util.List;

class Position {
    String account;
    String date;
    String cycle;
    String status;

    public Position(String account, String date, String cycle, String status) {
        this.account = account;
        this.date = date;
        this.cycle = cycle;
        this.status = status;
    }

    // Getters and setters
}

public class Main {
    public static void main(String[] args) {
        List<Position> listA = new ArrayList<>();
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""2"", ""closing""));

        List<Position> listB = new ArrayList<>();
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closed""));
        listB.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));

        List<String> accountsToExtract = listA.stream()
                .filter(a -> listB.stream()
                        .anyMatch(b -> a.account.equals(b.account)
                                && a.date.equals(b.date)
                                && a.cycle.equals(b.cycle)
                                && a.status.equals(b.status)))
                .map(a -> a.account)
                .distinct()
                .toList();

        System.out.println(""Accounts to extract: "" + accountsToExtract);
    }
}","        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));",ChatGPT
AvoidDuplicateLiterals,"The String literal ""ACC2"" appears 4 times in this file; the first occurrence is on line 25","import java.util.ArrayList;
import java.util.List;

class Position {
    String account;
    String date;
    String cycle;
    String status;

    public Position(String account, String date, String cycle, String status) {
        this.account = account;
        this.date = date;
        this.cycle = cycle;
        this.status = status;
    }

    // Getters and setters
}

public class Main {
    public static void main(String[] args) {
        List<Position> listA = new ArrayList<>();
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closing""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));
        listA.add(new Position(""ACC3"", ""20-Jan-23"", ""2"", ""closing""));

        List<Position> listB = new ArrayList<>();
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC1"", ""20-Jan-23"", ""2"", ""closing""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));
        listB.add(new Position(""ACC2"", ""20-Jan-23"", ""2"", ""closed""));
        listB.add(new Position(""ACC3"", ""20-Jan-23"", ""1"", ""open""));

        List<String> accountsToExtract = listA.stream()
                .filter(a -> listB.stream()
                        .anyMatch(b -> a.account.equals(b.account)
                                && a.date.equals(b.date)
                                && a.cycle.equals(b.cycle)
                                && a.status.equals(b.status)))
                .map(a -> a.account)
                .distinct()
                .toList();

        System.out.println(""Accounts to extract: "" + accountsToExtract);
    }
}","        listA.add(new Position(""ACC2"", ""20-Jan-23"", ""1"", ""open""));",ChatGPT
AvoidFieldNameMatchingTypeName,It is somewhat confusing to have a field name matching the declaring class name,"public class Odds {
    private String id;
    private String odds;
    private String header;
    private String name;
    // Getters and setters
}",    private String odds;,ChatGPT
CloseResource,Ensure that resources like this InputStream object are closed after use,"import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

public class JsonParserExample {

    public static void main(String[] args) {
        InputStream jsonInputStream = JsonParserExample.class.getResourceAsStream(""/path/to/your/json/file.json"");
        List<String> textList = extractTextFromJson(jsonInputStream);
        StringBuilder result = new StringBuilder();
        for (String text : textList) {
            result.append(text).append(System.lineSeparator());
        }
        System.out.println(""Result:"");
        System.out.println(result.toString());
    }

    public static List<String> extractTextFromJson(InputStream jsonInputStream) {
        ObjectMapper objectMapper = new ObjectMapper();
        List<String> textList = new ArrayList<>();
        try {
            JsonNode rootNode = objectMapper.readTree(jsonInputStream);
            JsonNode contentNode = rootNode.get(""content"");
            if (contentNode != null && contentNode.isArray()) {
                for (JsonNode node : contentNode) {
                    JsonNode fileContentNode = node.get(""fileContent"");
                    if (fileContentNode != null) {
                        JsonNode subListNode = fileContentNode.get(""subList"");
                        if (subListNode != null && subListNode.isArray()) {
                            for (JsonNode subNode : subListNode) {
                                JsonNode textNode = subNode.get(""text"");
                                if (textNode != null) {
                                    textList.add(textNode.asText());
                                }
                            }
                        }
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return textList;
    }
}","        InputStream jsonInputStream = JsonParserExample.class.getResourceAsStream(""/path/to/your/json/file.json"");",ChatGPT
TestClassWithoutTestCases,"The class 'TestCompletableFuture' might be a test class, but it contains no test cases.","import java.util.concurrent.*;

public class TestCompletableFuture {

    public static void main(String[] args) throws Exception {
        CompletableFuture<Void> future = new CompletableFuture<Void>()
                .whenComplete((res, exc) -> {
                    System.out.println(""inside handle."");
                    if (exc != null) {
                        System.out.println(""exception."");
                    }
                    System.out.println(""completed."");
                });

        future.completeExceptionally(new Exception(""exception""));
        System.out.println(""done."");
    }
}",public class TestCompletableFuture {,ChatGPT
CloseResource,Ensure that resources like this InputStream object are closed after use,"import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributeView;
import java.nio.file.attribute.BasicFileAttributes;

public class FileDateExtractor {

    public static void main(String[] args) throws IOException {
        InputStream inputStream = getInputStreamSomehow(); // Your InputStream
        Path tempFile = saveInputStreamToTempFile(inputStream);
        if (tempFile != null) {
            BasicFileAttributes attributes = getBasicFileAttributes(tempFile);
            if (attributes != null) {
                System.out.println(""Creation Time: "" + attributes.creationTime());
                System.out.println(""Last Modified Time: "" + attributes.lastModifiedTime());
            }
            // Delete the temporary file
            Files.delete(tempFile);
        }
    }

    private static Path saveInputStreamToTempFile(InputStream inputStream) throws IOException {
        Path tempFile = Files.createTempFile(""temp"", "".tmp"");
        try (FileOutputStream outputStream = new FileOutputStream(tempFile.toFile())) {
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }
        }
        return tempFile;
    }

    private static BasicFileAttributes getBasicFileAttributes(Path file) {
        try {
            return Files.getFileAttributeView(file, BasicFileAttributeView.class).readAttributes().basicAttributes();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    private static InputStream getInputStreamSomehow() {
        // Your logic to obtain the InputStream
        return null;
    }
}",        InputStream inputStream = getInputStreamSomehow(); // Your InputStream,ChatGPT
AssignmentInOperand,Avoid assignments in operands,"import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributeView;
import java.nio.file.attribute.BasicFileAttributes;

public class FileDateExtractor {

    public static void main(String[] args) throws IOException {
        InputStream inputStream = getInputStreamSomehow(); // Your InputStream
        Path tempFile = saveInputStreamToTempFile(inputStream);
        if (tempFile != null) {
            BasicFileAttributes attributes = getBasicFileAttributes(tempFile);
            if (attributes != null) {
                System.out.println(""Creation Time: "" + attributes.creationTime());
                System.out.println(""Last Modified Time: "" + attributes.lastModifiedTime());
            }
            // Delete the temporary file
            Files.delete(tempFile);
        }
    }

    private static Path saveInputStreamToTempFile(InputStream inputStream) throws IOException {
        Path tempFile = Files.createTempFile(""temp"", "".tmp"");
        try (FileOutputStream outputStream = new FileOutputStream(tempFile.toFile())) {
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }
        }
        return tempFile;
    }

    private static BasicFileAttributes getBasicFileAttributes(Path file) {
        try {
            return Files.getFileAttributeView(file, BasicFileAttributeView.class).readAttributes().basicAttributes();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    private static InputStream getInputStreamSomehow() {
        // Your logic to obtain the InputStream
        return null;
    }
}",            while ((bytesRead = inputStream.read(buffer)) != -1) {,ChatGPT
AvoidDuplicateLiterals,"The String literal ""New item"" appears 4 times in this file; the first occurrence is on line 17","import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.control.cell.TextFieldListCell;
import javafx.scene.layout.VBox;

import java.net.URL;
import java.util.ResourceBundle;

public class HelloController implements Initializable {

    @FXML
    private ComboBox<String> frequencyPlanComboBox;

    private ObservableList<String> items = FXCollections.observableArrayList(""aaa"", ""bbb"", ""ccc"", ""New item"");

    @Override
    public void initialize(URL pURL, ResourceBundle pResourceBundle) {
        frequencyPlanComboBox.setCellFactory(param -> new CustomListCell());
        frequencyPlanComboBox.getItems().addAll(items);
        frequencyPlanComboBox.setEditable(true); // Allow editing for the ""New item"" cell
    }

    private class CustomListCell extends ListCell<String> {
        private final Button newItemButton = new Button(""New item"");

        public CustomListCell() {
            newItemButton.setOnAction(event -> {
                getListView().getItems().add(getIndex(), ""New item"");
                getListView().getSelectionModel().select(getIndex());
            });
        }

        @Override
        protected void updateItem(String item, boolean empty) {
            super.updateItem(item, empty);
            if (empty || item == null) {
                setGraphic(null);
            } else if (""New item"".equals(item)) {
                setGraphic(newItemButton);
            } else {
                setText(item);
                setGraphic(null);
            }
        }
    }
}","    private ObservableList<String> items = FXCollections.observableArrayList(""aaa"", ""bbb"", ""ccc"", ""New item"");",ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.control.cell.TextFieldListCell;
import javafx.scene.layout.VBox;

import java.net.URL;
import java.util.ResourceBundle;

public class HelloController implements Initializable {

    @FXML
    private ComboBox<String> frequencyPlanComboBox;

    private ObservableList<String> items = FXCollections.observableArrayList(""aaa"", ""bbb"", ""ccc"", ""New item"");

    @Override
    public void initialize(URL pURL, ResourceBundle pResourceBundle) {
        frequencyPlanComboBox.setCellFactory(param -> new CustomListCell());
        frequencyPlanComboBox.getItems().addAll(items);
        frequencyPlanComboBox.setEditable(true); // Allow editing for the ""New item"" cell
    }

    private class CustomListCell extends ListCell<String> {
        private final Button newItemButton = new Button(""New item"");

        public CustomListCell() {
            newItemButton.setOnAction(event -> {
                getListView().getItems().add(getIndex(), ""New item"");
                getListView().getSelectionModel().select(getIndex());
            });
        }

        @Override
        protected void updateItem(String item, boolean empty) {
            super.updateItem(item, empty);
            if (empty || item == null) {
                setGraphic(null);
            } else if (""New item"".equals(item)) {
                setGraphic(newItemButton);
            } else {
                setText(item);
                setGraphic(null);
            }
        }
    }
}","            } else if (""New item"".equals(item)) {",ChatGPT
UseLocaleWithCaseConversions,"When doing a String.toLowerCase()/toUpperCase() call, use a Locale","import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder, ModifyResponseBodyFilter modifyResponseBodyFilter) {
        return builder.routes()
                .route(""modify_response_route"", r -> r.path(""/modify-response"")
                        .filters(f -> f.filter(modifyResponseBodyFilter.newConfig().setRewriteFunction((exchange, body) -> {
                            // Modify the response body as needed
                            String modifiedBody = new String(body).toUpperCase(); // Example: Convert response body to uppercase
                            return modifiedBody.getBytes();
                        })))
                        .uri(""http://example.com"")) // Specify the target URI
                .build();
    }
}",                            String modifiedBody = new String(body).toUpperCase(); // Example: Convert response body to uppercase,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.HashMap;
import java.util.Map;

public class Solution {
    public char solution(String s) {
        Map<Character, Integer> charCount = new HashMap<>();

        // Count occurrences of each character
        for (char c : s.toCharArray()) {
            charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        }

        // Find the first non-repeated character
        for (char c : s.toCharArray()) {
            if (charCount.get(c) == 1) {
                return c;
            }
        }

        return '-';
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.solution(""abacabad"")); // Output: c
    }
}",            if (charCount.get(c) == 1) {,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

class Ask7 {
    public static void main(String[] args) throws IOException {
        // Input file
        File inputFile = new File(""textFile.txt"");
        // Temporary file
        File tempFile = new File(""tempFile.txt"");

        // Scanner to read from input file
        Scanner in = new Scanner(inputFile);
        // PrintWriter to write to temporary file
        PrintWriter out = new PrintWriter(tempFile);

        // Read from input file and write non-empty lines to temporary file
        while (in.hasNextLine()) {
            String line = in.nextLine();
            if (!line.isEmpty()) {
                out.println(line);
            }
        }

        // Close resources
        in.close();
        out.close();

        // Replace original file with temporary file
        if (!tempFile.renameTo(inputFile)) {
            System.out.println(""Failed to rename temporary file to original file"");
        } else {
            System.out.println(""File updated successfully"");
        }
    }
}",        Scanner in = new Scanner(inputFile);,ChatGPT
CloseResource,Ensure that resources like this PrintWriter object are closed after use,"import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

class Ask7 {
    public static void main(String[] args) throws IOException {
        // Input file
        File inputFile = new File(""textFile.txt"");
        // Temporary file
        File tempFile = new File(""tempFile.txt"");

        // Scanner to read from input file
        Scanner in = new Scanner(inputFile);
        // PrintWriter to write to temporary file
        PrintWriter out = new PrintWriter(tempFile);

        // Read from input file and write non-empty lines to temporary file
        while (in.hasNextLine()) {
            String line = in.nextLine();
            if (!line.isEmpty()) {
                out.println(line);
            }
        }

        // Close resources
        in.close();
        out.close();

        // Replace original file with temporary file
        if (!tempFile.renameTo(inputFile)) {
            System.out.println(""Failed to rename temporary file to original file"");
        } else {
            System.out.println(""File updated successfully"");
        }
    }
}",        PrintWriter out = new PrintWriter(tempFile);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"public class RoundToOdd {

    public static void main(String[] args) {
        System.out.println(roundToOdd(2.1)); // expected: 3
        System.out.println(roundToOdd(4.9)); // expected: 5
        System.out.println(roundToOdd(3.7)); // expected: 3
        System.out.println(roundToOdd(1.1)); // expected: 1
        System.out.println(roundToOdd(7.0)); // expected: 7
        System.out.println(roundToOdd(2.0)); // expected: 1 or 3, depends on requirements
    }

    public static long roundToOdd(double d) {
        // Convert double to long
        long closestInteger = Math.round(d);

        // Check if the integer is odd
        if (closestInteger % 2 == 1) {
            return closestInteger; // Return if already odd
        } else {
            // If even, return the closest odd integer
            return (d > closestInteger) ? closestInteger + 1 : closestInteger - 1;
        }
    }
}",        if (closestInteger % 2 == 1) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.ArrayList;
import java.util.List;

public class RangeParser {
    public static List<String> parseRange(String range) {
        List<String> result = new ArrayList<>();

        // Split the range string by '-'
        String[] parts = range.split(""-"");
        if (parts.length != 2) {
            throw new IllegalArgumentException(""Invalid range format: "" + range);
        }

        // Parse the start and end values
        String start = parts[0].trim();
        String end = parts[1].trim();

        // Check if the range represents characters or integers
        if (start.length() == 1 && end.length() == 1) {
            // Characters range
            char startChar = start.charAt(0);
            char endChar = end.charAt(0);
            for (char c = startChar; c <= endChar; c++) {
                result.add(String.valueOf(c));
            }
        } else {
            // Integers range
            int startInt = Integer.parseInt(start);
            int endInt = Integer.parseInt(end);
            for (int i = startInt; i <= endInt; i++) {
                result.add(String.valueOf(i));
            }
        }

        return result;
    }

    public static void main(String[] args) {
        String range1 = ""1-3"";
        String range2 = ""11-16"";
        String range3 = ""a-d"";
        String range4 = ""C-G"";

        System.out.println(parseRange(range1)); // [1, 2, 3]
        System.out.println(parseRange(range2)); // [11, 12, 13, 14, 15, 16]
        System.out.println(parseRange(range3)); // [a, b, c, d]
        System.out.println(parseRange(range4)); // [C, D, E, F, G]
    }
}",        if (parts.length != 2) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JsonExpressionEvaluator {

    private static final Pattern EXPRESSION_PATTERN = Pattern.compile(""\\$\\{([^}]*)}"");

    public static JsonNode evaluateExpressions(JsonNode jsonNode) {
        ObjectMapper mapper = new ObjectMapper();
        JsonNode resultNode = mapper.createObjectNode();

        jsonNode.fields().forEachRemaining(entry -> {
            String key = entry.getKey();
            JsonNode value = entry.getValue();
            if (value.isTextual()) {
                String evaluatedValue = evaluateExpression(value.asText(), jsonNode);
                ((com.fasterxml.jackson.databind.node.ObjectNode) resultNode).put(key, evaluatedValue);
            } else {
                ((com.fasterxml.jackson.databind.node.ObjectNode) resultNode).set(key, value);
            }
        });

        return resultNode;
    }

    private static String evaluateExpression(String expression, JsonNode jsonNode) {
        Matcher matcher = EXPRESSION_PATTERN.matcher(expression);
        StringBuffer sb = new StringBuffer();
        while (matcher.find()) {
            String match = matcher.group(1);
            matcher.appendReplacement(sb, """");
            matcher.appendTail(sb);
            String[] tokens = match.split(""\\*"");
            if (tokens.length == 1) {
                String value = jsonNode.at(""/"" + tokens[0]).asText();
                sb.append(value);
            } else if (tokens.length == 2) {
                int result = Integer.parseInt(jsonNode.at(""/"" + tokens[0]).asText()) *
                        Integer.parseInt(jsonNode.at(""/"" + tokens[1]).asText());
                sb.append(result);
            }
        }
        matcher.appendTail(sb);
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        String jsonString = ""{\""model\"":\""abc\"",\""variant\"":\""m1\"",\""stage\"":2,\""a\"":100,\""b\"":200,\""display name\"":\""${model}-${variant}\"",\""c\"":\""${a}*${b}\"",\""description\"":\""${model}-${variant}-${stage*10}\""}"";
        JsonNode jsonNode = mapper.readTree(jsonString);
        JsonNode evaluatedNode = evaluateExpressions(jsonNode);
        System.out.println(evaluatedNode.toString());
    }
}",            if (tokens.length == 1) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JsonExpressionEvaluator {

    private static final Pattern EXPRESSION_PATTERN = Pattern.compile(""\\$\\{([^}]*)}"");

    public static JsonNode evaluateExpressions(JsonNode jsonNode) {
        ObjectMapper mapper = new ObjectMapper();
        JsonNode resultNode = mapper.createObjectNode();

        jsonNode.fields().forEachRemaining(entry -> {
            String key = entry.getKey();
            JsonNode value = entry.getValue();
            if (value.isTextual()) {
                String evaluatedValue = evaluateExpression(value.asText(), jsonNode);
                ((com.fasterxml.jackson.databind.node.ObjectNode) resultNode).put(key, evaluatedValue);
            } else {
                ((com.fasterxml.jackson.databind.node.ObjectNode) resultNode).set(key, value);
            }
        });

        return resultNode;
    }

    private static String evaluateExpression(String expression, JsonNode jsonNode) {
        Matcher matcher = EXPRESSION_PATTERN.matcher(expression);
        StringBuffer sb = new StringBuffer();
        while (matcher.find()) {
            String match = matcher.group(1);
            matcher.appendReplacement(sb, """");
            matcher.appendTail(sb);
            String[] tokens = match.split(""\\*"");
            if (tokens.length == 1) {
                String value = jsonNode.at(""/"" + tokens[0]).asText();
                sb.append(value);
            } else if (tokens.length == 2) {
                int result = Integer.parseInt(jsonNode.at(""/"" + tokens[0]).asText()) *
                        Integer.parseInt(jsonNode.at(""/"" + tokens[1]).asText());
                sb.append(result);
            }
        }
        matcher.appendTail(sb);
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        String jsonString = ""{\""model\"":\""abc\"",\""variant\"":\""m1\"",\""stage\"":2,\""a\"":100,\""b\"":200,\""display name\"":\""${model}-${variant}\"",\""c\"":\""${a}*${b}\"",\""description\"":\""${model}-${variant}-${stage*10}\""}"";
        JsonNode jsonNode = mapper.readTree(jsonString);
        JsonNode evaluatedNode = evaluateExpressions(jsonNode);
        System.out.println(evaluatedNode.toString());
    }
}",            } else if (tokens.length == 2) {,ChatGPT
AssignmentInOperand,Avoid assignments in operands,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Stack;

public class Interpreter {

    private Interpreter() {
        super();
    }

    private static String getCode(final String inputFile) throws IOException {
        StringBuilder code = new StringBuilder();

        // Store the entire code
        try (BufferedReader br = new BufferedReader(new FileReader(inputFile))) {
            String line;
            while ((line = br.readLine()) != null) {
                code.append(line);
            }
        }

        return code.toString();
    }

    public static void interpret(final String inputFile) throws IOException {
        // Get the program as a string
        final String code = getCode(inputFile);

        // Create the Turing tape (static size)
        char[] tape = new char[30000];
        int tapePointer = 0;

        Stack<Integer> loopStack = new Stack<>();

        for (int i = 0; i < code.length(); i++) {
            switch (code.charAt(i)) {
                case ',':
                    // Read a character from input and store in tape
                    tape[tapePointer] = (char) System.in.read();
                    break;

                case '.':
                    // Output character from tape
                    System.out.print(tape[tapePointer]);
                    break;

                case '+':
                    // Increment value at tape position
                    tape[tapePointer]++;
                    break;

                case '-':
                    // Decrement value at tape position
                    tape[tapePointer]--;
                    break;

                case '>':
                    // Move tape pointer to the right
                    tapePointer++;
                    break;

                case '<':
                    // Move tape pointer to the left
                    tapePointer--;
                    break;

                case '[':
                    // Start of loop, push index to loop stack if current value is zero
                    if (tape[tapePointer] == 0) {
                        int loopEndIndex = findLoopEndIndex(code, i);
                        loopStack.push(loopEndIndex);
                    } else {
                        // If current value is not zero, continue execution
                        continue;
                    }
                    break;

                case ']':
                    // End of loop, pop index from loop stack
                    if (tape[tapePointer] == 0) {
                        loopStack.pop(); // Skip loop
                    } else {
                        // If current value is not zero, return to loop start
                        i = loopStack.peek() - 1; // -1 to offset the loop increment
                    }
                    break;

                default:
                    // Ignore other characters
                    break;
            }
        }
    }

    // Find the index of the matching ']' for the current '['
    private static int findLoopEndIndex(String code, int startIndex) {
        int nestedLoops = 0;
        for (int i = startIndex + 1; i < code.length(); i++) {
            if (code.charAt(i) == '[') {
                nestedLoops++;
            } else if (code.charAt(i) == ']') {
                if (nestedLoops == 0) {
                    return i;
                } else {
                    nestedLoops--;
                }
            }
        }
        throw new IllegalArgumentException(""No matching ']' found for '[' at index "" + startIndex);
    }
}",            while ((line = br.readLine()) != null) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Stack;

public class Interpreter {

    private Interpreter() {
        super();
    }

    private static String getCode(final String inputFile) throws IOException {
        StringBuilder code = new StringBuilder();

        // Store the entire code
        try (BufferedReader br = new BufferedReader(new FileReader(inputFile))) {
            String line;
            while ((line = br.readLine()) != null) {
                code.append(line);
            }
        }

        return code.toString();
    }

    public static void interpret(final String inputFile) throws IOException {
        // Get the program as a string
        final String code = getCode(inputFile);

        // Create the Turing tape (static size)
        char[] tape = new char[30000];
        int tapePointer = 0;

        Stack<Integer> loopStack = new Stack<>();

        for (int i = 0; i < code.length(); i++) {
            switch (code.charAt(i)) {
                case ',':
                    // Read a character from input and store in tape
                    tape[tapePointer] = (char) System.in.read();
                    break;

                case '.':
                    // Output character from tape
                    System.out.print(tape[tapePointer]);
                    break;

                case '+':
                    // Increment value at tape position
                    tape[tapePointer]++;
                    break;

                case '-':
                    // Decrement value at tape position
                    tape[tapePointer]--;
                    break;

                case '>':
                    // Move tape pointer to the right
                    tapePointer++;
                    break;

                case '<':
                    // Move tape pointer to the left
                    tapePointer--;
                    break;

                case '[':
                    // Start of loop, push index to loop stack if current value is zero
                    if (tape[tapePointer] == 0) {
                        int loopEndIndex = findLoopEndIndex(code, i);
                        loopStack.push(loopEndIndex);
                    } else {
                        // If current value is not zero, continue execution
                        continue;
                    }
                    break;

                case ']':
                    // End of loop, pop index from loop stack
                    if (tape[tapePointer] == 0) {
                        loopStack.pop(); // Skip loop
                    } else {
                        // If current value is not zero, return to loop start
                        i = loopStack.peek() - 1; // -1 to offset the loop increment
                    }
                    break;

                default:
                    // Ignore other characters
                    break;
            }
        }
    }

    // Find the index of the matching ']' for the current '['
    private static int findLoopEndIndex(String code, int startIndex) {
        int nestedLoops = 0;
        for (int i = startIndex + 1; i < code.length(); i++) {
            if (code.charAt(i) == '[') {
                nestedLoops++;
            } else if (code.charAt(i) == ']') {
                if (nestedLoops == 0) {
                    return i;
                } else {
                    nestedLoops--;
                }
            }
        }
        throw new IllegalArgumentException(""No matching ']' found for '[' at index "" + startIndex);
    }
}",            if (code.charAt(i) == '[') {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Stack;

public class Interpreter {

    private Interpreter() {
        super();
    }

    private static String getCode(final String inputFile) throws IOException {
        StringBuilder code = new StringBuilder();

        // Store the entire code
        try (BufferedReader br = new BufferedReader(new FileReader(inputFile))) {
            String line;
            while ((line = br.readLine()) != null) {
                code.append(line);
            }
        }

        return code.toString();
    }

    public static void interpret(final String inputFile) throws IOException {
        // Get the program as a string
        final String code = getCode(inputFile);

        // Create the Turing tape (static size)
        char[] tape = new char[30000];
        int tapePointer = 0;

        Stack<Integer> loopStack = new Stack<>();

        for (int i = 0; i < code.length(); i++) {
            switch (code.charAt(i)) {
                case ',':
                    // Read a character from input and store in tape
                    tape[tapePointer] = (char) System.in.read();
                    break;

                case '.':
                    // Output character from tape
                    System.out.print(tape[tapePointer]);
                    break;

                case '+':
                    // Increment value at tape position
                    tape[tapePointer]++;
                    break;

                case '-':
                    // Decrement value at tape position
                    tape[tapePointer]--;
                    break;

                case '>':
                    // Move tape pointer to the right
                    tapePointer++;
                    break;

                case '<':
                    // Move tape pointer to the left
                    tapePointer--;
                    break;

                case '[':
                    // Start of loop, push index to loop stack if current value is zero
                    if (tape[tapePointer] == 0) {
                        int loopEndIndex = findLoopEndIndex(code, i);
                        loopStack.push(loopEndIndex);
                    } else {
                        // If current value is not zero, continue execution
                        continue;
                    }
                    break;

                case ']':
                    // End of loop, pop index from loop stack
                    if (tape[tapePointer] == 0) {
                        loopStack.pop(); // Skip loop
                    } else {
                        // If current value is not zero, return to loop start
                        i = loopStack.peek() - 1; // -1 to offset the loop increment
                    }
                    break;

                default:
                    // Ignore other characters
                    break;
            }
        }
    }

    // Find the index of the matching ']' for the current '['
    private static int findLoopEndIndex(String code, int startIndex) {
        int nestedLoops = 0;
        for (int i = startIndex + 1; i < code.length(); i++) {
            if (code.charAt(i) == '[') {
                nestedLoops++;
            } else if (code.charAt(i) == ']') {
                if (nestedLoops == 0) {
                    return i;
                } else {
                    nestedLoops--;
                }
            }
        }
        throw new IllegalArgumentException(""No matching ']' found for '[' at index "" + startIndex);
    }
}",            } else if (code.charAt(i) == ']') {,ChatGPT
AvoidDuplicateLiterals,"The String literal ""German"" appears 6 times in this file; the first occurrence is on line 13","import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        // Your data list
        List<SourceEntity> myList = List.of(
                new SourceEntity(""Math"", ""2022-03-01"", 1.0f, ""g""),
                new SourceEntity(""Math"", ""2022-03-01"", 0.5f, ""d1""),
                new SourceEntity(""Math"", ""2022-03-01"", 0.5f, ""d2""),
                new SourceEntity(""German"", ""2022-03-02"", 2.0f, ""g""),
                new SourceEntity(""German"", ""2022-03-02"", 0.3f, ""d1""),
                new SourceEntity(""German"", ""2022-03-02"", 0.2f, ""d2""),
                new SourceEntity(""German"", ""2022-05-01"", 1.0f, ""g""),
                new SourceEntity(""German"", ""2022-05-01"", 0.5f, ""d1""),
                new SourceEntity(""German"", ""2022-05-01"", 0.4f, ""d2"")
        );

        // Group by subject, then by type, and map to Grade
        Map<String, Map<String, List<Grade>>> grouped = myList.stream()
                .collect(Collectors.groupingBy(SourceEntity::getSubject,
                        Collectors.groupingBy(SourceEntity::getType,
                                Collectors.mapping(s -> new Grade(s.getGrade(), s.getGradeDate()), Collectors.toList()))));

        // Map the result to MapObject
        List<MapObject> result = grouped.entrySet().stream()
                .map(entry -> {
                    MapObject mapObject = new MapObject();
                    mapObject.setSubject(entry.getKey());
                    mapObject.setG(entry.getValue().getOrDefault(""g"", new ArrayList<>()));
                    mapObject.setD1(entry.getValue().getOrDefault(""d1"", new ArrayList<>()));
                    mapObject.setD2(entry.getValue().getOrDefault(""d2"", new ArrayList<>()));
                    return mapObject;
                })
                .collect(Collectors.toList());

        // Print result (convert to JSON)
        System.out.println(result);
    }
}","                new SourceEntity(""German"", ""2022-03-02"", 2.0f, ""g""),",ChatGPT
AvoidDecimalLiteralsInBigDecimalConstructor,Avoid creating BigDecimal with a decimal (float/double) literal. Use a String literal,"import java.math.BigDecimal;
import java.text.MessageFormat;
import java.text.NumberFormat;
import java.util.Locale;

public class Main {
    public static void main(String[] args) {
        Locale.setDefault(Locale.ENGLISH);

        BigDecimal value = new BigDecimal(946.2);

        // Format the value as a currency string according to the locale
        NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.getDefault());
        String formattedValue = currencyFormat.format(value);

        // Create the JSON string using MessageFormat
        String json = MessageFormat.format(""""""
        {{
          """"value"""": {0},
          """"description"""": """"O valor Ã© {1}""""
        }}
        """""", value, formattedValue);

        System.out.println(json);
    }
}",        BigDecimal value = new BigDecimal(946.2);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: JFrame.getContentPane() ,"import java.awt.Container;
import java.awt.Dimension;
import java.io.IOException;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;

import org.apache.batik.swing.JSVGCanvas;
import org.apache.batik.swing.svg.SVGDocumentLoader;
import org.apache.batik.swing.svg.SVGUserAgentAdapter;
import org.w3c.dom.svg.SVGDocument;

@SuppressWarnings(""serial"")
class Example extends JFrame {

    public static void main(String[] args) {
        new Example();
    }

    public Example() {
        Container c = getContentPane();
        JPanel panel = new JPanel();
        try {
            SVGDocument svgDocument = loadSVG(getClass().getResource(""tabler-icon-beach.svg""));
            JSVGCanvas svgCanvas = new JSVGCanvas();
            svgCanvas.setDocument(svgDocument);
            svgCanvas.setPreferredSize(new Dimension(18, 18));
            JButton button = new JButton(""Test button"", new ImageIcon(svgCanvas.createImage()));
            panel.add(button);
        } catch (IOException e) {
            e.printStackTrace();
        }
        c.add(panel);
        this.pack();
        this.setLocationRelativeTo(null);
        this.setVisible(true);
    }

    private SVGDocument loadSVG(java.net.URL url) throws IOException {
        SVGDocumentLoader loader = new SVGDocumentLoader(new SVGUserAgentAdapter());
        return loader.loadDocument(url.toString());
    }
}",        Container c = getContentPane();,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.pack() ,"import java.awt.Container;
import java.awt.Dimension;
import java.io.IOException;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;

import org.apache.batik.swing.JSVGCanvas;
import org.apache.batik.swing.svg.SVGDocumentLoader;
import org.apache.batik.swing.svg.SVGUserAgentAdapter;
import org.w3c.dom.svg.SVGDocument;

@SuppressWarnings(""serial"")
class Example extends JFrame {

    public static void main(String[] args) {
        new Example();
    }

    public Example() {
        Container c = getContentPane();
        JPanel panel = new JPanel();
        try {
            SVGDocument svgDocument = loadSVG(getClass().getResource(""tabler-icon-beach.svg""));
            JSVGCanvas svgCanvas = new JSVGCanvas();
            svgCanvas.setDocument(svgDocument);
            svgCanvas.setPreferredSize(new Dimension(18, 18));
            JButton button = new JButton(""Test button"", new ImageIcon(svgCanvas.createImage()));
            panel.add(button);
        } catch (IOException e) {
            e.printStackTrace();
        }
        c.add(panel);
        this.pack();
        this.setLocationRelativeTo(null);
        this.setVisible(true);
    }

    private SVGDocument loadSVG(java.net.URL url) throws IOException {
        SVGDocumentLoader loader = new SVGDocumentLoader(new SVGUserAgentAdapter());
        return loader.loadDocument(url.toString());
    }
}",        this.pack();,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setLocationRelativeTo(Component) ,"import java.awt.Container;
import java.awt.Dimension;
import java.io.IOException;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;

import org.apache.batik.swing.JSVGCanvas;
import org.apache.batik.swing.svg.SVGDocumentLoader;
import org.apache.batik.swing.svg.SVGUserAgentAdapter;
import org.w3c.dom.svg.SVGDocument;

@SuppressWarnings(""serial"")
class Example extends JFrame {

    public static void main(String[] args) {
        new Example();
    }

    public Example() {
        Container c = getContentPane();
        JPanel panel = new JPanel();
        try {
            SVGDocument svgDocument = loadSVG(getClass().getResource(""tabler-icon-beach.svg""));
            JSVGCanvas svgCanvas = new JSVGCanvas();
            svgCanvas.setDocument(svgDocument);
            svgCanvas.setPreferredSize(new Dimension(18, 18));
            JButton button = new JButton(""Test button"", new ImageIcon(svgCanvas.createImage()));
            panel.add(button);
        } catch (IOException e) {
            e.printStackTrace();
        }
        c.add(panel);
        this.pack();
        this.setLocationRelativeTo(null);
        this.setVisible(true);
    }

    private SVGDocument loadSVG(java.net.URL url) throws IOException {
        SVGDocumentLoader loader = new SVGDocumentLoader(new SVGUserAgentAdapter());
        return loader.loadDocument(url.toString());
    }
}",        this.setLocationRelativeTo(null);,ChatGPT
ConstructorCallsOverridableMethod,Overridable method called during object construction: Window.setVisible(boolean) ,"import java.awt.Container;
import java.awt.Dimension;
import java.io.IOException;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;

import org.apache.batik.swing.JSVGCanvas;
import org.apache.batik.swing.svg.SVGDocumentLoader;
import org.apache.batik.swing.svg.SVGUserAgentAdapter;
import org.w3c.dom.svg.SVGDocument;

@SuppressWarnings(""serial"")
class Example extends JFrame {

    public static void main(String[] args) {
        new Example();
    }

    public Example() {
        Container c = getContentPane();
        JPanel panel = new JPanel();
        try {
            SVGDocument svgDocument = loadSVG(getClass().getResource(""tabler-icon-beach.svg""));
            JSVGCanvas svgCanvas = new JSVGCanvas();
            svgCanvas.setDocument(svgDocument);
            svgCanvas.setPreferredSize(new Dimension(18, 18));
            JButton button = new JButton(""Test button"", new ImageIcon(svgCanvas.createImage()));
            panel.add(button);
        } catch (IOException e) {
            e.printStackTrace();
        }
        c.add(panel);
        this.pack();
        this.setLocationRelativeTo(null);
        this.setVisible(true);
    }

    private SVGDocument loadSVG(java.net.URL url) throws IOException {
        SVGDocumentLoader loader = new SVGDocumentLoader(new SVGUserAgentAdapter());
        return loader.loadDocument(url.toString());
    }
}",        this.setVisible(true);,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.ArrayList;
import java.util.List;

public class Solution {

    public static int[] solve(int n, int[] A, int[][] commands) {
        List<Integer> minValues = new ArrayList<>();
        minValues.add(Integer.MAX_VALUE);

        for (int[] command : commands) {
            if (command[0] == 1) {
                int p = command[1];
                int q = command[2];
                A[p] = q;
                // Update minValues if necessary
                if (q < minValues.get(0)) {
                    minValues.set(0, q);
                }
            } else if (command[0] == 2) {
                int r = command[2];
                // Update minValues if necessary
                if (r < minValues.get(0)) {
                    minValues.set(0, r);
                }
            }
        }

        // Apply the minimum value to all elements in A
        int minValue = minValues.get(0);
        for (int i = 0; i < n; i++) {
            A[i] = Math.min(A[i], minValue);
        }

        return A;
    }

    public static void main(String[] args) {
        int n = 4;
        int[] A = {2, 4, 1, 4};
        int[][] commands = {{1, 1, 30}, {1, 2, 4}, {2, -1, 10}};
        int[] result = solve(n, A, commands);
        for (int num : result) {
            System.out.print(num + "" "");
        }
    }
}",            if (command[0] == 1) {,ChatGPT
AvoidLiteralsInIfCondition,Avoid using literals in if statements,"import java.util.ArrayList;
import java.util.List;

public class Solution {

    public static int[] solve(int n, int[] A, int[][] commands) {
        List<Integer> minValues = new ArrayList<>();
        minValues.add(Integer.MAX_VALUE);

        for (int[] command : commands) {
            if (command[0] == 1) {
                int p = command[1];
                int q = command[2];
                A[p] = q;
                // Update minValues if necessary
                if (q < minValues.get(0)) {
                    minValues.set(0, q);
                }
            } else if (command[0] == 2) {
                int r = command[2];
                // Update minValues if necessary
                if (r < minValues.get(0)) {
                    minValues.set(0, r);
                }
            }
        }

        // Apply the minimum value to all elements in A
        int minValue = minValues.get(0);
        for (int i = 0; i < n; i++) {
            A[i] = Math.min(A[i], minValue);
        }

        return A;
    }

    public static void main(String[] args) {
        int n = 4;
        int[] A = {2, 4, 1, 4};
        int[][] commands = {{1, 1, 30}, {1, 2, 4}, {2, -1, 10}};
        int[] result = solve(n, A, commands);
        for (int num : result) {
            System.out.print(num + "" "");
        }
    }
}",            } else if (command[0] == 2) {,ChatGPT
CloseResource,Ensure that resources like this ExecutorService object are closed after use,"import java.util.concurrent.*;

public class LimitedVirtualThreadExecutor {

    private static final int MAX_THREAD_COUNT = 10; // Adjust this to your desired limit
    private static final Semaphore semaphore = new Semaphore(MAX_THREAD_COUNT);

    public static ExecutorService newLimitedVirtualThreadExecutor() {
        return Executors.unconfigurableExecutorService(
                new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                        60L, TimeUnit.SECONDS,
                        new SynchronousQueue<>()) {
                    @Override
                    public void execute(Runnable command) {
                        semaphore.acquireUninterruptibly();
                        super.execute(() -> {
                            try {
                                command.run();
                            } finally {
                                semaphore.release();
                            }
                        });
                    }
                }
        );
    }

    public static void main(String[] args) {
        ExecutorService executor = newLimitedVirtualThreadExecutor();
        for (int i = 0; i < 20; i++) {
            executor.execute(() -> {
                System.out.println(""Executing task..."");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        executor.shutdown();
    }
}",        ExecutorService executor = newLimitedVirtualThreadExecutor();,ChatGPT
SimpleDateFormatNeedsLocale,"When instantiating a SimpleDateFormat object, specify a Locale","import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateUtils {

    private static final String DATE_PATTERN = ""yyyy-MM-dd HH:mm:ss.SSS"";

    public static void main(String[] args) {
        DateUtils dateUtils = new DateUtils();
        System.out.println(""Last Year: "" + dateUtils.getLastYear());
        System.out.println(""Previous Month: "" + dateUtils.getPreviousMonth());
    }

    private String getLastYear() {
        DateFormat format = new SimpleDateFormat(DATE_PATTERN);
        Calendar c = Calendar.getInstance();
        c.setTime(new Date());
        c.add(Calendar.YEAR, -1);
        c.set(Calendar.MONTH, Calendar.NOVEMBER); // Set to same month
        c.set(Calendar.DAY_OF_MONTH, 1);
        c.set(Calendar.HOUR_OF_DAY, 0);
        c.set(Calendar.MINUTE, 0);
        c.set(Calendar.SECOND, 0);
        c.set(Calendar.MILLISECOND, 0);
        return format.format(c.getTime());
    }

    private String getPreviousMonth() {
        DateFormat format = new SimpleDateFormat(DATE_PATTERN);
        Calendar c = Calendar.getInstance();
        c.setTime(new Date());
        c.add(Calendar.MONTH, -1);
        c.set(Calendar.DAY_OF_MONTH, c.getActualMaximum(Calendar.DAY_OF_MONTH));
        c.set(Calendar.HOUR_OF_DAY, 23);
        c.set(Calendar.MINUTE, 59);
        c.set(Calendar.SECOND, 59);
        c.set(Calendar.MILLISECOND, 999);
        return format.format(c.getTime());
    }
}",        DateFormat format = new SimpleDateFormat(DATE_PATTERN);,ChatGPT
SimpleDateFormatNeedsLocale,"When instantiating a SimpleDateFormat object, specify a Locale","import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateUtils {

    private static final String DATE_PATTERN = ""yyyy-MM-dd HH:mm:ss.SSS"";

    public static void main(String[] args) {
        DateUtils dateUtils = new DateUtils();
        System.out.println(""Last Year: "" + dateUtils.getLastYear());
        System.out.println(""Previous Month: "" + dateUtils.getPreviousMonth());
    }

    private String getLastYear() {
        DateFormat format = new SimpleDateFormat(DATE_PATTERN);
        Calendar c = Calendar.getInstance();
        c.setTime(new Date());
        c.add(Calendar.YEAR, -1);
        c.set(Calendar.MONTH, Calendar.NOVEMBER); // Set to same month
        c.set(Calendar.DAY_OF_MONTH, 1);
        c.set(Calendar.HOUR_OF_DAY, 0);
        c.set(Calendar.MINUTE, 0);
        c.set(Calendar.SECOND, 0);
        c.set(Calendar.MILLISECOND, 0);
        return format.format(c.getTime());
    }

    private String getPreviousMonth() {
        DateFormat format = new SimpleDateFormat(DATE_PATTERN);
        Calendar c = Calendar.getInstance();
        c.setTime(new Date());
        c.add(Calendar.MONTH, -1);
        c.set(Calendar.DAY_OF_MONTH, c.getActualMaximum(Calendar.DAY_OF_MONTH));
        c.set(Calendar.HOUR_OF_DAY, 23);
        c.set(Calendar.MINUTE, 59);
        c.set(Calendar.SECOND, 59);
        c.set(Calendar.MILLISECOND, 999);
        return format.format(c.getTime());
    }
}",        DateFormat format = new SimpleDateFormat(DATE_PATTERN);,ChatGPT
AvoidFieldNameMatchingMethodName,Field unfix has the same name as a method,"class Fix<F> {
    private final F unfix;

    public Fix(F unfix) {
        this.unfix = unfix;
    }

    public F unfix() {
        return unfix;
    }
}",    private final F unfix;,ChatGPT
AssignmentInOperand,Avoid assignments in operands,"import java.io.*;

public class FileUpdater {

    public static void main(String[] args) {
        String filePath = ""your_file.txt"";
        String[] updates = {
            ""Bob White 1"", // Example update
            // Add more updates as needed
        };

        try {
            // Read the file into memory
            StringBuilder content = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    content.append(line).append(System.lineSeparator());
                }
            }

            // Modify the content in memory
            for (String update : updates) {
                String[] parts = update.split(""\\s"", 3); // Assuming space-separated fields
                String name = parts[0] + "" "" + parts[1];
                String newValue = parts[2];
                content = new StringBuilder(content.toString().replaceAll(""^"" + name + ""\\s\\d$"", update));
            }

            // Write the modified content back to the file
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
                writer.write(content.toString());
            }
            
            System.out.println(""File updated successfully."");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",                while ((line = reader.readLine()) != null) {,ChatGPT
TestClassWithoutTestCases,"The class 'SiteServiceImplTest' might be a test class, but it contains no test cases.","@PrepareForTest(LoggingUtils.class)
@RunWith(PowerMockRunner.class)
public class SiteServiceImplTest {

    @Test
    public void test() {
        // Mock the static method
        PowerMockito.mockStatic(LoggingUtils.class);

        // Define the behavior of the static method (if needed)
        Mockito.when(LoggingUtils.info(Mockito.anyString())).thenReturn(null);

        // Now, proceed with your test code that invokes the static method
        Page<SiteDTO> result = siteService.findAll(request, sort);

        // Verify that the static method was called
        PowerMockito.verifyStatic(LoggingUtils.class, Mockito.times(1));
        LoggingUtils.info(Mockito.anyString());
    }
}",public class SiteServiceImplTest {,ChatGPT
CloseResource,Ensure that resources like this Scanner object are closed after use,"import java.util.Scanner;

public class GrossPayCalculator {

    static void story(Scanner scanner) {
        System.out.println(""Which season the day is of?"");
        String season = scanner.nextLine();
        System.out.println(""How is that day?"");
        String adjective = scanner.nextLine();
        System.out.println(""What is the number?"");
        int number = scanner.nextInt();
        System.out.println(""On a "" + adjective + "" "" + season + "" day,\nyou read "" + number + "" pages of book."");
    }

    public static void main(String[] args) {

        int hours = 0;
        System.out.println(""How many hours did you work?: "");
        Scanner scanner = new Scanner(System.in);
        hours = scanner.nextInt();

        double payRate = 0;
        System.out.println(""What is your pay rate?: "");
        payRate = scanner.nextDouble();

        double grossPay = hours * payRate;
        System.out.println(""Gross pay: "" + grossPay);

        story(scanner); // Pass the scanner object to the story method

        scanner.close();
    }
}",        Scanner scanner = new Scanner(System.in);,ChatGPT
